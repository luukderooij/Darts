
==================================================
CONFIG FILE: docker-compose.yml
==================================================

version: '3.8'

services:
  backend:
    build: ./backend
    container_name: darts-backend
    restart: always
    volumes:
      # Koppel de database aan een map op je server zodat data bewaard blijft
      - ./data/darts.db:/app/darts.db
      # Koppel logs
      - ./logs:/app/logs
    environment:
      - DATABASE_URL=sqlite:////app/darts.db
      - SECRET_KEY=your_secret_key_here
    # Geen ports mapping nodig, want nginx praat intern met backend

  frontend:
    build: ./frontend
    container_name: darts-frontend
    restart: always
    ports:
      - "80:80" # De app is bereikbaar op poort 80 van je server
    depends_on:
      - backend

==================================================
CONFIG FILE: README.md
==================================================

# Darts






Start dev enviroment:
 CTRL SHIFT B

 
.venv/Scripts/Activate.ps1
cd backend
uvicorn app.main:app --reload

cd frontend
npm run dev





Log in op je Proxmox VM (bijv. Ubuntu/Debian) en installeer Docker:

```bash
# Update pakketten
sudo apt update && sudo apt upgrade -y

# Installeer Docker & Docker Compose
curl -fsSL [https://get.docker.com](https://get.docker.com) -o get-docker.sh
sudo sh get-docker.sh
sudo usermod -aG docker $USER
# Log uit en weer in om de groepsrechten toe te passen


# 1. Clone de code
git clone [https://github.com/luukderooij/Darts.git](https://github.com/luukderooij/Darts.git)
cd Darts

# 2. Maak mappen voor persistente data
mkdir -p data logs

# 3. Start de containers
docker compose up -d --build

==================================================
CONFIG FILE: .env.example
==================================================



==================================================
FILE: backend/app\main.py
==================================================

from contextlib import asynccontextmanager
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware

# Import core settings and database logic
from app.core.config import settings
from app.db.session import init_db

# Import API route modules
from app.api import auth, users, players, tournaments, matches, websockets, dartboards, teams

@asynccontextmanager
async def lifespan(app: FastAPI):
    """
    Lifespan context manager for handling startup and shutdown events.
    """
    # --- Startup ---
    print("Starting up Dart Tournament Manager...")
    init_db()
    
    yield
    
    # --- Shutdown ---
    print("Shutting down...")

app = FastAPI(
    title="Dart Tournament Manager API",
    description="Backend for managing dart tournaments, players, and real-time scores.",
    version="1.0.0",
    lifespan=lifespan
)

# --- CORS Configuration ---
origins = [
    "http://localhost:5173",
    "http://localhost:3000",
    "http://127.0.0.1:5173",
    "*" 
]

app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# --- Register Routers ---
app.include_router(auth.router, prefix="/api/auth", tags=["Authentication"])
app.include_router(users.router, prefix="/api/users", tags=["Users"])
app.include_router(players.router, prefix="/api/players", tags=["Players"])
app.include_router(tournaments.router, prefix="/api/tournaments", tags=["Tournaments"])
app.include_router(matches.router, prefix="/api/matches", tags=["Matches"])
app.include_router(dartboards.router, prefix="/api/dartboards", tags=["Dartboards"])
app.include_router(teams.router, prefix="/api/teams", tags=["Teams"])

# WebSocket router for real-time logs
# Note: The frontend will connect via ws://localhost:8000/ws/logs
app.include_router(websockets.router, prefix="/ws", tags=["WebSockets"])
app.include_router(dartboards.router, prefix="/api/dartboards", tags=["Dartboards"])

# --- Root Endpoint (Health Check) ---
@app.get("/")
def read_root():
    return {
        "status": "online",
        "message": "Dart Tournament Manager API is running",
        "docs_url": "/docs" 
    }

==================================================
FILE: backend/app\__init__.py
==================================================

__version__ = "0.0.1"

==================================================
FILE: backend/app\api\auth.py
==================================================

from datetime import timedelta
from typing import Annotated
from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordRequestForm
from sqlmodel import Session, select

from app.db.session import get_session
from app.core.security import (
    create_access_token,
    get_password_hash,
    verify_password,
    ACCESS_TOKEN_EXPIRE_MINUTES
)
from app.models.user import User
from app.schemas.user import UserCreate, UserRead
from app.schemas.token import Token

router = APIRouter()

# --- Helper Function ---
def authenticate_user(session: Session, email: str, password: str):
    # We look up the user by EMAIL
    statement = select(User).where(User.email == email)
    user = session.exec(statement).first()
    if not user:
        return False
    if not verify_password(password, user.hashed_password):
        return False
    return user

# --- Endpoints ---

@router.post("/login", response_model=Token)
def login_for_access_token(
    form_data: Annotated[OAuth2PasswordRequestForm, Depends()],
    session: Session = Depends(get_session)
):
    # Note: OAuth2PasswordRequestForm always has a field named 'username'.
    # We are using that field to carry the 'email' address.
    user = authenticate_user(session, form_data.username, form_data.password)
    
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect email or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
        
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    
    # We store the EMAIL in the 'sub' (subject) of the token
    access_token = create_access_token(
        data={"sub": user.email}, 
        expires_delta=access_token_expires
    )
    
    return {"access_token": access_token, "token_type": "bearer"}

@router.post("/register", response_model=UserRead)
def register_user(user_in: UserCreate, session: Session = Depends(get_session)):
    # 1. Check if email already exists
    existing_user = session.exec(select(User).where(User.email == user_in.email)).first()
    if existing_user:
        raise HTTPException(
            status_code=400, 
            detail="Email already registered"
        )
    
    # 2. Create new user
    user = User(
        first_name=user_in.first_name,
        last_name=user_in.last_name,
        email=user_in.email,
        hashed_password=get_password_hash(user_in.password)
    )
    
    session.add(user)
    session.commit()
    session.refresh(user)
    
    return user

==================================================
FILE: backend/app\api\dartboards.py
==================================================

from typing import List
from fastapi import APIRouter, Depends, HTTPException
from sqlmodel import Session, select

from app.db.session import get_session
from app.models.dartboard import Dartboard
from app.schemas.dartboard import DartboardCreate, DartboardRead
from app.api.users import get_current_user # Auth check

router = APIRouter()

@router.post("/", response_model=DartboardRead)
def create_board(
    board_in: DartboardCreate,
    session: Session = Depends(get_session),
    current_user = Depends(get_current_user)
):
    board = Dartboard(name=board_in.name, number=board_in.number)
    session.add(board)
    session.commit()
    session.refresh(board)
    return board

@router.get("/", response_model=List[DartboardRead])
def read_boards(
    session: Session = Depends(get_session),
    current_user = Depends(get_current_user)
):
    # Sort by number automatically (1, 2, 3...)
    statement = select(Dartboard).order_by(Dartboard.number)
    boards = session.exec(statement).all()
    return boards

@router.delete("/{board_id}")
def delete_board(
    board_id: int,
    session: Session = Depends(get_session),
    current_user = Depends(get_current_user)
):
    board = session.get(Dartboard, board_id)
    if not board:
        raise HTTPException(status_code=404, detail="Board not found")
    session.delete(board)
    session.commit()
    return {"ok": True}

==================================================
FILE: backend/app\api\matches.py
==================================================

import logging
from typing import List, Optional
from fastapi import APIRouter, Depends, HTTPException, status, Header
from sqlmodel import Session, select

from app.db.session import get_session
from app.models.match import Match
from app.models.player import Player
from app.models.tournament import Tournament
from app.models.user import User
from app.schemas.match import MatchRead, MatchScoreUpdate
from app.api.users import get_current_user
from app.services.tournament_gen import check_and_advance_knockout

logger = logging.getLogger("dart_app")

router = APIRouter()

# --- Helpers ---

def get_match_or_404(match_id: int, session: Session) -> Match:
    match = session.get(Match, match_id)
    if not match:
        raise HTTPException(status_code=404, detail="Match not found")
    return match

# --- Endpoints ---

@router.put("/{match_id}/score", response_model=MatchRead)
def update_match_score(
    match_id: int,
    score_in: MatchScoreUpdate,
    current_user: Optional[User] = Depends(get_current_user), 
    x_scorer_token: Optional[str] = Header(None, alias="X-Scorer-Token"),
    session: Session = Depends(get_session)
):
    # ... (Auth en ophalen match blijft hetzelfde) ...
    match = get_match_or_404(match_id, session)
    tournament = session.get(Tournament, match.tournament_id)
    
    # ... (Auth checks blijven hetzelfde) ...
    is_authorized = False
    if current_user and tournament.user_id == current_user.id:
        is_authorized = True
    if not is_authorized and x_scorer_token:
        if x_scorer_token == tournament.scorer_uuid:
            is_authorized = True
            
    if not is_authorized:
         raise HTTPException(status_code=403, detail="Not authorized.")

    # Update
    match.score_p1 = score_in.score_p1
    match.score_p2 = score_in.score_p2
    match.is_completed = score_in.is_completed
    
    session.add(match)
    session.commit()
    session.refresh(match)
    
    # --- NIEUWE LOGICA: Check of we door moeten naar de volgende ronde ---
    if match.is_completed and match.poule_number is None:
        # Dit is een Knockout wedstrijd die net is afgerond.
        # Check of de hele ronde klaar is.
        check_and_advance_knockout(match.tournament_id, match.round_number, session)
    # ---------------------------------------------------------------------
    
    # Logging
    logger.info(f"MATCH {match.id}: {match.score_p1} - {match.score_p2}")
    
    # Return response (blijft hetzelfde)
    p1 = session.get(Player, match.player1_id) if match.player1_id else None
    p2 = session.get(Player, match.player2_id) if match.player2_id else None
    
    match_dict = match.model_dump()
    match_dict['player1_name'] = p1.name if p1 else "Bye"
    match_dict['player2_name'] = p2.name if p2 else "Bye"

    return match_dict

@router.get("/by-tournament/{public_uuid}", response_model=List[MatchRead])
def get_matches_public(
    public_uuid: str,
    session: Session = Depends(get_session)
):
    # 1. Resolve Tournament
    statement = select(Tournament).where(Tournament.public_uuid == public_uuid)
    tournament = session.exec(statement).first()
    
    if not tournament:
        # Check scorer UUID too
        statement_scorer = select(Tournament).where(Tournament.scorer_uuid == public_uuid)
        tournament = session.exec(statement_scorer).first()
        
    if not tournament:
        raise HTTPException(status_code=404, detail="Tournament not found")
        
    # 2. Get Matches
    statement_matches = select(Match).where(Match.tournament_id == tournament.id).order_by(Match.id)
    matches = session.exec(statement_matches).all()
    
    # 3. Bulk Fetch Player Names
    player_ids = set()
    for m in matches:
        if m.player1_id: player_ids.add(m.player1_id)
        if m.player2_id: player_ids.add(m.player2_id)
        
    players = session.exec(select(Player).where(Player.id.in_(player_ids))).all()
    player_map = {p.id: p.name for p in players}
    
    # 4. Attach names to response
    results = []
    for m in matches:
        # Convert the SQLModel to a dict so we can add extra fields
        m_data = m.model_dump()
        m_data['player1_name'] = player_map.get(m.player1_id, "Bye")
        m_data['player2_name'] = player_map.get(m.player2_id, "Bye")
        results.append(m_data)
        
    return results

==================================================
FILE: backend/app\api\players.py
==================================================

from typing import List
from fastapi import APIRouter, Depends, HTTPException
from sqlmodel import Session, select

from app.db.session import get_session
from app.models.player import Player
from app.schemas.player import PlayerCreate, PlayerRead

# --- THE FIX IS HERE ---
# We import from 'users', not 'auth'
from app.api.users import get_current_user 
from app.models.user import User

router = APIRouter()

@router.post("/", response_model=PlayerRead)
def create_player(
    player_in: PlayerCreate,
    session: Session = Depends(get_session),
    current_user: User = Depends(get_current_user)
):
    player = Player(
        first_name=player_in.first_name,
        last_name=player_in.last_name,
        nickname=player_in.nickname,
        email=player_in.email,
        # user_id=current_user.id (Uncomment if you want to link players to the admin who created them)
    )
    
    session.add(player)
    session.commit()
    session.refresh(player)
    return player

@router.get("/", response_model=List[PlayerRead])
def read_players(
    skip: int = 0,
    limit: int = 100,
    session: Session = Depends(get_session),
    current_user: User = Depends(get_current_user)
):
    statement = select(Player).offset(skip).limit(limit)
    players = session.exec(statement).all()
    return players

@router.delete("/{player_id}")
def delete_player(
    player_id: int,
    session: Session = Depends(get_session),
    current_user: User = Depends(get_current_user)
):
    player = session.get(Player, player_id)
    if not player:
        raise HTTPException(status_code=404, detail="Player not found")
        
    session.delete(player)
    session.commit()
    return {"ok": True}

==================================================
FILE: backend/app\api\teams.py
==================================================

# FILE: backend/app/api/teams.py
import random
from typing import List
from fastapi import APIRouter, Depends, HTTPException
from sqlmodel import Session, select

from app.db.session import get_session
from app.models.team import Team
from app.models.player import Player
from app.models.tournament import Tournament
from app.schemas.team import TeamCreateManual, TeamAutoGenerate, TeamRead
from app.api.users import get_current_user # Beveiliging

router = APIRouter()

# --- HELPER: Automatische Naam Genereren ---
def generate_team_name(players: List[Player]) -> str:
    """
    Genereert een naam zoals 'Van Gerwen & Van Barneveld' 
    of 'Michael & Raymond' als er geen achternaam is.
    """
    names = []
    for p in players:
        # Gebruik achternaam als die er is, anders voornaam
        name_part = p.last_name if p.last_name else p.first_name
        if p.nickname: # Optioneel: nickname gebruiken
             name_part = p.nickname
        names.append(name_part)
    
    return " & ".join(names)

# --- ENDPOINT 1: Handmatig Team Aanmaken ---
@router.post("/manual", response_model=TeamRead)
def create_manual_team(
    team_in: TeamCreateManual,
    session: Session = Depends(get_session),
    current_user = Depends(get_current_user)
):
    # 1. Check of toernooi bestaat
    tournament = session.get(Tournament, team_in.tournament_id)
    if not tournament:
        raise HTTPException(status_code=404, detail="Toernooi niet gevonden")

    # 2. Haal spelers op
    players = session.exec(select(Player).where(Player.id.in_(team_in.player_ids))).all()
    if len(players) != len(team_in.player_ids):
        raise HTTPException(status_code=400, detail="Eén of meer speler IDs bestaan niet.")
    
    if len(players) < 2:
        raise HTTPException(status_code=400, detail="Een team moet minimaal 2 spelers hebben.")

    # 3. Bepaal de naam (Eis 3: Automatisch als leeg)
    final_name = team_in.name
    if not final_name or final_name.strip() == "":
        final_name = generate_team_name(players)

    # 4. Opslaan
    team = Team(name=final_name, tournament_id=team_in.tournament_id)
    team.players = players # SQLModel regelt de koppeltabel automatisch
    
    session.add(team)
    session.commit()
    session.refresh(team)
    
    return team

# --- ENDPOINT 2: Automatisch Random Teams Genereren ---
@router.post("/auto", response_model=List[TeamRead])
def create_auto_teams(
    auto_in: TeamAutoGenerate,
    session: Session = Depends(get_session),
    current_user = Depends(get_current_user)
):
    # 1. Haal spelers op
    players = session.exec(select(Player).where(Player.id.in_(auto_in.player_ids))).all()
    
    # Check even aantal (voor koppels)
    if len(players) % 2 != 0:
        raise HTTPException(status_code=400, detail="Aantal spelers moet even zijn om koppels te maken.")

    # 2. Husselen (Eis 1: Random)
    # We maken een kopie van de lijst om te husselen
    shuffled_players = list(players)
    random.shuffle(shuffled_players)

    new_teams = []

    # 3. Loop door de lijst in stappen van 2
    for i in range(0, len(shuffled_players), 2):
        p1 = shuffled_players[i]
        p2 = shuffled_players[i+1]
        
        pair_players = [p1, p2]
        
        # Eis 3: Automatische naam
        auto_name = generate_team_name(pair_players)
        
        team = Team(name=auto_name, tournament_id=auto_in.tournament_id)
        team.players = pair_players
        
        session.add(team)
        new_teams.append(team)

    session.commit()
    
    # Refresh alle teams om ID's te krijgen
    for t in new_teams:
        session.refresh(t)
        
    return new_teams

# --- ENDPOINT 3: Teams ophalen van een toernooi ---
@router.get("/{tournament_id}", response_model=List[TeamRead])
def read_teams(
    tournament_id: int,
    session: Session = Depends(get_session),
    current_user = Depends(get_current_user)
):
    teams = session.exec(select(Team).where(Team.tournament_id == tournament_id)).all()
    return teams

==================================================
FILE: backend/app\api\tournaments.py
==================================================

# FILE: backend/app/api/tournaments.py
import uuid
import math 
from typing import List, Any
from fastapi import APIRouter, Depends, HTTPException, Query
from sqlmodel import Session, select
from sqlalchemy.orm import selectinload

from app.db.session import get_session
from app.models.tournament import Tournament
from app.models.user import User
from app.models.player import Player
from app.models.match import Match
from app.models.dartboard import Dartboard 
from app.api.users import get_current_user 
from app.schemas.tournament import TournamentUpdate

from app.schemas.tournament import (
    TournamentCreate, 
    TournamentRead, 
    TournamentUpdate, 
    TournamentReadWithMatches # <--- Nieuwe import
)

from app.services.tournament_gen import (
    generate_poule_phase, 
    generate_knockout_from_poules,
    generate_round_robin_global,
    generate_knockout
)

router = APIRouter()

@router.post("/", response_model=TournamentRead)
def create_tournament(
    tourn_in: TournamentCreate,
    session: Session = Depends(get_session),
    current_user: User = Depends(get_current_user)
):
    # 1. Verify Players
    players_to_link = []
    for pid in tourn_in.player_ids:
        p = session.get(Player, pid)
        if not p:
            raise HTTPException(status_code=400, detail=f"Invalid player ID: {pid}")
        players_to_link.append(p)
        
    if len(players_to_link) < 2:
        raise HTTPException(status_code=400, detail="Need at least 2 players")

    # 2. Validatie Poulegrootte
    if tourn_in.format == "hybrid" and tourn_in.number_of_poules > 0:
        avg_players = math.ceil(len(players_to_link) / tourn_in.number_of_poules)
        if avg_players > 7:
            raise HTTPException(
                status_code=400, 
                detail=f"Te veel spelers per poule! Je probeert {avg_players} spelers per poule te stoppen. Het maximum is 7."
            )

    # 3. Verify Boards
    boards_to_link = []
    for bid in tourn_in.board_ids:
        b = session.get(Dartboard, bid)
        if not b:
             raise HTTPException(status_code=400, detail=f"Invalid board ID: {bid}")
        boards_to_link.append(b)

    # 4. Create Tournament Object
    tourn_data = tourn_in.model_dump(exclude={"player_ids", "board_ids"})
    tournament = Tournament.model_validate(tourn_data)
    
    tournament.user_id = current_user.id
    tournament.status = "active"
    tournament.scorer_uuid = str(uuid.uuid4())
    tournament.public_uuid = str(uuid.uuid4())
    
    # 5. Link Relations
    tournament.players = players_to_link
    tournament.boards = boards_to_link 
    
    session.add(tournament)
    session.commit()
    session.refresh(tournament)
    
    # 6. Generate Matches based on Format
    if tournament.format == "hybrid":
        generate_poule_phase(
            tournament_id=tournament.id, 
            players=players_to_link, 
            num_poules=tournament.number_of_poules, 
            legs_best_of=tournament.starting_legs_group,
            sets_best_of=tournament.sets_per_match,
            session=session
        )
    elif tournament.format == "round_robin":
        generate_round_robin_global(
            tournament_id=tournament.id,
            players=players_to_link,
            legs_best_of=tournament.starting_legs_group,
            sets_best_of=tournament.sets_per_match,
            session=session
        )
    elif tournament.format == "knockout":
        generate_knockout(
            tournament_id=tournament.id,
            players=players_to_link,
            legs_best_of=tournament.starting_legs_ko,
            sets_best_of=tournament.sets_per_match,
            session=session
        )
    
    return tournament

@router.get("/{tournament_id}", response_model=TournamentRead)
def read_tournament_by_id(
    tournament_id: int,
    session: Session = Depends(get_session),
    current_user: User = Depends(get_current_user)
):
    tournament = session.get(Tournament, tournament_id)
    if not tournament:
        raise HTTPException(status_code=404, detail="Tournament not found")
    return tournament

@router.get("/", response_model=List[TournamentRead])
def read_tournaments(
    offset: int = 0,
    limit: int = 100,
    session: Session = Depends(get_session),
    current_user: User = Depends(get_current_user)
):
    tournaments = session.exec(
        select(Tournament)
        .options(selectinload(Tournament.players), selectinload(Tournament.boards))
        .offset(offset)
        .limit(limit)
    ).all()
    
    # We vullen de counts handmatig in, omdat SQLModel dit niet automatisch doet
    results = []
    for t in tournaments:
        # Zet om naar dict en voeg counts toe
        t_data = t.model_dump()
        t_data['player_count'] = len(t.players)
        t_data['board_count'] = len(t.boards)
        results.append(t_data)
        
    return results

@router.get("/public/{public_uuid}", response_model=TournamentReadWithMatches) # <--- Aangepast Model
def read_public_tournament(public_uuid: str, session: Session = Depends(get_session)):
    # 1. Haal toernooi op met matches en spelers
    t = session.exec(
        select(Tournament)
        .where(Tournament.public_uuid == public_uuid)
        .options(selectinload(Tournament.matches), selectinload(Tournament.players))
    ).first()
    
    if not t:
        raise HTTPException(status_code=404, detail="Tournament not found")

    # 2. Maak een map van ID -> Naam voor snelle lookup
    player_map = {p.id: p.name for p in t.players}

    # 3. Verrijk de matches met spelernamen
    matches_data = []
    sorted_matches = sorted(t.matches, key=lambda m: m.id)
    
    for m in sorted_matches:
        m_dict = m.model_dump()
        # Vul de namen in (of "Bye" als er geen speler is)
        m_dict['player1_name'] = player_map.get(m.player1_id, "Bye")
        m_dict['player2_name'] = player_map.get(m.player2_id, "Bye")
        matches_data.append(m_dict)

    # 4. Bouw het antwoord
    response = t.model_dump()
    response['matches'] = matches_data
    response['player_count'] = len(t.players)
    response['board_count'] = len(t.boards)

    return response

@router.post("/{tournament_id}/start-knockout")
def start_knockout(
    tournament_id: int,
    session: Session = Depends(get_session),
    current_user: User = Depends(get_current_user)
):
    t = session.get(Tournament, tournament_id)
    if not t:
        raise HTTPException(status_code=404, detail="Tournament not found")
        
    generate_knockout_from_poules(t, session)
    return {"message": "Knockout phase generated"}


@router.patch("/{tournament_id}", response_model=TournamentRead)
def update_tournament_settings(
    tournament_id: int,
    tourn_update: TournamentUpdate,
    session: Session = Depends(get_session),
    current_user: User = Depends(get_current_user)
):
    """
    Update toernooi instellingen (bijv. allow_byes) on the fly.
    """
    tournament = session.get(Tournament, tournament_id)
    if not tournament:
        raise HTTPException(status_code=404, detail="Tournament not found")
    
    # Update alleen de velden die zijn meegegeven
    tourn_data = tourn_update.model_dump(exclude_unset=True)
    for key, value in tourn_data.items():
        setattr(tournament, key, value)
        
    session.add(tournament)
    session.commit()
    session.refresh(tournament)
    return tournament

@router.post("/{tournament_id}/rounds/{round_number}/update-format")
def update_round_format(
    tournament_id: int,
    round_number: int,
    best_of_legs: int = Query(...),
    session: Session = Depends(get_session),
    current_user: User = Depends(get_current_user)
):
    """
    Batch update: Pas de 'Best of X' aan voor ALLE ongespeelde wedstrijden in een specifieke ronde.
    """
    # 1. Haal matches op
    statement = select(Match).where(
        Match.tournament_id == tournament_id,
        Match.round_number == round_number,
        Match.is_completed == False # Alleen ongespeelde aanpassen
    )
    matches = session.exec(statement).all()
    
    if not matches:
        return {"message": "Geen ongespeelde wedstrijden gevonden in deze ronde om aan te passen."}
        
    # 2. Update ze allemaal
    for match in matches:
        match.best_of_legs = best_of_legs
        session.add(match)
        
    session.commit()
    return {"message": f"{len(matches)} wedstrijden geüpdatet naar Best of {best_of_legs} legs."}

==================================================
FILE: backend/app\api\users.py
==================================================

from typing import Annotated
from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from jose import JWTError, jwt
from sqlmodel import Session, select

from app.db.session import get_session
from app.models.user import User
from app.core.security import SECRET_KEY, ALGORITHM
from app.schemas.token import TokenData

router = APIRouter()

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="api/auth/login")

async def get_current_user(
    token: Annotated[str, Depends(oauth2_scheme)],
    session: Session = Depends(get_session)
):
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        # We stored the email in the 'sub' field in auth.py
        email: str = payload.get("sub")
        if email is None:
            raise credentials_exception
        token_data = TokenData(email=email)
    except JWTError:
        raise credentials_exception
        
    # FIX: Look up by email, NOT username
    statement = select(User).where(User.email == token_data.email)
    user = session.exec(statement).first()
    
    if user is None:
        raise credentials_exception
    return user

@router.get("/me", response_model=User)
async def read_users_me(
    current_user: Annotated[User, Depends(get_current_user)]
):
    return current_user

==================================================
FILE: backend/app\api\websockets.py
==================================================

import asyncio
import logging
from fastapi import APIRouter, WebSocket, WebSocketDisconnect
from app.core.logging_config import log_buffer

router = APIRouter()
logger = logging.getLogger("dart_app")

@router.websocket("/logs")
async def websocket_endpoint(websocket: WebSocket):
    await websocket.accept()
    
    # 1. Send existing logs immediately upon connection
    # Convert deque to list so it is JSON serializable
    await websocket.send_json(list(log_buffer))
    
    try:
        while True:
            # 2. Wait a bit (Poll)
            # In a production app, we would use an event trigger, 
            # but polling the buffer every 2 seconds is fine for this.
            await asyncio.sleep(2)
            
            # Send the current buffer state
            await websocket.send_json(list(log_buffer))
            
    except WebSocketDisconnect:
        logger.info("Logs Client disconnected")

==================================================
FILE: backend/app\api\__init__.py
==================================================

from . import auth, users, players, tournaments, matches, websockets, dartboards

==================================================
FILE: backend/app\core\config.py
==================================================

from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    # Application Info
    PROJECT_NAME: str = "Dart Tournament Manager"
    
    # Database
    # Default to SQLite for dev, but ready for Postgres
    DATABASE_URL: str = "sqlite:///./darts.db"
    
    # Security
    # In production, this should be a long, random string!
    SECRET_KEY: str = "change_this_secret_in_production_9823749823"
    ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 1440  # 24 hours

    class Config:
        case_sensitive = True
        env_file = ".env"

settings = Settings()

==================================================
FILE: backend/app\core\logging_config.py
==================================================

import logging
import sys
from collections import deque

# 1. The Shared Buffer
# This holds the last 100 log messages in memory.
# It is exported so websockets.py can import it and send it to the frontend.
log_buffer = deque(maxlen=100)

class BufferHandler(logging.Handler):
    """Custom handler that pushes logs into the deque."""
    def emit(self, record):
        try:
            msg = self.format(record)
            log_buffer.append(msg)
        except Exception:
            self.handleError(record)

def setup_logging():
    """Configures the logger to write to Console, File, and WebSocket Buffer."""
    logger = logging.getLogger("dart_app")
    logger.setLevel(logging.INFO)
    
    # Prevent adding handlers multiple times if the app reloads
    if logger.hasHandlers():
        return logger

    formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')

    # A. Console Handler (Print to terminal)
    console_handler = logging.StreamHandler(sys.stdout)
    console_handler.setFormatter(formatter)
    logger.addHandler(console_handler)

    # B. File Handler (Save to disk)
    # The 'logs' folder was created by our structure script
    try:
        file_handler = logging.FileHandler("logs/app.log")
        file_handler.setFormatter(formatter)
        logger.addHandler(file_handler)
    except FileNotFoundError:
        print("Warning: logs directory not found. Skipping file logging.")

    # C. Buffer Handler (For WebSockets)
    buffer_handler = BufferHandler()
    buffer_handler.setFormatter(formatter)
    logger.addHandler(buffer_handler)

    return logger

# Initialize immediately so it runs on import
logger = setup_logging()

==================================================
FILE: backend/app\core\security.py
==================================================

from datetime import datetime, timedelta
from typing import Any, Union
from jose import jwt
from passlib.context import CryptContext

# --- Configuration ---
# In a real production app, you would load these from an environment variable
SECRET_KEY = "CHANGE_THIS_TO_A_SECURE_RANDOM_STRING_IN_PRODUCTION"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30  # <--- This is the missing line causing your error!

# --- Password Hashing Setup ---
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

def verify_password(plain_password, hashed_password):
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password):
    return pwd_context.hash(password)

# --- Token Generation ---
def create_access_token(data: dict, expires_delta: Union[timedelta, None] = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=15)
    
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

==================================================
FILE: backend/app\core\__init__.py
==================================================



==================================================
FILE: backend/app\db\session.py
==================================================

from sqlmodel import SQLModel, create_engine, Session
from app.core.config import settings

# check_same_thread=False is needed only for SQLite
connect_args = {"check_same_thread": False} if "sqlite" in settings.DATABASE_URL else {}

engine = create_engine(
    settings.DATABASE_URL, 
    echo=True, # Set to False in production to reduce log noise
    connect_args=connect_args
)

def init_db():
    """
    Creates all tables defined in SQLModel models.
    Called during startup in main.py.
    """
    # Import ALL models here so SQLModel knows about them before creating tables
    # --- FIX: Added 'dartboard' and 'links' to this list ---
    from app.models import user, player, tournament, match, dartboard, links, team # noqa: F401
    
    SQLModel.metadata.create_all(engine)

def get_session():
    """
    Dependency to be used in FastAPI endpoints.
    Yields a database session and closes it automatically.
    """
    with Session(engine) as session:
        yield session

==================================================
FILE: backend/app\db\__init__.py
==================================================



==================================================
FILE: backend/app\models\dartboard.py
==================================================

from typing import Optional
from sqlmodel import Field, SQLModel

class Dartboard(SQLModel, table=True):
    id: Optional[int] = Field(default=None, primary_key=True)
    name: str  # e.g., "Main Stage"
    number: int # e.g., 1

==================================================
FILE: backend/app\models\links.py
==================================================

from typing import Optional
from sqlmodel import Field, SQLModel

class TournamentPlayerLink(SQLModel, table=True):
    tournament_id: Optional[int] = Field(default=None, foreign_key="tournament.id", primary_key=True)
    player_id: Optional[int] = Field(default=None, foreign_key="player.id", primary_key=True)

class TournamentBoardLink(SQLModel, table=True):
    tournament_id: Optional[int] = Field(default=None, foreign_key="tournament.id", primary_key=True)
    board_id: Optional[int] = Field(default=None, foreign_key="dartboard.id", primary_key=True)

==================================================
FILE: backend/app\models\match.py
==================================================

from typing import Optional
from sqlmodel import SQLModel, Field, Relationship

class Match(SQLModel, table=True):
    id: Optional[int] = Field(default=None, primary_key=True)
    
    # --- Structure info ---
    round_number: int 
    poule_number: Optional[int] = None # NIEUW: Als dit ingevuld is, is het een groepswedstrijd
    board_number: Optional[int] = None 
    
    # --- Game Settings (Per match opgeslagen voor flexibiliteit) ---
    best_of_legs: int = Field(default=5) # NIEUW: Bijv. "5" (betekent first to 3)
    best_of_sets: int = Field(default=1) # NIEUW
    
    # --- Status ---
    is_completed: bool = False
    
    # --- Scores ---
    score_p1: int = 0
    score_p2: int = 0
    
    # --- Relationships ---
    tournament_id: int = Field(foreign_key="tournament.id")
    tournament: Optional["Tournament"] = Relationship(back_populates="matches")
    
    player1_id: Optional[int] = Field(default=None, foreign_key="player.id")
    player2_id: Optional[int] = Field(default=None, foreign_key="player.id")

    team1_id: Optional[int] = Field(default=None, foreign_key="team.id")
    team2_id: Optional[int] = Field(default=None, foreign_key="team.id")

==================================================
FILE: backend/app\models\player.py
==================================================

from typing import Optional, List
from sqlmodel import Field, SQLModel, Relationship
from app.models.team import Team, TeamPlayerLink

class Player(SQLModel, table=True):
    id: Optional[int] = Field(default=None, primary_key=True)
    
    first_name: str
    last_name: Optional[str] = None
    nickname: Optional[str] = None
    email: Optional[str] = None # We keep this loose as a string in the DB
    
    user_id: Optional[int] = Field(default=None, foreign_key="user.id")
    user: Optional["User"] = Relationship(back_populates="players")

    teams: List[Team] = Relationship(back_populates="players", link_model=TeamPlayerLink)

    @property
    def name(self) -> str:
        full_name = self.first_name
        if self.nickname:
            full_name += f' "{self.nickname}"'
        if self.last_name:
            full_name += f" {self.last_name}"
        return full_name
    

==================================================
FILE: backend/app\models\team.py
==================================================

from typing import Optional, List
from sqlmodel import Field, SQLModel, Relationship

# Koppeltabel: Speler <-> Team
class TeamPlayerLink(SQLModel, table=True):
    team_id: Optional[int] = Field(default=None, foreign_key="team.id", primary_key=True)
    player_id: Optional[int] = Field(default=None, foreign_key="player.id", primary_key=True)

class Team(SQLModel, table=True):
    id: Optional[int] = Field(default=None, primary_key=True)
    name: str
    tournament_id: int = Field(foreign_key="tournament.id")
    
    # Relaties
    players: List["Player"] = Relationship(back_populates="teams", link_model=TeamPlayerLink)
    tournament: "Tournament" = Relationship(back_populates="teams")

==================================================
FILE: backend/app\models\tournament.py
==================================================

import uuid
from typing import Optional, List
from sqlmodel import SQLModel, Field, Relationship
from datetime import datetime
from app.models.links import TournamentPlayerLink, TournamentBoardLink

class Tournament(SQLModel, table=True):
    id: Optional[int] = Field(default=None, primary_key=True)
    
    name: str = Field(default_factory=lambda: f"Toernooi {datetime.now().strftime('%Y-%m-%d')}")
    date: str 
    created_at: datetime = Field(default_factory=datetime.utcnow)
    status: str = Field(default="draft") # draft, active, knockout_ready, finished
    
    # --- Format Settings ---
    format: str = Field(default="hybrid") 
    
    number_of_poules: int = Field(default=1)
    
    # Hoeveel spelers gaan er per poule door naar de KO?
    qualifiers_per_poule: int = Field(default=2) 

    allow_byes: bool = Field(default=True)
    
    # --- Game Settings (Best of X) ---
    starting_legs_group: int = Field(default=3) 
    starting_legs_ko: int = Field(default=3)    
    sets_per_match: int = Field(default=1)
    
    # --- Access Control ---
    public_uuid: str = Field(default_factory=lambda: str(uuid.uuid4()), index=True, unique=True)
    scorer_uuid: str = Field(default_factory=lambda: str(uuid.uuid4()), index=True, unique=True)
    
    # --- Ownership ---
    user_id: Optional[int] = Field(default=None, foreign_key="user.id")
    user: Optional["User"] = Relationship(back_populates="tournaments")
    
    # --- Relationships ---
    players: List["Player"] = Relationship(back_populates=None, link_model=TournamentPlayerLink)
    boards: List["Dartboard"] = Relationship(back_populates=None, link_model=TournamentBoardLink)
    matches: List["Match"] = Relationship(back_populates="tournament")
    
    # --- NIEUW: Voeg deze regel toe om de cirkel rond te maken ---
    teams: List["Team"] = Relationship(back_populates="tournament")

==================================================
FILE: backend/app\models\user.py
==================================================

from typing import Optional
from sqlmodel import Field, SQLModel, Relationship

class User(SQLModel, table=True):
    id: Optional[int] = Field(default=None, primary_key=True)
    
    first_name: str
    last_name: str
    email: str = Field(unique=True, index=True)
    
    hashed_password: str

    players: list["Player"] = Relationship(back_populates="user")
    tournaments: list["Tournament"] = Relationship(back_populates="user")

==================================================
FILE: backend/app\models\__init__.py
==================================================

from .user import User
from .player import Player
from .tournament import Tournament
from .match import Match

==================================================
FILE: backend/app\schemas\auth.py
==================================================

from typing import Optional
from pydantic import BaseModel

class Token(BaseModel):
    access_token: str
    token_type: str

class TokenData(BaseModel):
    username: Optional[str] = None

class UserCreate(BaseModel):
    username: str
    password: str

class UserRead(BaseModel):
    id: int
    username: str

==================================================
FILE: backend/app\schemas\dartboard.py
==================================================

from pydantic import BaseModel

class DartboardBase(BaseModel):
    name: str
    number: int

class DartboardCreate(DartboardBase):
    pass

class DartboardRead(DartboardBase):
    id: int

==================================================
FILE: backend/app\schemas\match.py
==================================================

from typing import Optional
from pydantic import BaseModel

class MatchScoreUpdate(BaseModel):
    score_p1: int
    score_p2: int
    is_completed: bool = False

class MatchRead(BaseModel):
    id: int
    tournament_id: int
    round_number: int
    
    poule_number: Optional[int] = None 
    best_of_legs: Optional[int] = 5
    best_of_sets: Optional[int] = 1

    player1_id: Optional[int]
    player2_id: Optional[int]
    player1_name: Optional[str] = "Bye"
    player2_name: Optional[str] = "Bye"
    
    score_p1: int
    score_p2: int
    is_completed: bool
    
    class Config:
        from_attributes = True

==================================================
FILE: backend/app\schemas\player.py
==================================================

from typing import Optional
from pydantic import BaseModel, EmailStr, field_validator

class PlayerBase(BaseModel):
    first_name: str
    last_name: Optional[str] = None
    nickname: Optional[str] = None
    email: Optional[EmailStr] = None

class PlayerCreate(PlayerBase):
    # This magic function converts empty strings "" into None (null)
    # automatically, preventing validation errors.
    @field_validator('email', 'nickname', 'last_name', mode='before')
    @classmethod
    def empty_to_none(cls, v):
        if v == "":
            return None
        return v

class PlayerRead(PlayerBase):
    id: int
    name: str

==================================================
FILE: backend/app\schemas\team.py
==================================================

# FILE: backend/app/schemas/team.py
from typing import List, Optional
from pydantic import BaseModel
from app.schemas.player import PlayerRead

# --- INPUT SCHEMAS ---

# Voor handmatig 1 team maken
class TeamCreateManual(BaseModel):
    tournament_id: int
    player_ids: List[int]       # De IDs van de spelers in dit team
    name: Optional[str] = None  # Optioneel (wordt automatisch gegenereerd indien leeg)

# Voor automatisch teams genereren (random)
class TeamAutoGenerate(BaseModel):
    tournament_id: int
    player_ids: List[int]       # De pool van spelers die verdeeld moeten worden

# --- OUTPUT SCHEMA ---

# Wat sturen we terug naar de frontend?
class TeamRead(BaseModel):
    id: int
    name: str
    tournament_id: int
    players: List[PlayerRead] = [] # We willen de speler details zien in het team

    class Config:
        from_attributes = True

==================================================
FILE: backend/app\schemas\token.py
==================================================

from typing import Optional
from pydantic import BaseModel

class Token(BaseModel):
    access_token: str
    token_type: str

class TokenData(BaseModel):
    email: Optional[str] = None

==================================================
FILE: backend/app\schemas\tournament.py
==================================================

# FILE: backend/app/schemas/tournament.py
from typing import List, Optional
from pydantic import BaseModel
from datetime import datetime

# --- Input Schema (Create) ---
class TournamentCreate(BaseModel):
    name: str
    date: str  
    number_of_poules: int = 1  
    format: str = "hybrid"
    allow_byes: bool = True
    
    # Settings
    qualifiers_per_poule: int = 2
    starting_legs_group: int = 3
    starting_legs_ko: int = 5
    sets_per_match: int = 1
    
    # IDs voor relaties
    player_ids: List[int]
    board_ids: List[int]  

# --- Input Schema (Update) ---
class TournamentUpdate(BaseModel):
    name: Optional[str] = None
    date: Optional[str] = None
    status: Optional[str] = None
    format: Optional[str] = None
    scorer_uuid: Optional[str] = None

# --- Output Schema (Read) ---
class TournamentRead(BaseModel):
    id: int
    name: str
    date: str 
    status: str
    format: str
    allow_byes: bool = True
    number_of_poules: int  
    created_at: datetime
    public_uuid: str
    scorer_uuid: str
    
    # Settings terugsturen
    qualifiers_per_poule: int = 2
    starting_legs_group: int = 3
    starting_legs_ko: int = 5
    
    # Counts
    player_count: int = 0
    board_count: int = 0
    
    class Config:
        from_attributes = True

# --- Detailed View (Public Page) ---
class MatchReadSimple(BaseModel):
    id: int
    round_number: int
    poule_number: Optional[int] = None # <--- BELANGRIJK VOOR DE TABS
    player1_name: Optional[str] = None
    player2_name: Optional[str] = None
    score_p1: int
    score_p2: int
    is_completed: bool

class TournamentReadWithMatches(TournamentRead):
    matches: List[MatchReadSimple] = []

==================================================
FILE: backend/app\schemas\user.py
==================================================

from typing import Optional
from pydantic import BaseModel, EmailStr

class UserCreate(BaseModel):
    first_name: str
    last_name: str
    email: EmailStr
    password: str  # No username here

class UserRead(BaseModel):
    id: int
    first_name: str
    last_name: str
    email: str 
    # No username here

class UserUpdate(BaseModel):
    first_name: Optional[str] = None
    last_name: Optional[str] = None
    email: Optional[EmailStr] = None

==================================================
FILE: backend/app\schemas\__init__.py
==================================================



==================================================
FILE: backend/app\services\tournament_gen.py
==================================================

from typing import List, Dict
import random
import math
from sqlmodel import Session, select
from app.models.match import Match
from app.models.team import Team
from app.models.player import Player
from app.models.tournament import Tournament

# --- POULE FASE LOGICA ---

def generate_poule_phase(
    tournament_id: int,
    players: List[Player],
    num_poules: int,
    legs_best_of: int,
    sets_best_of: int,
    session: Session
):
    """
    Verdeelt spelers over N poules en genereert voor elke poule een Round Robin schema.
    """
    if len(players) < num_poules:
        # Fallback: als er minder spelers zijn dan poules, stop alles in 1 poule
        num_poules = 1

    # 1. Spelers husselen voor willekeurige indeling
    shuffled_players = list(players)
    random.shuffle(shuffled_players)

    # 2. Verdeel over poules (Modulo verdeling)
    poules_map = {i: [] for i in range(1, num_poules + 1)}
    
    for idx, player in enumerate(shuffled_players):
        target_poule = (idx % num_poules) + 1
        poules_map[target_poule].append(player)

    # 3. Genereer wedstrijden per poule
    matches_to_add = []
    
    for poule_num, pool_players in poules_map.items():
        new_matches = _create_round_robin_matches(
            tournament_id=tournament_id,
            players=pool_players,
            poule_number=poule_num,
            legs=legs_best_of,
            sets=sets_best_of
        )
        matches_to_add.extend(new_matches)

    session.add_all(matches_to_add)
    session.commit()


def generate_round_robin_global(
    tournament_id: int, 
    players: List[Player], 
    legs_best_of: int,
    sets_best_of: int,
    session: Session
):
    """
    Klassieke Round Robin (alles in 1 grote groep).
    """
    matches = _create_round_robin_matches(tournament_id, players, None, legs_best_of, sets_best_of)
    session.add_all(matches)
    session.commit()


def _create_round_robin_matches(
    tournament_id: int, 
    players: List[Player], 
    poule_number: int | None,
    legs: int,
    sets: int
) -> List[Match]:
    matches = []
    if len(players) < 2:
        return matches

    # Dummy toevoegen bij oneven aantal
    rotation = list(players)
    if len(rotation) % 2 != 0:
        rotation.append(None)
    
    num_players = len(rotation)
    num_rounds = num_players - 1
    half = num_players // 2

    for round_idx in range(num_rounds):
        round_num = round_idx + 1
        
        for i in range(half):
            p1 = rotation[i]
            p2 = rotation[num_players - 1 - i]
            
            if p1 and p2:
                match = Match(
                    tournament_id=tournament_id,
                    round_number=round_num,
                    poule_number=poule_number,
                    player1_id=p1.id,
                    player2_id=p2.id,
                    best_of_legs=legs,
                    best_of_sets=sets,
                    is_completed=False
                )
                matches.append(match)

        # Rotate
        rotation.insert(1, rotation.pop())
    
    return matches


# --- KNOCKOUT LOGICA (HYBRIDE) ---

def generate_knockout_from_poules(tournament: Tournament, session: Session):
    """
    Genereert een dynamische knockout fase op basis van Global Seeding.
    Werkt voor elk aantal poules en qualifiers.
    """
    # 1. Haal alle gespeelde poule wedstrijden op
    matches = session.exec(
        select(Match)
        .where(Match.tournament_id == tournament.id)
        .where(Match.poule_number != None)
    ).all()
    
    # 2. Bereken statistieken per speler
    stats = {} 
    
    for m in matches:
        if not m.is_completed:
            continue
            
        p1, p2 = m.player1_id, m.player2_id
        # Init stats als ze nog niet bestaan
        if p1 not in stats: stats[p1] = {'id': p1, 'w': 0, 'pts': 0, 'ld': 0, 'poule': m.poule_number}
        if p2 not in stats: stats[p2] = {'id': p2, 'w': 0, 'pts': 0, 'ld': 0, 'poule': m.poule_number}
        
        # Leg Difference (Saldo)
        stats[p1]['ld'] += (m.score_p1 - m.score_p2)
        stats[p2]['ld'] += (m.score_p2 - m.score_p1)
        
        # Punten (2 voor winst)
        if m.score_p1 > m.score_p2:
            stats[p1]['w'] += 1
            stats[p1]['pts'] += 2
        else:
            stats[p2]['w'] += 1
            stats[p2]['pts'] += 2

    # 3. Groepeer per poule en sorteer DAARBINNEN
    poules_map = {}
    for pid, data in stats.items():
        p_num = data['poule']
        if p_num not in poules_map: poules_map[p_num] = []
        poules_map[p_num].append(data)
        
    for p_num in poules_map:
        # Sorteren: Meeste punten -> Hoogste saldo -> Meeste winstpartijen
        poules_map[p_num].sort(key=lambda x: (x['pts'], x['ld'], x['w']), reverse=True)

    # 4. Global Seeding (Buckets maken)
    # We zetten alle nummers 1 bij elkaar, alle nummers 2 bij elkaar, etc.
    limit = tournament.qualifiers_per_poule
    ranked_buckets = [[] for _ in range(limit)]
    
    sorted_poule_numbers = sorted(poules_map.keys())
    
    for p_num in sorted_poule_numbers:
        players_in_poule = poules_map[p_num]
        for rank_idx in range(min(len(players_in_poule), limit)):
            ranked_buckets[rank_idx].append(players_in_poule[rank_idx])

    # Sorteer nu de buckets zelf (zodat de Beste #1 bovenaan staat)
    for bucket in ranked_buckets:
        bucket.sort(key=lambda x: (x['pts'], x['ld'], x['w']), reverse=True)

    # 5. Maak één lange ranglijst (Flatten)
    final_seed_list = []
    for bucket in ranked_buckets:
        for p_data in bucket:
            final_seed_list.append(p_data['id'])
            
    if not final_seed_list:
        return 

    # --- NIEUWE LOGICA: Check op Byes ---
    if not tournament.allow_byes:
        num_qualifiers = len(final_seed_list)
        # Bereken de grootste macht van 2 die in het aantal past (Floor)
        # Voorbeeld: 10 spelers -> log2(10)=3.32 -> floor=3 -> 2^3 = 8 spelers.
        # Voorbeeld: 7 spelers -> log2(7)=2.8 -> floor=2 -> 2^2 = 4 spelers.
        power_of_two = math.floor(math.log2(num_qualifiers))
        target_size = 2 ** power_of_two
        
        # Als we minder dan 2 spelers overhouden, is er geen KO mogelijk
        if target_size < 2:
             # Fallback: doe niets of pak minimaal 2 als die er zijn
             pass 
        elif target_size < num_qualifiers:
            # We snijden de lijst af. Omdat de lijst al gesorteerd is op sterkte,
            # vallen automatisch de zwakste qualifiers af.
            final_seed_list = final_seed_list[:target_size]

    # 6. Bracket Grootte Berekenen (Macht van 2)
    num_qualifiers = len(final_seed_list)
    # Zoekt de eerstvolgende macht van 2 (bijv 10 spelers -> 16 bracket size)
    bracket_size = 2 ** math.ceil(math.log2(num_qualifiers))
    
    # Vul aan met None (dit zijn de Byes)
    padded_players = list(final_seed_list)
    while len(padded_players) < bracket_size:
        padded_players.append(None)

    # 7. Wedstrijden Genereren (Hoogste Seed vs Laagste Seed)
    knockout_matches = []
    half_size = bracket_size // 2
    
    for i in range(half_size):
        # Seed 1 speelt tegen Seed 16 (of Bye), Seed 2 tegen 15, etc.
        p1_id = padded_players[i]
        p2_id = padded_players[bracket_size - 1 - i]
        
        if p1_id and p2_id:
            # Echte wedstrijd (Speler vs Speler)
            match = _create_ko_match(tournament, p1_id, p2_id)
            knockout_matches.append(match)
            
        elif p1_id and p2_id is None:
            # Speler vs Bye -> We maken een wedstrijd die DIRECT AFGEROND is.
            # Hierdoor verschijnt hij in de bracket als gewonnen en gaat de speler door.
            bye_match = Match(
                tournament_id=tournament.id,
                round_number=1,
                poule_number=None,
                player1_id=p1_id,
                player2_id=None, # Geen tegenstander
                score_p1=tournament.starting_legs_ko, # Automatische winst score
                score_p2=0,
                is_completed=True, # Direct klaar!
                best_of_legs=tournament.starting_legs_ko,
                best_of_sets=tournament.sets_per_match
            )
            knockout_matches.append(bye_match)

    session.add_all(knockout_matches)
    session.commit()


# --- ALGEMENE KNOCKOUT HELPERS ---

def generate_knockout(
    tournament_id: int, 
    players: List[Player], 
    legs_best_of: int,
    sets_best_of: int,
    session: Session
):
    """
    Direct Knockout generator (zonder poules vooraf).
    """
    import random
    random.shuffle(players)
    
    # Hack: we maken een fake tournament object om _create_bracket_matches te hergebruiken
    # zonder dat we het hele object uit de DB hoeven te halen.
    class FakeTournament:
        id = tournament_id
        starting_legs_ko = legs_best_of
        sets_per_match = sets_best_of
        
    fake_tourn = FakeTournament()
    
    player_ids = [p.id for p in players]
    _create_bracket_matches(fake_tourn, player_ids, session)


def _create_bracket_matches(tournament, player_ids, session):
    """Generieke bracket generator"""
    n = len(player_ids)
    bracket_size = 1
    while bracket_size < n:
        bracket_size *= 2
        
    padded_players = list(player_ids)
    while len(padded_players) < bracket_size:
        padded_players.append(None)
        
    matches = []
    for i in range(bracket_size // 2):
        p1 = padded_players[i]
        p2 = padded_players[bracket_size - 1 - i]
        
        if p1 and p2:
            matches.append(_create_ko_match(tournament, p1, p2))
            
    session.add_all(matches)
    session.commit()


def _create_ko_match(tournament, p1_id, p2_id):
    return Match(
        tournament_id=tournament.id,
        round_number=1, 
        poule_number=None, 
        player1_id=p1_id,
        player2_id=p2_id,
        best_of_legs=tournament.starting_legs_ko,
        best_of_sets=tournament.sets_per_match,
        is_completed=False
    )

def check_and_advance_knockout(tournament_id: int, current_round: int, session: Session):
    """
    Checkt of een knockout ronde compleet is. 
    Zo ja: Genereert de volgende ronde.
    """
    # 1. Haal alle wedstrijden van deze ronde op
    matches = session.exec(
        select(Match)
        .where(Match.tournament_id == tournament_id)
        .where(Match.round_number == current_round)
        .where(Match.poule_number == None) 
    ).all()
    
    if not matches:
        return

    # 2. Check of ALLES compleet is
    if not all(m.is_completed for m in matches):
        return # Nog niet iedereen is klaar

    # --- NIEUWE CHECK: Bestaat de volgende ronde al? ---
    # Dit voorkomt dat we dubbele wedstrijden aanmaken als je per ongeluk 2x opslaat.
    next_round = current_round + 1
    existing_next_round = session.exec(
        select(Match)
        .where(Match.tournament_id == tournament_id)
        .where(Match.round_number == next_round)
        .where(Match.poule_number == None)
    ).first()
    
    if existing_next_round:
        print(f"Ronde {next_round} bestaat al, we genereren niets nieuws.")
        return
    # ---------------------------------------------------

    print(f"--- Ronde {current_round} compleet! Genereren Ronde {current_round + 1} ---")

    # 3. Verzamel winnaars
    matches.sort(key=lambda x: x.id)
    
    winners = []
    for m in matches:
        if m.score_p1 > m.score_p2:
            winners.append(m.player1_id)
        else:
            winners.append(m.player2_id)
            
    # Als er maar 1 winnaar over is, is het toernooi klaar!
    if len(winners) < 2:
        print(f"Toernooi {tournament_id} is afgelopen. Winnaar ID: {winners[0]}")
        t = session.get(Tournament, tournament_id)
        if t:
            t.status = "finished"
            session.add(t)
            session.commit()
        return

    # 4. Maak wedstrijden voor de volgende ronde
    t = session.get(Tournament, tournament_id)
    legs = t.starting_legs_ko if t else 5
    sets = t.sets_per_match if t else 1
    
    new_matches = []
    for i in range(0, len(winners), 2):
        p1 = winners[i]
        p2 = winners[i+1]
        
        new_match = Match(
            tournament_id=tournament_id,
            round_number=next_round,
            poule_number=None,
            player1_id=p1,
            player2_id=p2,
            score_p1=0,
            score_p2=0,
            is_completed=False,
            best_of_legs=legs,
            best_of_sets=sets
        )
        new_matches.append(new_match)
        
    session.add_all(new_matches)
    session.commit()

def create_random_teams(tournament_id: int, player_ids: list[int], session: Session):
    """
    Eis 1: Automatisch team systeem (Random).
    Eis 3: Automatische naamgeving.
    """
    # 1. Spelers ophalen
    players = session.exec(select(Player).where(Player.id.in_(player_ids))).all()
    
    if len(players) % 2 != 0:
        raise ValueError("Aantal spelers moet even zijn voor koppels!")

    # 2. Husselen
    random.shuffle(players)

    teams = []
    # 3. Koppels maken (per 2)
    for i in range(0, len(players), 2):
        p1 = players[i]
        p2 = players[i+1]

        # Eis 3: Automatische naam
        # Bijv: "Van Gerwen & Van Barneveld"
        team_name = f"{p1.last_name or p1.first_name} & {p2.last_name or p2.first_name}"

        team = Team(name=team_name, tournament_id=tournament_id)
        team.players = [p1, p2]
        session.add(team)
        teams.append(team)
    
    session.commit()
    return teams

def create_manual_team(tournament_id: int, player_ids: list[int], custom_name: str | None, session: Session):
    """
    Eis 2: Vrije keuze team samenstelling.
    Eis 3: Team naam keuze (met fallback).
    """
    players = session.exec(select(Player).where(Player.id.in_(player_ids))).all()
    
    if not players:
        raise ValueError("Geen geldige spelers geselecteerd")

    # Eis 3: Naam logica
    if custom_name and custom_name.strip() != "":
        final_name = custom_name
    else:
        # Fallback: namen aan elkaar plakken
        names = [p.last_name or p.first_name for p in players]
        final_name = " & ".join(names)

    team = Team(name=final_name, tournament_id=tournament_id)
    team.players = players
    
    session.add(team)
    session.commit()
    session.refresh(team)
    return team

==================================================
FILE: backend/app\services\__init__.py
==================================================



==================================================
FILE: frontend/src\App.tsx
==================================================

import { BrowserRouter, Routes, Route, Navigate } from 'react-router-dom';
import { AuthProvider } from './context/AuthContext';

// Auth Pages
import Login from './pages/auth/Login';
import Register from './pages/auth/Register';

// Admin Pages
import ManagePlayers from './pages/admin/ManagePlayers';
import CreateTournament from './pages/admin/CreateTournament';
import SystemLogs from './pages/admin/SystemLogs';
import ManageBoards from './pages/admin/ManageBoards';
import Dashboard from './pages/admin/Dashboard';
import ManageTournament from './pages/admin/ManageTournament'; 

// Public Pages
import TournamentView from './pages/public/TournamentView';

// Scorer Pages
import ScorerMatchList from './pages/scorer/MatchList';
import Scoreboard from './pages/scorer/Scoreboard';

function App() {
  return (
    <AuthProvider>
      <BrowserRouter>
        <Routes>
          {/* Auth Routes */}
          <Route path="/login" element={<Login />} />
          <Route path="/register" element={<Register />} />
          
          {/* Public Routes (No Login Required) */}
          <Route path="/t/:public_uuid" element={<TournamentView />} />

          {/* Admin Routes */}
          <Route path="/dashboard" element={<Dashboard />} />
          <Route path="/dashboard/tournament/:id" element={<ManageTournament />} />
          <Route path="/dashboard/players" element={<ManagePlayers />} />
          <Route path="/dashboard/create-tournament" element={<CreateTournament />} />
          <Route path="/dashboard/logs" element={<SystemLogs />} />
          <Route path="/dashboard/boards" element={<ManageBoards />} />

          {/* Scorer Routes (Tablet View) */}
          <Route path="/board/:scorer_uuid" element={<ScorerMatchList />} />
          <Route path="/board/:scorer_uuid/match/:match_id" element={<Scoreboard />} />

          {/* Default Redirect */}
          <Route path="/" element={<Navigate to="/dashboard" replace />} />
        </Routes>
      </BrowserRouter>
    </AuthProvider>
  );
}

export default App;

==================================================
FILE: frontend/src\index.css
==================================================

@tailwind base;
@tailwind components;
@tailwind utilities;

==================================================
FILE: frontend/src\main.tsx
==================================================

import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App.tsx'
import './index.css'

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
)

==================================================
FILE: frontend/src\components\layout\AdminLayout.tsx
==================================================

import { ReactNode } from 'react';
import Sidebar from './Sidebar';

interface AdminLayoutProps {
  children: ReactNode;
}

const AdminLayout = ({ children }: AdminLayoutProps) => {
  return (
    <div className="flex h-screen bg-gray-100">
      <Sidebar />
      <main className="flex-1 overflow-auto p-8">
        {children}
      </main>
    </div>
  );
};

export default AdminLayout;

==================================================
FILE: frontend/src\components\layout\Sidebar.tsx
==================================================

import { Link, useLocation, useNavigate } from 'react-router-dom';
import { useAuth } from '../../hooks/useAuth';
// 1. Added 'Target' icon for the boards
import { LayoutDashboard, Users, Trophy, LogOut, Activity, Target } from 'lucide-react';

const Sidebar = () => {
  const { logout, user } = useAuth();
  const navigate = useNavigate();
  const location = useLocation();

  const handleLogout = () => {
    logout();
    navigate('/login');
  };

  // 2. Added 'Manage Boards' to the menu list
  const menuItems = [
    { icon: LayoutDashboard, label: 'Dashboard', path: '/dashboard' },
    { icon: Users, label: 'Manage Players', path: '/dashboard/players' },
    { icon: Target, label: 'Manage Boards', path: '/dashboard/boards' }, // <--- NEW LINK
    { icon: Trophy, label: 'Create Tournament', path: '/dashboard/create-tournament' },
    { icon: Activity, label: 'System Logs', path: '/dashboard/logs' },
  ];

  return (
    <div className="bg-slate-900 text-white w-64 min-h-screen flex flex-col">
      <div className="p-6 border-b border-slate-700">
        <h1 className="text-2xl font-bold text-blue-400">Dart Manager</h1>
        {/* 3. Fixed user display (username no longer exists) */}
        <p className="text-xs text-slate-400 mt-1">
           Logged in as: {user?.first_name || 'Admin'}
        </p>
      </div>

      <nav className="flex-1 p-4">
        <ul className="space-y-2">
          {menuItems.map((item) => {
            const Icon = item.icon;
            const isActive = location.pathname === item.path;
            return (
              <li key={item.path}>
                <Link
                  to={item.path}
                  className={`flex items-center space-x-3 p-3 rounded-lg transition-colors ${
                    isActive 
                      ? 'bg-blue-600 text-white' 
                      : 'text-slate-300 hover:bg-slate-800'
                  }`}
                >
                  <Icon size={20} />
                  <span>{item.label}</span>
                </Link>
              </li>
            );
          })}
        </ul>
      </nav>

      <div className="p-4 border-t border-slate-700">
        <button
          onClick={handleLogout}
          className="flex items-center space-x-3 text-red-400 hover:text-red-300 w-full p-3 hover:bg-slate-800 rounded-lg transition-colors"
        >
          <LogOut size={20} />
          <span>Sign Out</span>
        </button>
      </div>
    </div>
  );
};

export default Sidebar;

==================================================
FILE: frontend/src\context\AuthContext.tsx
==================================================

import { createContext, useState, useEffect, ReactNode } from 'react';
import api from '../services/api';

// Define the shape of our User object (matches Python UserRead schema)
interface User {
  id: number;
  username: string;
}

// Define what functions/data we want to expose to the app
interface AuthContextType {
  user: User | null;
  login: (token: string) => void;
  logout: () => void;
  isLoading: boolean;
}

// Create the context (starts empty)
export const AuthContext = createContext<AuthContextType | null>(null);

// The Provider Component (wraps the whole app)
export const AuthProvider = ({ children }: { children: ReactNode }) => {
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  // This runs once when the app starts (like __init__)
  useEffect(() => {
    const initAuth = async () => {
      const token = localStorage.getItem('token');
      if (token) {
        try {
          // If we find a token, ask the backend "Who am I?"
          const response = await api.get('/users/me');
          setUser(response.data);
        } catch (error) {
          // If token is invalid/expired, clear it
          console.error("Token invalid", error);
          localStorage.removeItem('token');
        }
      }
      setIsLoading(false);
    };
    initAuth();
  }, []);

  // Function to run when user logs in
  const login = async (token: string) => {
    localStorage.setItem('token', token); // Save to browser
    try {
      const response = await api.get('/users/me'); // Fetch user details
      setUser(response.data);
    } catch (error) {
      console.error("Login failed fetching user", error);
    }
  };

  // Function to run when user logs out
  const logout = () => {
    localStorage.removeItem('token');
    setUser(null);
  };

  return (
    <AuthContext.Provider value={{ user, login, logout, isLoading }}>
      {children}
    </AuthContext.Provider>
  );
};

==================================================
FILE: frontend/src\hooks\useAuth.ts
==================================================

import { useContext } from 'react';
import { AuthContext } from '../context/AuthContext';

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};

==================================================
FILE: frontend/src\hooks\useWebSocket.ts
==================================================



==================================================
FILE: frontend/src\pages\SystemLogs.tsx
==================================================



==================================================
FILE: frontend/src\pages\admin\CreateTournament.tsx
==================================================

import { useEffect, useState } from 'react';
import { useNavigate } from 'react-router-dom';
import api from '../../services/api';
import AdminLayout from '../../components/layout/AdminLayout';
import { Player, Dartboard } from '../../types';
import { Trophy, AlertCircle, LayoutGrid, Users, Target, Scissors, Shuffle, UserPlus, Trash2, Save } from 'lucide-react';

// --- STYLING CONSTANTEN ---
const LABEL_STYLE = "block text-xs font-bold text-gray-500 uppercase mb-1";
const INPUT_STYLE = "w-full border border-gray-300 rounded-md p-2 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent transition-all shadow-sm";

interface Team {
    id: number;
    name: string;
    players: Player[];
}

const CreateTournament = () => {
    const navigate = useNavigate();

    // --- Wizard State ---
    const [step, setStep] = useState<1 | 2>(1); // Stap 1: Setup, Stap 2: Teams
    const [createdTournamentId, setCreatedTournamentId] = useState<number | null>(null);

    // --- Data State ---
    const [allPlayers, setAllPlayers] = useState<Player[]>([]);
    const [allBoards, setAllBoards] = useState<Dartboard[]>([]);
    const [loading, setLoading] = useState(true);
    const [teams, setTeams] = useState<Team[]>([]); // Gemaakte teams

    // --- Selection State ---
    const [selectedPlayerIds, setSelectedPlayerIds] = useState<number[]>([]);
    const [selectedBoardIds, setSelectedBoardIds] = useState<number[]>([]);

    // --- Form State ---
    const defaultName = `Toernooi ${new Date().toLocaleDateString('nl-NL')}`;
    const [name, setName] = useState(defaultName);
    const [date, setDate] = useState(new Date().toISOString().split('T')[0]);

    // Format settings
    const [participationMode, setParticipationMode] = useState<'singles' | 'doubles'>('singles'); // NIEUW
    const [format, setFormat] = useState('hybrid');
    const [poules, setPoules] = useState(1);
    const [qualifiersPerPoule, setQualifiersPerPoule] = useState(2);
    const [allowByes, setAllowByes] = useState(true);

    // Match length settings
    const [groupLegs, setGroupLegs] = useState(3);
    const [koLegs, setKoLegs] = useState(5);
    const [sets, setSets] = useState(1);

    const [error, setError] = useState<string | null>(null);

    // --- Manual Team Input State ---
    const [manualTeamName, setManualTeamName] = useState("");
    const [manualSelection, setManualSelection] = useState<number[]>([]);

    // --- Load Data ---
    useEffect(() => {
        const fetchData = async () => {
            try {
                const [pRes, bRes] = await Promise.all([
                    api.get('/players/'),
                    api.get('/dartboards/')
                ]);
                setAllPlayers(pRes.data);
                setAllBoards(bRes.data);

                // --- NIEUW: Standaard 1e bord selecteren ---
                // We checken eerst of de lijst niet leeg is, om errors te voorkomen.
                if (bRes.data.length > 0) {
                    // We pakken het ID van het eerste bord in de lijst
                    setSelectedBoardIds([bRes.data[0].id]);
                }
                // ------------------------------------------

            } catch (err) {
                console.error(err);
                setError("Kon data niet laden. Staat de backend aan?");
            } finally {
                setLoading(false);
            }
        };
        fetchData();
    }, []);

    // --- Helpers ---
    const togglePlayer = (id: number) => setSelectedPlayerIds(prev => prev.includes(id) ? prev.filter(p => p !== id) : [...prev, id]);
    const toggleBoard = (id: number) => setSelectedBoardIds(prev => prev.includes(id) ? prev.filter(b => b !== id) : [...prev, id]);

    const toggleManualSelection = (id: number) => {
        setManualSelection(prev => {
            if (prev.includes(id)) return prev.filter(p => p !== id);
            if (prev.length >= 2) return prev; // Max 2 selecteren
            return [...prev, id];
        });
    };

    // --- STAP 1: Toernooi Aanmaken ---
    const handleCreateTournament = async (e: React.FormEvent) => {
        e.preventDefault();
        setError(null);

        if (selectedBoardIds.length === 0) {
            setError("Selecteer minimaal 1 dartbord.");
            return;
        }

        // Validatie: bij koppels minimaal 4 spelers (2 teams)
        const minPlayers = participationMode === 'doubles' ? 4 : 2;
        if (selectedPlayerIds.length < minPlayers) {
            setError(`Selecteer minimaal ${minPlayers} spelers.`);
            return;
        }

        try {
            const finalName = name.trim() === "" ? defaultName : name;
            
            // Als we koppels doen, zetten we het toernooi eerst in 'draft' en genereren we nog GEEN matches
            // (Dit vereist wel dat je backend 'teams' ondersteunt bij generatie, voor nu maken we het object aan)
            const payload = {
                name: finalName,
                date,
                format,
                allow_byes: allowByes,
                number_of_poules: poules,
                qualifiers_per_poule: qualifiersPerPoule,
                starting_legs_group: groupLegs,
                starting_legs_ko: koLegs,
                sets_per_match: sets,
                player_ids: selectedPlayerIds,
                board_ids: selectedBoardIds,
                // eventueel: mode: participationMode (als je backend dit ondersteunt)
            };

            const res = await api.post('/tournaments/', payload);
            
            if (participationMode === 'doubles') {
                // Ga naar stap 2: Team Builder
                setCreatedTournamentId(res.data.id);
                setStep(2);
                window.scrollTo(0,0);
            } else {
                // Klaar!
                navigate('/dashboard');
            }

        } catch (err: any) {
            console.error(err);
            setError(err.response?.data?.detail || "Er is iets misgegaan bij het aanmaken.");
            window.scrollTo(0,0);
        }
    };

    // --- STAP 2: Teams Beheren ---
    
    // Spelers die geselecteerd zijn, maar nog NIET in een team zitten
    const unassignedPlayers = allPlayers.filter(p => 
        selectedPlayerIds.includes(p.id) && 
        !teams.some(t => t.players.some(tp => tp.id === p.id))
    );

    const handleAutoGenerate = async () => {
        if (!createdTournamentId) return;
        try {
            // Stuur alle nog niet ingedeelde spelers naar de auto-endpoint
            const idsToAssign = unassignedPlayers.map(p => p.id);
            if (idsToAssign.length < 2) return;

            const res = await api.post('/teams/auto', {
                tournament_id: createdTournamentId,
                player_ids: idsToAssign
            });
            
            setTeams(prev => [...prev, ...res.data]);
        } catch (err) {
            alert("Fout bij genereren teams.");
        }
    };

    const handleManualCreate = async () => {
        if (!createdTournamentId) return;
        if (manualSelection.length !== 2) {
            alert("Selecteer precies 2 spelers voor een team.");
            return;
        }

        try {
            const res = await api.post('/teams/manual', {
                tournament_id: createdTournamentId,
                player_ids: manualSelection,
                name: manualTeamName
            });
            setTeams(prev => [...prev, res.data]);
            
            // Reset form
            setManualSelection([]);
            setManualTeamName("");
        } catch (err) {
            alert("Fout bij aanmaken team.");
        }
    };

    const handleFinalize = async () => {
        // Hier zou je normaliter een endpoint aanroepen om matches te genereren op basis van teams
        // Voor nu sturen we de gebruiker naar het dashboard
        if (unassignedPlayers.length > 0) {
            if(!confirm("Er zijn nog spelers niet ingedeeld in een team. Wil je toch doorgaan?")) return;
        }
        navigate(`/dashboard/tournament/${createdTournamentId}`);
    };

    // ---------------- UI RENDER ----------------

    return (
        <AdminLayout>
            <div className="max-w-6xl mx-auto pb-20">
                
                {/* HEADER */}
                <h2 className="text-3xl font-bold text-gray-800 mb-6 flex items-center gap-2">
                    {step === 1 ? <Trophy className="text-yellow-500" /> : <Users className="text-blue-500" />} 
                    {step === 1 ? "Nieuw Toernooi" : "Team Indeling"}
                </h2>

                {error && (
                    <div className="bg-red-50 text-red-600 p-4 rounded-lg mb-6 flex items-center gap-2 border border-red-200 shadow-sm">
                        <AlertCircle size={20} /> <span className="font-medium">{error}</span>
                    </div>
                )}

                {/* --- STAP 1: SETTINGS & PLAYERS --- */}
                {step === 1 && (
                    <form onSubmit={handleCreateTournament} className="grid grid-cols-1 lg:grid-cols-12 gap-6">
                        
                        {/* SETTINGS (LINKS) */}
                        <div className="lg:col-span-4 space-y-6">
                            
                            {/* Algemeen */}
                            <div className="bg-white p-5 rounded-lg shadow-sm border border-gray-200">
                                <h3 className="font-bold text-gray-700 mb-4 border-b border-gray-100 pb-2">1. Algemeen</h3>
                                <div className="space-y-4">
                                    <div>
                                        <label className={LABEL_STYLE}>Naam</label>
                                        <input type="text" className={INPUT_STYLE} value={name} onChange={e => setName(e.target.value)} placeholder={defaultName} />
                                    </div>
                                    <div>
                                        <label className={LABEL_STYLE}>Datum</label>
                                        <input type="date" required className={INPUT_STYLE} value={date} onChange={e => setDate(e.target.value)} />
                                    </div>
                                    
                                    {/* NIEUW: MODUS SELECTIE */}
                                    <div>
                                        <label className={LABEL_STYLE}>Modus</label>
                                        <div className="flex gap-2">
                                            <button type="button" 
                                                onClick={() => setParticipationMode('singles')}
                                                className={`flex-1 py-2 px-3 rounded border text-sm font-bold transition-colors ${participationMode === 'singles' ? 'bg-blue-600 text-white border-blue-600' : 'bg-gray-50 text-gray-600 border-gray-300'}`}
                                            >
                                                1 vs 1
                                            </button>
                                            <button type="button" 
                                                onClick={() => setParticipationMode('doubles')}
                                                className={`flex-1 py-2 px-3 rounded border text-sm font-bold transition-colors ${participationMode === 'doubles' ? 'bg-blue-600 text-white border-blue-600' : 'bg-gray-50 text-gray-600 border-gray-300'}`}
                                            >
                                                Koppels
                                            </button>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            {/* Format Settings */}
                            <div className="bg-white p-5 rounded-lg shadow-sm border border-gray-200">
                                <h3 className="font-bold text-gray-700 mb-4 border-b border-gray-100 pb-2 flex items-center gap-2">
                                    <LayoutGrid size={18} className="text-blue-500" /> Format
                                </h3>
                                <div className="space-y-4">
                                    <select className={INPUT_STYLE} value={format} onChange={e => setFormat(e.target.value)}>
                                        <option value="hybrid">Hybride (Poules + KO)</option>
                                        <option value="knockout">Direct Knockout</option>
                                        <option value="round_robin">Alleen Poules</option>
                                    </select>

                                    <div className="flex items-start gap-2 p-2 bg-gray-50 rounded border border-gray-100">
                                        <input type="checkbox" id="allowByes" className="mt-1" checked={allowByes} onChange={e => setAllowByes(e.target.checked)} />
                                        <div>
                                            <label htmlFor="allowByes" className="text-sm font-bold text-gray-700">Sta Byes toe</label>
                                            <p className="text-xs text-gray-500">Automatische vrijloting bij oneven aantal.</p>
                                        </div>
                                    </div>

                                    {format === 'hybrid' && (
                                        <div className="grid grid-cols-2 gap-3">
                                            <div>
                                                <label className={LABEL_STYLE}>Poules</label>
                                                <input type="number" min="1" className={INPUT_STYLE} value={poules} onChange={e => setPoules(parseInt(e.target.value))} />
                                            </div>
                                            <div>
                                                <label className={LABEL_STYLE}>Qualifiers</label>
                                                <input type="number" min="1" className={INPUT_STYLE} value={qualifiersPerPoule} onChange={e => setQualifiersPerPoule(parseInt(e.target.value))} />
                                            </div>
                                        </div>
                                    )}
                                </div>
                            </div>
                            
                            {/* Wedstrijd Lengte & Borden (Ingekort voor overzicht) */}
                            <div className="bg-white p-5 rounded-lg shadow-sm border border-gray-200">
                                <h3 className="font-bold text-gray-700 mb-4 border-b border-gray-100 pb-2 flex items-center gap-2">
                                    <Target size={18} className="text-red-500" /> Settings
                                </h3>
                                <div className="grid grid-cols-2 gap-3 mb-4">
                                    <div><label className={LABEL_STYLE}>Poule (Bo)</label><input type="number" className={INPUT_STYLE} value={groupLegs} onChange={e => setGroupLegs(Number(e.target.value))}/></div>
                                    <div><label className={LABEL_STYLE}>KO (Bo)</label><input type="number" className={INPUT_STYLE} value={koLegs} onChange={e => setKoLegs(Number(e.target.value))}/></div>
                                </div>
                                
                                <label className={LABEL_STYLE}>Borden</label>
                                <div className="max-h-32 overflow-y-auto space-y-1 pr-1 custom-scrollbar border rounded p-2">
                                    {allBoards.map(board => (
                                        <label key={board.id} className={`flex items-center p-1 rounded cursor-pointer text-sm ${selectedBoardIds.includes(board.id) ? 'bg-blue-50 text-blue-700' : ''}`}>
                                            <input type="checkbox" className="mr-2" checked={selectedBoardIds.includes(board.id)} onChange={() => toggleBoard(board.id)} />
                                            Bord {board.number}
                                        </label>
                                    ))}
                                </div>
                            </div>
                        </div>

                        {/* SPELERS SELECTIE (RECHTS) */}
                        <div className="lg:col-span-8 flex flex-col h-full">
                            <div className="bg-white p-6 rounded-lg shadow-sm border border-gray-200 flex-1 flex flex-col">
                                <div className="flex justify-between items-center mb-4 border-b border-gray-100 pb-2">
                                    <h3 className="font-bold text-gray-700 flex items-center gap-2">
                                        <Users size={18} className="text-green-600"/> 
                                        {participationMode === 'doubles' ? '2. Selecteer Alle Deelnemers' : '2. Selecteer Spelers'}
                                    </h3>
                                    <span className="bg-green-100 text-green-700 text-xs px-3 py-1 rounded-full font-bold">
                                        {selectedPlayerIds.length} geselecteerd
                                    </span>
                                </div>
                                
                                <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-2 overflow-y-auto pr-2 max-h-[600px] custom-scrollbar">
                                    {allPlayers.map(player => (
                                        <label key={player.id} className={`flex items-center p-2 rounded border cursor-pointer select-none text-sm transition-all ${selectedPlayerIds.includes(player.id) ? 'bg-green-50 border-green-500 shadow-sm' : 'hover:bg-gray-50 border-gray-200'}`}>
                                            <input type="checkbox" className="w-4 h-4 text-green-600 rounded accent-green-600" checked={selectedPlayerIds.includes(player.id)} onChange={() => togglePlayer(player.id)} />
                                            <div className="ml-2 font-medium text-gray-800 truncate">{player.name}</div>
                                        </label>
                                    ))}
                                </div>

                                <div className="mt-6 pt-4 border-t border-gray-100">
                                    <button type="submit" disabled={loading} className="w-full bg-blue-600 text-white font-bold py-3 rounded-lg hover:bg-blue-700 transition shadow-lg flex justify-center items-center gap-2">
                                        {participationMode === 'doubles' ? (
                                            <>Verder naar Team Indeling <Scissors className="ml-2" size={18}/></>
                                        ) : (
                                            <><Trophy size={20} /> Toernooi Starten</>
                                        )}
                                    </button>
                                </div>
                            </div>
                        </div>
                    </form>
                )}

                {/* --- STAP 2: TEAM BUILDER (ALLEEN BIJ KOPPELS) --- */}
                {step === 2 && (
                    <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
                        
                        {/* LINKER KOLOM: BESCHIKBARE SPELERS & CONTROLS */}
                        <div className="space-y-6">
                            
                            {/* Auto Generator */}
                            <div className="bg-white p-6 rounded-lg shadow-sm border border-gray-200">
                                <h3 className="font-bold text-gray-700 mb-2 flex items-center gap-2">
                                    <Shuffle className="text-purple-500" /> Automatisch Indelen
                                </h3>
                                <p className="text-sm text-gray-500 mb-4">
                                    Hussel alle {unassignedPlayers.length} overgebleven spelers in willekeurige teams.
                                </p>
                                <button 
                                    onClick={handleAutoGenerate}
                                    disabled={unassignedPlayers.length < 2}
                                    className="w-full bg-purple-100 text-purple-700 font-bold py-2 rounded hover:bg-purple-200 transition disabled:opacity-50"
                                >
                                    Random Teams Genereren
                                </button>
                            </div>

                            {/* Manual Creator */}
                            <div className="bg-white p-6 rounded-lg shadow-sm border border-gray-200">
                                <h3 className="font-bold text-gray-700 mb-4 flex items-center gap-2">
                                    <UserPlus className="text-blue-500" /> Handmatig Team
                                </h3>
                                
                                <div className="mb-4">
                                    <label className={LABEL_STYLE}>1. Selecteer 2 spelers uit de lijst hieronder</label>
                                    <div className="text-sm font-medium bg-gray-50 p-2 rounded border border-gray-200 min-h-[40px] flex items-center gap-2">
                                        {manualSelection.length === 0 && <span className="text-gray-400 italic">Geen selectie...</span>}
                                        {manualSelection.map(id => {
                                            const p = allPlayers.find(pl => pl.id === id);
                                            return (
                                                <span key={id} className="bg-blue-100 text-blue-700 px-2 py-1 rounded text-xs">
                                                    {p?.name}
                                                </span>
                                            );
                                        })}
                                    </div>
                                </div>

                                <div className="mb-4">
                                    <label className={LABEL_STYLE}>2. Team Naam (Optioneel)</label>
                                    <input 
                                        type="text" 
                                        className={INPUT_STYLE} 
                                        placeholder="Bijv. 'The Power Duo'" 
                                        value={manualTeamName}
                                        onChange={e => setManualTeamName(e.target.value)}
                                    />
                                </div>

                                <button 
                                    onClick={handleManualCreate}
                                    disabled={manualSelection.length !== 2}
                                    className="w-full bg-blue-600 text-white font-bold py-2 rounded hover:bg-blue-700 transition disabled:opacity-50"
                                >
                                    Maak Team
                                </button>
                            </div>

                            {/* Beschikbare Spelers Lijst */}
                            <div className="bg-white p-4 rounded-lg shadow-sm border border-gray-200">
                                <h4 className="font-bold text-gray-500 text-xs uppercase mb-2">Nog in te delen ({unassignedPlayers.length})</h4>
                                <div className="grid grid-cols-2 gap-2 max-h-60 overflow-y-auto pr-1 custom-scrollbar">
                                    {unassignedPlayers.map(p => (
                                        <div 
                                            key={p.id} 
                                            onClick={() => toggleManualSelection(p.id)}
                                            className={`p-2 rounded border text-sm cursor-pointer transition-colors ${
                                                manualSelection.includes(p.id) 
                                                ? 'bg-blue-50 border-blue-500 text-blue-700 font-bold' 
                                                : 'hover:bg-gray-50 border-gray-200'
                                            }`}
                                        >
                                            {p.name}
                                        </div>
                                    ))}
                                </div>
                            </div>

                        </div>

                        {/* RECHTER KOLOM: GEMAAKTE TEAMS */}
                        <div className="flex flex-col h-full">
                            <div className="bg-white p-6 rounded-lg shadow-sm border border-gray-200 flex-1 flex flex-col">
                                <div className="flex justify-between items-center mb-4 border-b border-gray-100 pb-2">
                                    <h3 className="font-bold text-gray-700">Gemaakte Teams</h3>
                                    <span className="bg-green-100 text-green-700 text-xs px-3 py-1 rounded-full font-bold">
                                        {teams.length} Teams
                                    </span>
                                </div>

                                <div className="flex-1 overflow-y-auto space-y-3 pr-2 custom-scrollbar">
                                    {teams.length === 0 ? (
                                        <div className="text-center text-gray-400 py-10 italic">
                                            Nog geen teams gemaakt.<br/>Gebruik de opties links.
                                        </div>
                                    ) : (
                                        teams.map(team => (
                                            <div key={team.id} className="flex items-center justify-between p-3 bg-gray-50 rounded border border-gray-200">
                                                <div>
                                                    <div className="font-bold text-gray-800">{team.name}</div>
                                                    <div className="text-xs text-gray-500 flex gap-1 mt-1">
                                                        {team.players.map(p => (
                                                            <span key={p.id} className="bg-white border px-1 rounded">
                                                                {p.name}
                                                            </span>
                                                        ))}
                                                    </div>
                                                </div>
                                                {/* Verwijderen functionaliteit zou hier kunnen met een delete API call */}
                                                <div className="text-green-500"><Target size={16}/></div>
                                            </div>
                                        ))
                                    )}
                                </div>

                                <div className="mt-6 pt-4 border-t border-gray-100">
                                    <button 
                                        onClick={handleFinalize}
                                        className="w-full bg-green-600 text-white font-bold py-3 rounded-lg hover:bg-green-700 transition shadow-lg flex justify-center items-center gap-2"
                                    >
                                        <Save size={20} /> Opslaan & Starten
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                )}
            </div>
        </AdminLayout>
    );
};

export default CreateTournament;

==================================================
FILE: frontend/src\pages\admin\Dashboard.tsx
==================================================

import { useEffect, useState } from 'react';
import { Link } from 'react-router-dom';
import api from '../../services/api';
import AdminLayout from '../../components/layout/AdminLayout';
import { Trophy, Calendar, Users, ExternalLink, Copy, Target, LayoutGrid } from 'lucide-react';
import { Tournament } from '../../types';
import { useNavigate } from 'react-router-dom';

const Dashboard = () => {
  const [tournaments, setTournaments] = useState<Tournament[]>([]);
  const [loading, setLoading] = useState(true);
  const navigate = useNavigate();
  // 1. Fetch tournaments from the Backend
  useEffect(() => {
    const fetchTournaments = async () => {
      try {
        const res = await api.get('/tournaments/');
        // Sort by newest first
        const sorted = res.data.sort((a: Tournament, b: Tournament) => 
          new Date(b.date).getTime() - new Date(a.date).getTime()
        );
        setTournaments(sorted);
      } catch (error) {
        console.error("Failed to load tournaments");
      } finally {
        setLoading(false);
      }
    };

    fetchTournaments();
  }, []);

  // Helper to copy the public link
  const copyToClipboard = (uuid: string) => {
    const url = `${window.location.origin}/t/${uuid}`;
    navigator.clipboard.writeText(url);
    alert("Public link copied to clipboard!");
  };

  return (
    <AdminLayout>
      <div className="flex justify-between items-center mb-8">
        <div>
          <h2 className="text-3xl font-bold text-gray-800">Dashboard</h2>
          <p className="text-gray-500">Welcome back to your tournament center.</p>
        </div>
        <Link 
          to="/dashboard/create-tournament" 
          className="bg-blue-600 text-white px-4 py-2 rounded-lg font-bold hover:bg-blue-700 transition flex items-center gap-2 shadow-sm"
        >
          <Trophy size={18} />
          New Tournament
        </Link>
      </div>

      {loading ? (
        <div className="text-center py-12 text-gray-400">Loading tournaments...</div>
      ) : (
        <div className="grid gap-6">
          {tournaments.length === 0 ? (
            <div className="bg-white p-12 rounded-lg shadow-sm text-center border-2 border-dashed border-gray-200">
              <Trophy className="mx-auto h-12 w-12 text-gray-300 mb-4" />
              <h3 className="text-lg font-medium text-gray-900">No tournaments yet</h3>
              <p className="mt-1 text-gray-500">Get started by creating your first tournament.</p>
            </div>
          ) : (
            tournaments.map((t) => (
              <div key={t.id} className="bg-white p-6 rounded-lg shadow-sm border border-gray-100 hover:shadow-md transition-shadow">
                <div className="flex flex-col md:flex-row justify-between md:items-center gap-4">
                  
                  {/* Left: Info */}
                  <div>
                    <div className="flex items-center gap-3 mb-1">
                      <h3 className="text-xl font-bold text-blue-900">{t.name}</h3>
                      <span className={`text-xs px-2 py-1 rounded-full uppercase font-bold tracking-wide ${
                        t.status === 'active' ? 'bg-green-100 text-green-700' : 'bg-gray-100 text-gray-600'
                      }`}>
                        {t.status}
                      </span>
                    </div>
                    
                    <div className="flex flex-wrap items-center gap-4 text-sm text-gray-500 mt-2">
                      <span className="flex items-center gap-1">
                        <Calendar size={14} />
                        {new Date(t.date).toLocaleDateString()}
                      </span>
                      <span className="flex items-center gap-1" title="Players">
                        <Users size={14} />
                        {t.player_count || 0} Players
                      </span>
                      <span className="flex items-center gap-1" title="Boards">
                        <Target size={14} />
                        {t.board_count || 0} Boards
                      </span>
                      <span className="flex items-center gap-1" title="Poules">
                        <LayoutGrid size={14} />
                        {t.number_of_poules || 1} Poules
                      </span>
                    </div>
                  </div>

                  {/* Right: Actions */}
                  <div className="flex items-center gap-3">
                    <button 
                      onClick={() => copyToClipboard(t.public_uuid || '')}
                      className="p-2 text-gray-400 hover:text-blue-600 hover:bg-blue-50 rounded transition"
                      title="Copy Public Link"
                    >
                      <Copy size={20} />
                    </button>
                    
                    <Link 
                      to={`/t/${t.public_uuid}`}
                      target="_blank"
                      className="flex items-center gap-2 px-4 py-2 border border-gray-200 rounded text-gray-600 font-medium hover:bg-gray-50 transition"
                    >
                      <ExternalLink size={18} />
                      Public View
                    </Link>

                  <button 
                    onClick={() => navigate(`/dashboard/tournament/${t.id}`)}
                    className="bg-slate-800 text-white px-5 py-2 rounded font-medium hover:bg-slate-900 transition shadow-sm"
                  >
                    Manage
                  </button>
                  </div>

                </div>
              </div>
            ))
          )}
        </div>
      )}
    </AdminLayout>
  );
};

export default Dashboard;

==================================================
FILE: frontend/src\pages\admin\ManageBoards.tsx
==================================================

import { useEffect, useState } from 'react';
import api from '../../services/api';
import { Trash2, Target } from 'lucide-react';
import AdminLayout from '../../components/layout/AdminLayout';
import { Dartboard } from '../../types';

const ManageBoards = () => {
  const [boards, setBoards] = useState<Dartboard[]>([]);
  const [formData, setFormData] = useState({ name: '', number: '' });

  useEffect(() => { loadBoards(); }, []);

  const loadBoards = async () => {
    try {
      const response = await api.get('/dartboards/');
      setBoards(response.data);
    } catch (err) { console.error(err); }
  };

  const handleAdd = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      await api.post('/dartboards/', {
        name: formData.name,
        number: parseInt(formData.number)
      });
      setFormData({ name: '', number: '' });
      loadBoards();
    } catch (err) { alert("Error adding board"); }
  };

  const handleDelete = async (id: number) => {
    if(!confirm("Delete this board?")) return;
    try { await api.delete(`/dartboards/${id}`); loadBoards(); }
    catch (err) { alert("Error deleting board"); }
  };

  return (
    <AdminLayout>
      <h2 className="text-3xl font-bold text-gray-800 mb-8">Manage Dartboards</h2>
      
      <div className="grid grid-cols-1 md:grid-cols-3 gap-8">
        {/* Form */}
        <div className="bg-white p-6 rounded-lg shadow-sm h-fit">
          <h3 className="font-semibold mb-4 flex items-center gap-2">
            <Target className="text-blue-600" /> Add Board
          </h3>
          <form onSubmit={handleAdd} className="space-y-4">
            <div>
              <label className="block text-xs font-bold text-gray-700 mb-1">Board Number</label>
              <input type="number" required className="w-full border rounded p-2"
                value={formData.number}
                onChange={e => setFormData({...formData, number: e.target.value})}
              />
            </div>
            <div>
              <label className="block text-xs font-bold text-gray-700 mb-1">Location Name</label>
              <input type="text" required placeholder="e.g. Main Stage" className="w-full border rounded p-2"
                value={formData.name}
                onChange={e => setFormData({...formData, name: e.target.value})}
              />
            </div>
            <button type="submit" className="w-full bg-blue-600 text-white font-bold py-2 rounded hover:bg-blue-700">
              Add Board
            </button>
          </form>
        </div>

        {/* List */}
        <div className="md:col-span-2 grid grid-cols-1 sm:grid-cols-2 gap-4">
          {boards.map(board => (
            <div key={board.id} className="bg-white p-4 rounded-lg shadow-sm border-l-4 border-blue-500 flex justify-between items-center">
              <div>
                <span className="text-xs font-bold text-gray-400 uppercase">Board {board.number}</span>
                <div className="text-lg font-bold text-gray-800">{board.name}</div>
              </div>
              <button onClick={() => handleDelete(board.id)} className="text-gray-400 hover:text-red-500">
                <Trash2 size={20} />
              </button>
            </div>
          ))}
        </div>
      </div>
    </AdminLayout>
  );
};

export default ManageBoards;

==================================================
FILE: frontend/src\pages\admin\ManagePlayers.tsx
==================================================

import { useEffect, useState } from 'react';
import api from '../../services/api';
import { Trash2, UserPlus } from 'lucide-react';
import AdminLayout from '../../components/layout/AdminLayout';
import { Player } from '../../types';

const ManagePlayers = () => {
  const [players, setPlayers] = useState<Player[]>([]);
  const [loading, setLoading] = useState(true);
  
  // State for the 4 input fields
  const [formData, setFormData] = useState({
    first_name: '',
    last_name: '',
    nickname: '',
    email: ''
  });

  // Load players when page opens
  useEffect(() => {
    loadPlayers();
  }, []);

  const loadPlayers = async () => {
    try {
      const response = await api.get('/players/');
      setPlayers(response.data);
    } catch (error) {
      console.error("Failed to load players");
    } finally {
      setLoading(false);
    }
  };

  const handleAddPlayer = async (e: React.FormEvent) => {
    e.preventDefault();
    
    // DATA CLEANING:
    // We must convert empty strings "" to null, otherwise the backend
    // will think we are sending an invalid email address.
    const payload = {
      first_name: formData.first_name,
      last_name: formData.last_name.trim() === '' ? null : formData.last_name,
      nickname: formData.nickname.trim() === '' ? null : formData.nickname,
      email: formData.email.trim() === '' ? null : formData.email
    };

    try {
      await api.post('/players/', payload);
      
      // Clear the form
      setFormData({
        first_name: '',
        last_name: '',
        nickname: '',
        email: ''
      });
      
      // Refresh the list
      loadPlayers(); 
    } catch (error: any) {
      console.error("Error adding player:", error.response?.data);
      alert("Error adding player. Please check that the email is valid (or leave it empty).");
    }
  };

  const handleDelete = async (id: number) => {
    if (!confirm("Are you sure you want to delete this player?")) return;
    try {
      await api.delete(`/players/${id}`);
      loadPlayers();
    } catch (error) {
      alert("Error deleting player");
    }
  };

  return (
    <AdminLayout>
      <div className="max-w-4xl mx-auto">
        <h2 className="text-3xl font-bold text-gray-800 mb-8">Manage Players</h2>

        {/* --- Add Player Form --- */}
        <div className="bg-white p-6 rounded-lg shadow-sm mb-8">
          <h3 className="text-lg font-semibold mb-4 text-gray-700">Add New Player</h3>
          
          <form onSubmit={handleAddPlayer} className="space-y-4">
            
            {/* Row 1: First & Last Name */}
            <div className="grid grid-cols-2 gap-4">
              <div>
                <label className="block text-xs font-bold text-gray-700 mb-1">First Name*</label>
                <input 
                  type="text" 
                  required
                  className="w-full border rounded p-2 text-sm focus:ring-2 focus:ring-blue-500 outline-none"
                  value={formData.first_name}
                  onChange={(e) => setFormData({...formData, first_name: e.target.value})}
                  placeholder="Luke"
                />
              </div>
              
              <div>
                <label className="block text-xs font-bold text-gray-700 mb-1">Last Name</label>
                <input 
                  type="text" 
                  className="w-full border rounded p-2 text-sm focus:ring-2 focus:ring-blue-500 outline-none"
                  value={formData.last_name}
                  onChange={(e) => setFormData({...formData, last_name: e.target.value})}
                  placeholder="Littler"
                />
              </div>
            </div>

            {/* Row 2: Nickname & Email */}
            <div className="grid grid-cols-2 gap-4">
              <div>
                <label className="block text-xs font-bold text-gray-700 mb-1">Nickname</label>
                <input 
                  type="text" 
                  className="w-full border rounded p-2 text-sm focus:ring-2 focus:ring-blue-500 outline-none"
                  value={formData.nickname}
                  onChange={(e) => setFormData({...formData, nickname: e.target.value})}
                  placeholder='e.g. "The Nuke"'
                />
              </div>
              <div>
                <label className="block text-xs font-bold text-gray-700 mb-1">Email</label>
                <input 
                  type="email" 
                  className="w-full border rounded p-2 text-sm focus:ring-2 focus:ring-blue-500 outline-none"
                  value={formData.email}
                  onChange={(e) => setFormData({...formData, email: e.target.value})}
                  placeholder="luke@darts.com"
                />
              </div>
            </div>

            <button
              type="submit"
              className="w-full bg-blue-600 text-white px-6 py-2 rounded-lg hover:bg-blue-700 flex items-center justify-center gap-2 font-medium mt-4 transition-colors"
            >
              <UserPlus size={20} />
              Add Player
            </button>
          </form>
        </div>

        {/* --- Players List --- */}
        <div className="bg-white rounded-lg shadow-sm overflow-hidden">
          <div className="p-4 border-b bg-gray-50 font-medium text-gray-500 flex justify-between items-center">
            <span>Total Players: {players.length}</span>
          </div>
          
          {loading ? (
             <div className="p-8 text-center text-gray-500">Loading players...</div>
          ) : players.length === 0 ? (
            <div className="p-8 text-center text-gray-500">No players found. Add one above!</div>
          ) : (
            <ul className="divide-y divide-gray-100">
              {players.map((player) => (
                <li key={player.id} className="p-4 flex items-center justify-between hover:bg-gray-50 transition">
                  <div>
                    {/* The 'name' property comes formatted from the backend (e.g. Luke "The Nuke" Littler) */}
                    <div className="text-lg text-gray-800 font-medium">{player.name}</div>
                    
                    <div className="text-xs text-gray-400">
                       {player.email ? player.email : "No email linked"}
                    </div>
                  </div>
                  
                  <button
                    onClick={() => handleDelete(player.id)}
                    className="text-gray-400 hover:text-red-600 p-2 rounded-full hover:bg-red-50 transition"
                    title="Delete Player"
                  >
                    <Trash2 size={20} />
                  </button>
                </li>
              ))}
            </ul>
          )}
        </div>
      </div>
    </AdminLayout>
  );
};

export default ManagePlayers;

==================================================
FILE: frontend/src\pages\admin\ManageTournament.tsx
==================================================

import { useEffect, useState } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import api from '../../services/api';
import AdminLayout from '../../components/layout/AdminLayout';
import { Save, RefreshCcw, ShieldAlert, Settings, ChevronDown, ChevronRight, SaveAll, GitMerge } from 'lucide-react';
import { Tournament, Match } from '../../types';

interface MatchWithUI extends Match {
  best_of_legs: number;
  player1_name: string;
  player2_name: string;
  score_p1: number;
  score_p2: number;
  is_completed: boolean;
  round_number: number;
  poule_number: number | null;
  is_saving?: boolean;
  save_success?: boolean;
}

const ManageTournament = () => {
  const { id } = useParams();
  const navigate = useNavigate();
  
  const [tournament, setTournament] = useState<Tournament | null>(null);
  const [matches, setMatches] = useState<MatchWithUI[]>([]);
  const [loading, setLoading] = useState(true);
  
  // Settings State
  const [allowByes, setAllowByes] = useState(true);
  const [settingsDirty, setSettingsDirty] = useState(false);

  // Round Collapses
  const [openRounds, setOpenRounds] = useState<Record<string, boolean>>({});

  useEffect(() => {
    loadData();
  }, [id]);

  const loadData = async () => {
    setLoading(true);
    try {
      const tournRes = await api.get(`/tournaments/${id}`);
      const currentTourn = tournRes.data;
      setTournament(currentTourn);
      setAllowByes(currentTourn.allow_byes);

if (currentTourn.public_uuid) {
          const matchesRes = await api.get(`/matches/by-tournament/${currentTourn.public_uuid}`);
          setMatches(matchesRes.data);
          
          if (matchesRes.data.length > 0) {
              const maxRoundMatch = matchesRes.data.reduce((prev: any, current: any) => {
                  return (prev.id > current.id) ? prev : current;
              });
              
              const type = maxRoundMatch.poule_number !== null ? 'P' : 'K';
              const key = `${type}-${maxRoundMatch.round_number}`;
              
              setOpenRounds((prev) => ({ ...prev, [key]: true }));
              // --- FIX END ---
          }
      }
    } catch (error) {
      console.error("Fout bij laden data:", error);
    } finally {
      setLoading(false);
    }
  };

  // --- ACTIES ---

  const handleUpdateSettings = async () => {
    if (!tournament) return;
    try {
        await api.patch(`/tournaments/${tournament.id}`, { allow_byes: allowByes });
        setSettingsDirty(false);
        alert("Instellingen opgeslagen.");
    } catch (err) {
        alert("Fout bij opslaan instellingen.");
    }
  };

  const handleResetMatch = async (matchId: number) => {
    if (!confirm("Resetten naar 0-0 en open zetten?")) return;
    try {
        await api.put(`/matches/${matchId}/score`, {
            score_p1: 0,
            score_p2: 0,
            is_completed: false
        });
        setMatches(prev => prev.map(m => m.id === matchId ? { ...m, score_p1: 0, score_p2: 0, is_completed: false } : m));
    } catch (err) {
        alert("Reset mislukt.");
    }
  };

  const handleBatchUpdateRound = async (roundNum: number, legs: number) => {
    if (!tournament) return;
    if (!confirm(`Zet alle ONGESPEELDE wedstrijden in ronde ${roundNum} naar Best of ${legs}?`)) return;
    try {
        await api.post(`/tournaments/${tournament.id}/rounds/${roundNum}/update-format?best_of_legs=${legs}`);
        loadData();
    } catch (err) {
        alert("Update mislukt.");
    }
  };

  const toggleRound = (key: string) => setOpenRounds(prev => ({...prev, [key]: !prev[key]}));

  // --- SPREADSHEET LOGICA ---

  const handleScoreChange = (id: number, field: 'score_p1' | 'score_p2', value: string) => {
      const numVal = value === '' ? 0 : parseInt(value);
      setMatches(prev => prev.map(m => 
          m.id === id ? { ...m, [field]: numVal, save_success: false } : m
      ));
  };

  const canStartKnockout = () => {
      if (!tournament || !matches.length) return false;
      if (tournament.format !== 'hybrid') return false; // Alleen voor hybride toernooien

      const pouleMatches = matches.filter(m => m.poule_number !== null);
      const koMatches = matches.filter(m => m.poule_number === null);

      // 1. Zijn er poule wedstrijden?
      if (pouleMatches.length === 0) return false;

      // 2. Zijn ze ALLEMAAL klaar?
      const allPoulesFinished = pouleMatches.every(m => m.is_completed);

      // 3. Is de knockout nog NIET begonnen?
      const koNotStarted = koMatches.length === 0;

      return allPoulesFinished && koNotStarted;
  };

  const handleStartKnockout = async () => {
      if (!confirm("Weet je zeker dat je de Poule-fase wilt afsluiten en de Knockout wilt genereren?")) return;
      
      try {
          // De API endpoint die we eerder hebben gezien in de context [cite: 35]
          await api.post(`/tournaments/${id}/start-knockout`);
          alert("Knockout fase gegenereerd!");
          loadData(); // Herlaad de data om de nieuwe wedstrijden te tonen
      } catch (err) {
          console.error(err);
          alert("Er ging iets mis bij het starten van de knockout.");
      }
  };

  const saveMatchScore = async (match: MatchWithUI) => {
      setMatches(prev => prev.map(m => m.id === match.id ? { ...m, is_saving: true } : m));

      try {
          await api.put(`/matches/${match.id}/score`, {
              score_p1: match.score_p1,
              score_p2: match.score_p2,
              is_completed: true 
          });

          setMatches(prev => prev.map(m => m.id === match.id ? { ...m, is_saving: false, save_success: true, is_completed: true } : m));
          
          setTimeout(() => {
            setMatches(prev => prev.map(m => m.id === match.id ? { ...m, save_success: false } : m));
          }, 2000);

      } catch (err) {
          console.error(err);
          setMatches(prev => prev.map(m => m.id === match.id ? { ...m, is_saving: false } : m));
      }
  };

  const handleKeyDown = (e: React.KeyboardEvent, match: MatchWithUI) => {
      if (e.key === 'Enter') {
          saveMatchScore(match);
          (e.currentTarget as HTMLInputElement).blur(); 
      }
  };

  const getRoundName = (roundNum: number, matchCount: number) => {
    if (matchCount === 1) return "Finale";
    if (matchCount === 2) return "Halve Finale";
    if (matchCount === 4) return "Kwartfinale";
    return `Ronde ${roundNum}`;
};

  // 1. Groepeer op FASE (P/K) én RONDE nummer
  // We maken keys zoals "P-1" (Poule ronde 1) en "K-1" (Knockout ronde 1)
  const groupedMatches = matches.reduce((acc, match) => {
    const type = match.poule_number !== null ? 'P' : 'K'; // P = Poule, K = Knockout
    const key = `${type}-${match.round_number}`;
    
    if (!acc[key]) acc[key] = [];
    acc[key].push(match);
    return acc;
  }, {} as Record<string, MatchWithUI[]>);

  // 2. Sorteer de keys
  // We willen eerst Poules (P), dan Knockouts (K). Binnen die groepen sorteren we op ronde nummer.
  const sortedGroupKeys = Object.keys(groupedMatches).sort((a, b) => {
      const [typeA, roundA] = a.split('-');
      const [typeB, roundB] = b.split('-');

      // Als types verschillend zijn: P komt voor K
      if (typeA !== typeB) return typeA === 'P' ? -1 : 1;

      // Als types gelijk zijn: Sorteer op nummer (1, 2, 3...)
      return Number(roundA) - Number(roundB);
  });

  // --- RENDERING ---

  if (loading) {
    return (
      <AdminLayout>
          <div className="flex justify-center items-center h-64 text-gray-500">
              <span className="animate-pulse">Gegevens ophalen...</span>
          </div>
      </AdminLayout>
    );
  }

  if (!tournament) {
    return (
      <AdminLayout>
          <div className="max-w-5xl mx-auto mt-8 bg-red-50 text-red-600 p-6 rounded-lg border border-red-200">
              <h3 className="font-bold text-lg flex items-center gap-2"><ShieldAlert /> Toernooi niet gevonden</h3>
              <button onClick={() => navigate('/dashboard')} className="mt-4 text-blue-600 hover:underline">&larr; Terug</button>
          </div>
      </AdminLayout>
    );
  }

  return (
    <AdminLayout>
      {/* CSS Hack om de pijltjes (spinners) van input[type=number] te verbergen */}
      <style>{`
        .no-spinner::-webkit-inner-spin-button, 
        .no-spinner::-webkit-outer-spin-button { 
          -webkit-appearance: none; 
          margin: 0; 
        } 
        .no-spinner { 
          -moz-appearance: textfield; 
        }
      `}</style>

      <div className="max-w-5xl mx-auto pb-20">
        <div className="flex justify-between items-center mb-6">
            <h2 className="text-3xl font-bold text-gray-800 flex items-center gap-3">
                <Settings className="text-gray-600" />
                Beheer: <span className="text-blue-600">{tournament.name}</span>
            </h2>
            <button onClick={loadData} className="p-2 bg-gray-200 rounded hover:bg-gray-300">
                <RefreshCcw size={20} />
            </button>
        </div>

        {/* NIEUW: START KNOCKOUT KNOP (Alleen zichtbaar als poules klaar zijn) */}
        {canStartKnockout() && (
            <div className="bg-green-50 border border-green-200 rounded-lg p-4 mb-6 flex justify-between items-center shadow-sm animate-pulse">
                <div className="flex items-center gap-3">
                    <div className="bg-green-100 p-2 rounded-full text-green-600">
                        <GitMerge size={24} />
                    </div>
                    <div>
                        <h4 className="font-bold text-green-800">Poule Fase Voltooid!</h4>
                        <p className="text-sm text-green-600">Alle wedstrijden zijn gespeeld. Je kunt nu de bracket genereren.</p>
                    </div>
                </div>
                <button 
                    onClick={handleStartKnockout}
                    className="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-6 rounded-lg shadow transition-transform transform hover:scale-105"
                >
                    Start Knockout Fase
                </button>
            </div>
        )}


        {/* SETTINGS */}
        <div className="bg-white p-6 rounded-lg shadow-sm border border-yellow-200 mb-8">
            <h3 className="font-bold text-lg mb-4 flex items-center gap-2">
                <ShieldAlert className="text-yellow-500" /> Instellingen
            </h3>
            <div className="flex items-center gap-6">
                <label className="flex items-center gap-2 cursor-pointer">
                    <input type="checkbox" checked={allowByes} onChange={e => { setAllowByes(e.target.checked); setSettingsDirty(true); }} className="w-5 h-5 accent-blue-600"/>
                    <span className="font-medium text-gray-700">Allow Byes</span>
                </label>
                {settingsDirty && (
                    <button onClick={handleUpdateSettings} className="bg-blue-600 text-white px-4 py-1 rounded shadow hover:bg-blue-700 flex items-center gap-2 animate-pulse">
                        <Save size={16} /> Opslaan
                    </button>
                )}
            </div>
        </div>

{/* MATCHES LIST */}
        <div className="space-y-4">
            {sortedGroupKeys.map((groupKey) => {
                const [type, roundStr] = groupKey.split('-');
                const roundNum = Number(roundStr);
                const roundMatches = groupedMatches[groupKey];
                
                const isOpen = openRounds[groupKey];
                const isPoule = type === 'P';

                return (
                    <div key={groupKey} className={`rounded-lg shadow-sm border overflow-hidden ${isPoule ? 'bg-white border-gray-200' : 'bg-orange-50/50 border-orange-200'}`}>
                        {/* HEADER */}
                        <div 
                            className={`p-4 flex justify-between items-center cursor-pointer select-none ${isPoule ? 'bg-gray-50' : 'bg-orange-100 text-orange-900'}`} 
                            onClick={() => toggleRound(groupKey)}
                        >
                            <div className="flex items-center gap-2 font-bold text-gray-700">
                                {isOpen ? <ChevronDown size={20} /> : <ChevronRight size={20} />}
                                
                                {isPoule ? (
                                    <span>Poule Fase - Ronde {roundNum}</span>
                                ) : (
                                    <span className="text-orange-800 flex items-center gap-2">
                                        <GitMerge size={16}/> Knockout - {getRoundName(roundNum, roundMatches.length)}
                                    </span>
                                )}
                                
                                <span className={`text-xs px-2 py-0.5 rounded font-normal ${isPoule ? 'bg-gray-200 text-gray-600' : 'bg-orange-200 text-orange-800'}`}>
                                    {roundMatches.length} wedstrijden
                                </span>
                            </div>
                            
                            {isOpen && (
                                <div className="flex items-center gap-2" onClick={e => e.stopPropagation()}>
                                    <span className="text-xs text-gray-500 font-bold">Zet Best of:</span>
                                    <input type="number" min="1" className="w-12 text-center border rounded p-1 text-xs no-spinner" 
                                        placeholder={roundMatches[0].best_of_legs?.toString() || "5"}
                                        onKeyDown={(e) => e.key === 'Enter' && handleBatchUpdateRound(roundNum, parseInt(e.currentTarget.value))}
                                    />
                                </div>
                            )}
                        </div>

                        {/* ROWS */}
                        {isOpen && (
                            <div className="divide-y divide-gray-100">
                                {roundMatches.map(match => (
                                    <div key={match.id} className={`p-3 transition-colors flex items-center justify-between ${match.save_success ? 'bg-green-50' : 'hover:bg-white'}`}>
                                        
                                        {/* ID */}
                                        <div className="w-8 text-xs text-gray-400 font-mono text-center">#{match.id}</div>

                                        {/* PLAYERS & INPUTS */}
                                        <div className="flex-1 flex items-center justify-center gap-2">
                                            
                                            {/* SPELER 1 */}
                                            <div className={`flex-1 text-right truncate font-medium ${match.score_p1 > match.score_p2 && match.is_completed ? 'text-green-700 font-bold' : 'text-gray-700'}`}>
                                                {match.player1_name || <span className="italic text-gray-400">Bye</span>}
                                            </div>

                                            {/* INPUTS CONTAINER */}
                                            <div className="flex items-center bg-white border rounded shadow-sm overflow-hidden focus-within:ring-2 focus-within:ring-blue-400 focus-within:border-blue-400 transition-all">
                                                <input 
                                                    type="number" 
                                                    className={`w-12 text-center p-2 outline-none font-bold no-spinner ${match.save_success ? 'text-green-600' : 'text-gray-800'}`}
                                                    value={match.score_p1}
                                                    onChange={(e) => handleScoreChange(match.id, 'score_p1', e.target.value)}
                                                    onFocus={(e) => e.target.select()} 
                                                    onBlur={() => saveMatchScore(match)}
                                                    onKeyDown={(e) => handleKeyDown(e, match)}
                                                />
                                                <span className="text-gray-300 font-light px-1">|</span>
                                                <input 
                                                    type="number" 
                                                    className={`w-12 text-center p-2 outline-none font-bold no-spinner ${match.save_success ? 'text-green-600' : 'text-gray-800'}`}
                                                    value={match.score_p2}
                                                    onChange={(e) => handleScoreChange(match.id, 'score_p2', e.target.value)}
                                                    onFocus={(e) => e.target.select()}
                                                    onBlur={() => saveMatchScore(match)}
                                                    onKeyDown={(e) => handleKeyDown(e, match)}
                                                />
                                            </div>

                                            {/* SPELER 2 */}
                                            <div className={`flex-1 text-left truncate font-medium ${match.score_p2 > match.score_p1 && match.is_completed ? 'text-green-700 font-bold' : 'text-gray-700'}`}>
                                                {match.player2_name || <span className="italic text-gray-400">Bye</span>}
                                            </div>

                                        </div>

                                        {/* ACTIONS */}
                                        <div className="w-20 flex justify-end gap-1">
                                            {match.is_saving ? (
                                                <span className="p-2 text-blue-500 animate-spin"><RefreshCcw size={16}/></span>
                                            ) : match.save_success ? (
                                                <span className="p-2 text-green-500"><SaveAll size={16}/></span>
                                            ) : (
                                                <button onClick={() => handleResetMatch(match.id)} className="p-2 text-gray-300 hover:text-red-500 transition" title="Reset">
                                                    <RefreshCcw size={16} />
                                                </button>
                                            )}
                                        </div>

                                    </div>
                                ))}
                            </div>
                        )}
                    </div>
                );
            })}
        </div>
      </div>
    </AdminLayout>
  );
};

export default ManageTournament;

==================================================
FILE: frontend/src\pages\admin\SystemLogs.tsx
==================================================

import { useEffect, useState, useRef } from 'react';
import AdminLayout from '../../components/layout/AdminLayout';
import { Terminal, Wifi, WifiOff } from 'lucide-react';

const SystemLogs = () => {
  const [logs, setLogs] = useState<string[]>([]);
  const [isConnected, setIsConnected] = useState(false);
  const scrollRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    // 1. Open the Connection
    const ws = new WebSocket('ws://localhost:8000/api/ws/logs');

    ws.onopen = () => {
      setIsConnected(true);
      console.log('Connected to Log Stream');
    };

    ws.onmessage = (event) => {
      // 2. Receive Data (it comes as a JSON array of strings)
      const data = JSON.parse(event.data);
      setLogs(data);
    };

    ws.onclose = () => setIsConnected(false);

    // Cleanup when leaving the page
    return () => {
      ws.close();
    };
  }, []);

  // Auto-scroll to bottom when new logs arrive
  useEffect(() => {
    if (scrollRef.current) {
      scrollRef.current.scrollTop = scrollRef.current.scrollHeight;
    }
  }, [logs]);

  return (
    <AdminLayout>
      <div className="max-w-6xl mx-auto h-[calc(100vh-100px)] flex flex-col">
        <div className="flex justify-between items-center mb-4">
          <h2 className="text-2xl font-bold text-gray-800 flex items-center gap-3">
            <Terminal className="text-gray-600" />
            System Live Logs
          </h2>
          
          <div className={`flex items-center gap-2 px-3 py-1 rounded-full text-sm font-medium ${isConnected ? 'bg-green-100 text-green-700' : 'bg-red-100 text-red-700'}`}>
            {isConnected ? <Wifi size={16} /> : <WifiOff size={16} />}
            {isConnected ? 'Live Stream Active' : 'Disconnected'}
          </div>
        </div>

        <div className="flex-1 bg-black rounded-lg shadow-2xl p-4 overflow-hidden border border-gray-700 flex flex-col font-mono text-sm">
          {/* Terminal Header */}
          <div className="flex gap-2 mb-4 border-b border-gray-800 pb-2">
            <div className="w-3 h-3 rounded-full bg-red-500"></div>
            <div className="w-3 h-3 rounded-full bg-yellow-500"></div>
            <div className="w-3 h-3 rounded-full bg-green-500"></div>
          </div>

          {/* Logs Output */}
          <div ref={scrollRef} className="flex-1 overflow-y-auto space-y-1 pr-2 custom-scrollbar">
            {logs.length === 0 ? (
              <span className="text-gray-500 italic">Waiting for logs...</span>
            ) : (
              logs.map((log, index) => (
                <div key={index} className="text-green-400 break-words hover:bg-gray-900 transition-colors p-0.5 rounded">
                  <span className="text-gray-600 mr-2">$</span>
                  {log}
                </div>
              ))
            )}
          </div>
        </div>
      </div>
    </AdminLayout>
  );
};

export default SystemLogs;

==================================================
FILE: frontend/src\pages\auth\Login.tsx
==================================================

import { useState } from 'react';
import { useAuth } from '../../hooks/useAuth';
import { loginUser } from '../../services/authService';
import { useNavigate } from 'react-router-dom';

const Login = () => {
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');
  
  // Get the login function from our global context
  const { login } = useAuth();
  
  // Hook to redirect the user after login
  const navigate = useNavigate();

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault(); // Stop page refresh
    setError('');

    try {
      // 1. Call Python API
      const data = await loginUser(username, password);
      
      // 2. Save token to Context/LocalStorage
      await login(data.access_token);
      
      // 3. Redirect to Dashboard
      navigate('/dashboard');
    } catch (err) {
      setError('Invalid username or password');
    }
  };

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-100">
      <div className="bg-white p-8 rounded-lg shadow-md w-96">
        <h2 className="text-2xl font-bold mb-6 text-center text-blue-600">Dart Manager</h2>
        
        {error && (
          <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-2 rounded mb-4">
            {error}
          </div>
        )}

        <form onSubmit={handleSubmit}>
          <div className="mb-4">
            <label className="block text-gray-700 text-sm font-bold mb-2">
              Username
            </label>
            <input
              type="text"
              className="w-full px-3 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
              value={username}
              onChange={(e) => setUsername(e.target.value)}
              required
            />
          </div>
          
          <div className="mb-6">
            <label className="block text-gray-700 text-sm font-bold mb-2">
              Password
            </label>
            <input
              type="password"
              className="w-full px-3 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              required
            />
          </div>
          
          <button
            type="submit"
            className="w-full bg-blue-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-700 transition duration-200"
          >
            Sign In
          </button>
        </form>
      </div>
    </div>
  );
};

export default Login;

==================================================
FILE: frontend/src\pages\auth\Register.tsx
==================================================

import { useState } from 'react';
import { Link, useNavigate } from 'react-router-dom';
import { registerUser } from '../../services/authService';

const Register = () => {
  const navigate = useNavigate();
  const [error, setError] = useState('');
  
  const [formData, setFormData] = useState({
    first_name: '',
    last_name: '',
    email: '',
    password: ''
  });

  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setFormData({ ...formData, [e.target.name]: e.target.value });
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError('');

    try {
      await registerUser(formData);
      // Success! Redirect to login
      alert("Registration successful! You can now sign in.");
      navigate('/login');
    } catch (err: any) {
      // If the backend says "Email already registered", show that here
      if (err.response && err.response.data && err.response.data.detail) {
        setError(err.response.data.detail);
      } else {
        setError('Registration failed. Please try again.');
      }
    }
  };

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-100">
      <div className="bg-white p-8 rounded-lg shadow-md w-96">
        <h2 className="text-2xl font-bold mb-6 text-center text-blue-600">Create Account</h2>
        
        {error && (
          <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-2 rounded mb-4 text-sm">
            {error}
          </div>
        )}

        <form onSubmit={handleSubmit} className="space-y-4">
          
          <div className="grid grid-cols-2 gap-2">
            <div>
              <label className="block text-gray-700 text-xs font-bold mb-1">First Name</label>
              <input
                name="first_name"
                type="text"
                required
                className="w-full px-3 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                onChange={handleChange}
                placeholder="Michael"
              />
            </div>
            <div>
              <label className="block text-gray-700 text-xs font-bold mb-1">Last Name</label>
              <input
                name="last_name"
                type="text"
                required
                className="w-full px-3 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                onChange={handleChange}
                placeholder="Smith"
              />
            </div>
          </div>

          <div>
            <label className="block text-gray-700 text-xs font-bold mb-1">Email</label>
            <input
              name="email"
              type="email"
              required
              className="w-full px-3 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
              onChange={handleChange}
              placeholder="name@example.com"
            />
          </div>
          
          <div>
            <label className="block text-gray-700 text-xs font-bold mb-1">Password</label>
            <input
              name="password"
              type="password"
              required
              className="w-full px-3 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
              onChange={handleChange}
              placeholder="••••••••"
            />
          </div>
          
          <button
            type="submit"
            className="w-full bg-green-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-green-700 transition duration-200 mt-4"
          >
            Sign Up
          </button>
        </form>

        <div className="mt-4 text-center text-sm">
          <span className="text-gray-600">Already have an account? </span>
          <Link to="/login" className="text-blue-600 hover:underline">
            Login here
          </Link>
        </div>
      </div>
    </div>
  );
};

export default Register;

==================================================
FILE: frontend/src\pages\public\Standings.tsx
==================================================



==================================================
FILE: frontend/src\pages\public\TournamentView.tsx
==================================================

import { useEffect, useState, useMemo } from 'react';
import { useParams, Link } from 'react-router-dom';
import api from '../../services/api';
import { Trophy, Tablet, LayoutGrid, GitMerge, AlertCircle, Medal, RefreshCw } from 'lucide-react';
import { useAuth } from '../../hooks/useAuth';

// --- Types ---
interface Match {
  id: number;
  round_number: number;
  poule_number: number | null;
  player1_name: string;
  player2_name: string;
  score_p1: number;
  score_p2: number;
  is_completed: boolean;
  best_of_legs?: number;
}

interface Tournament {
  id: number;
  name: string;
  status: string;
  format: string;
  scorer_uuid: string;
  qualifiers_per_poule?: number; 
  starting_legs_group?: number;
  starting_legs_ko?: number;
  matches: Match[];
}

// --- Helper Components ---

// 1. De "Bracket" Weergave (Met verticale lijnen fix) [cite: 364]
const BracketView = ({ matches }: { matches: Match[] }) => {
    // Groepeer wedstrijden per ronde
    const rounds = useMemo(() => {
        const groups: Record<number, Match[]> = {};
        matches.forEach(m => {
            if (!groups[m.round_number]) groups[m.round_number] = [];
            groups[m.round_number].push(m);
        });
        return groups;
    }, [matches]);

    const roundNumbers = Object.keys(rounds).map(Number).sort((a, b) => a - b);
    
    // Helper voor ronde namen
    const getRoundName = (matchCount: number, roundIndex: number) => {
        if (matchCount === 1) return "FINALE";
        if (matchCount === 2) return "HALVE FINALE";
        if (matchCount === 4) return "KWARTFINALE";
        if (matchCount === 8) return "LAATSTE 16";
        return `RONDE ${roundIndex + 1}`;
    };

    if (matches.length === 0) {
        return (
            <div className="bg-white p-12 rounded-lg border border-dashed border-gray-300 text-center text-gray-500">
                <GitMerge className="mx-auto mb-2 opacity-20" size={40} />
                Nog geen knockout wedstrijden.
            </div>
        );
    }

    // Basis hoogte voor de eerste ronde (in pixels). Pas dit aan als je kaarten groter/kleiner zijn.
    const BASE_HEIGHT = 160; 

    return (
        <div className="overflow-x-auto pb-8 pt-4">
            <div className="flex px-4">
                {roundNumbers.map((roundNum, colIndex) => {
                    const currentRoundMatches = rounds[roundNum];
                    const roundName = getRoundName(currentRoundMatches.length, colIndex);
                    const isLastColumn = colIndex === roundNumbers.length - 1;

                    // De hoogte van de 'slot' verdubbelt elke ronde zodat alles uitlijnt
                    const slotHeight = BASE_HEIGHT * Math.pow(2, colIndex);

                    return (
                        <div key={roundNum} className="flex flex-col w-72">
                            {/* Ronde Titel */}
                            <div className="text-center font-bold text-gray-500 uppercase text-xs mb-6 tracking-wider border-b border-gray-200 pb-2 mx-4">
                                {roundName}
                            </div>
                            
                            {/* De kolom met wedstrijden (Gebruik justify-center ipv around) */}
                            <div className="flex flex-col justify-center flex-1">
                                {currentRoundMatches.map((match, matchIndex) => {
                                    // Bepaal of dit de bovenste of onderste van een setje is
                                    const isTop = matchIndex % 2 === 0;
                                    const isBottom = matchIndex % 2 !== 0;

                                    return (
                                        <div 
                                            key={match.id} 
                                            className="relative flex items-center justify-center"
                                            style={{ height: `${slotHeight}px` }} // Vaste berekende hoogte
                                        >
                                            
                                            {/* --- LINKS CONNECTOR (Inkomend) --- */}
                                            {colIndex > 0 && (
                                                <div className="absolute -left-6 w-6 h-0.5 bg-gray-300"></div>
                                            )}

                                            {/* --- RECHTS CONNECTOR (Uitgaand) --- */}
                                            {/* Alleen tekenen als het NIET de finale is */}
                                            {!isLastColumn && (
                                                <>
                                                    {/* Als het de BOVENSTE is: Lijn naar rechts en dan NAAR BENEDEN */}
                                                    {isTop && (
                                                        <div className="absolute -right-6 top-1/2 w-6 border-t-2 border-r-2 border-gray-300 rounded-tr-md" 
                                                             style={{ height: '50%' }}>
                                                        </div>
                                                    )}

                                                    {/* Als het de ONDERSTE is: Lijn naar rechts en dan NAAR BOVEN */}
                                                    {isBottom && (
                                                        <div className="absolute -right-6 top-0 w-6 border-b-2 border-r-2 border-gray-300 rounded-br-md" 
                                                             style={{ height: '50%' }}>
                                                        </div>
                                                    )}
                                                </>
                                            )}

                                            {/* --- MATCH CARD --- */}
                                            <div className={`w-full mx-2 bg-white border rounded-lg shadow-sm overflow-hidden text-sm relative z-10 
                                                ${match.is_completed ? 'border-gray-300' : 'border-blue-300 ring-1 ring-blue-100'}
                                            `}>
                                                {/* Header balkje */}
                                                <div className={`h-1.5 w-full ${match.is_completed ? 'bg-gray-400' : 'bg-blue-500'}`}></div>
                                                
                                                {/* Speler 1 */}
                                                <div className={`px-3 py-2 flex justify-between items-center border-b border-gray-100 ${match.score_p1 > match.score_p2 && match.is_completed ? 'bg-green-50/50 font-bold text-gray-900' : ''}`}>
                                                    <span className="truncate font-medium">{match.player1_name || 'TBD'}</span>
                                                    <span className="font-mono font-bold ml-2 bg-gray-50 px-2 py-0.5 rounded text-gray-700">
                                                        {match.is_completed ? match.score_p1 : '-'}
                                                    </span>
                                                </div>

                                                {/* Speler 2 */}
                                                <div className={`px-3 py-2 flex justify-between items-center ${match.score_p2 > match.score_p1 && match.is_completed ? 'bg-green-50/50 font-bold text-gray-900' : ''}`}>
                                                    <span className={`truncate font-medium ${!match.player2_name ? 'text-gray-400 italic' : ''}`}>
                                                        {match.player2_name ? match.player2_name : (match.is_completed ? 'BYE' : 'TBD')}
                                                    </span>
                                                    <span className="font-mono font-bold ml-2 bg-gray-50 px-2 py-0.5 rounded text-gray-700">
                                                        {match.is_completed ? match.score_p2 : '-'}
                                                    </span>
                                                </div>
                                            </div>

                                        </div>
                                    );
                                })}
                            </div>
                        </div>
                    );
                })}
            </div>
        </div>
    );
};

// 2. Helper voor Poule Standen
const calculateStandings = (matches: Match[]) => {
  const stats: Record<string, { p: number, w: number, l: number, pts: number, ld: number }> = {};
  
  matches.forEach(m => {
    if (m.player1_name && !stats[m.player1_name]) stats[m.player1_name] = { p:0, w:0, l:0, pts:0, ld:0 };
    if (m.player2_name && !stats[m.player2_name]) stats[m.player2_name] = { p:0, w:0, l:0, pts:0, ld:0 };

    if (m.is_completed && m.player1_name && m.player2_name) {
      const p1 = stats[m.player1_name];
      const p2 = stats[m.player2_name];

      p1.p++; p2.p++; 
      p1.ld += (m.score_p1 - m.score_p2); 
      p2.ld += (m.score_p2 - m.score_p1);

      if (m.score_p1 > m.score_p2) {
        p1.w++; p1.pts += 2; 
        p2.l++;
      } else {
        p2.w++; p2.pts += 2;
        p1.l++;
      }
    }
  });

  return Object.entries(stats)
    .map(([name, data]) => ({ name, ...data }))
    .sort((a, b) => b.pts - a.pts || b.ld - a.ld);
};

// --- HOOFD COMPONENT ---
const TournamentView = () => {
  const { public_uuid } = useParams();
  const { user } = useAuth();
  
  const [tournament, setTournament] = useState<Tournament | null>(null);
  const [loading, setLoading] = useState(true);
  const [activeTab, setActiveTab] = useState<number | 'ko'>(1);

  // --- Data Laden ---
  const loadData = async () => {
    try {
      const res = await api.get(`/tournaments/public/${public_uuid}`);
      setTournament(res.data);
    } catch (err) {
      console.error("Error loading tournament", err);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    loadData();
    const interval = setInterval(loadData, 10000); // Auto refresh elke 10s
    return () => clearInterval(interval);
  }, [public_uuid]);

  // --- Logica ---
  const handleStartKnockout = async () => {
    if (!tournament) return;
    if (!confirm("Weet je zeker dat je de Knockout fase wilt starten?")) return;
    try {
        await api.post(`/tournaments/${tournament.id}/start-knockout`);
        alert("Knockout fase gegenereerd!");
        window.location.reload(); 
    } catch (err) {
        alert("Kon knockout niet starten.");
    }
  };

  const availablePoules = useMemo(() => {
    if (!tournament) return [];
    const poules = new Set<number>();
    tournament.matches.forEach(m => {
        if (m.poule_number) poules.add(m.poule_number);
    });
    return Array.from(poules).sort((a, b) => a - b);
  }, [tournament]);

  const hasKnockout = useMemo(() => {
    return tournament?.matches.some(m => m.poule_number === null) || false;
  }, [tournament]);

  useEffect(() => {
    if (tournament && !loading) {
        if (availablePoules.length === 0 && hasKnockout) setActiveTab('ko');
    }
  }, [loading, availablePoules, hasKnockout]);

  const filteredMatches = useMemo(() => {
    if (!tournament) return [];
    if (activeTab === 'ko') return tournament.matches.filter(m => m.poule_number === null);
    return tournament.matches.filter(m => m.poule_number === activeTab);
  }, [tournament, activeTab]);

  const standings = useMemo(() => {
    if (activeTab === 'ko') return [];
    return calculateStandings(filteredMatches);
  }, [filteredMatches, activeTab]);

  const showKnockoutButton = user && tournament?.format === 'hybrid' && !hasKnockout;

  if (loading) return <div className="p-10 text-center text-gray-500">Laden...</div>;
  if (!tournament) return <div className="p-10 text-center text-red-500">Toernooi niet gevonden</div>;

  return (
    <div className="min-h-screen bg-gray-50 pb-20">
      
      {/* Header */}
      <header className="bg-slate-900 text-white p-6 shadow-md">
        <div className="max-w-6xl mx-auto flex flex-col md:flex-row justify-between items-center gap-4">
            <div>
               <h1 className="text-3xl font-bold flex items-center gap-3">
                 <Trophy className="text-yellow-400" />
                {tournament.name}
              </h1>
              <div className="flex items-center gap-3 mt-2">
                <span className="bg-slate-700 px-3 py-0.5 rounded-full text-xs uppercase tracking-wider text-slate-300">
                    {tournament.format === 'hybrid' ? 'Hybride' : tournament.format}
                </span>
                <span className={`text-xs px-2 py-0.5 rounded-full uppercase font-bold ${tournament.status === 'active' ? 'bg-green-500 text-white' : 'bg-gray-500'}`}>
                    {tournament.status}
                </span>
              </div>
            </div>

            <div className="flex items-center gap-3">
                {/* Refresh knop */}
                <button onClick={loadData} className="bg-slate-800 p-2 rounded hover:bg-slate-700 text-slate-300" title="Verversen">
                    <RefreshCw size={20} />
                </button>

                {showKnockoutButton && (
                    <button 
                        onClick={handleStartKnockout}
                        className="bg-orange-600 hover:bg-orange-500 text-white font-bold py-2 px-4 rounded-lg flex items-center gap-2 transition shadow-lg border border-orange-500 animate-pulse"
                    >
                        <GitMerge size={20} />
                        Start Knockout
                    </button>
                )}
                {user && (
                  <Link 
                    to={`/board/${tournament.scorer_uuid}`} 
                    target="_blank"
                    className="bg-blue-600 hover:bg-blue-500 text-white font-bold py-2 px-6 rounded-lg flex items-center gap-2 transition shadow-lg border border-blue-500"
                  >
                    <Tablet size={20} />
                    Open Scorer
                  </Link>
                )}
            </div>
        </div>
      </header>

      <div className="max-w-6xl mx-auto mt-8 px-4">
        
        {/* TABS */}
        <div className="flex border-b border-gray-200 mb-6 overflow-x-auto">
            {availablePoules.map(num => (
                <button
                    key={num}
                    onClick={() => setActiveTab(num)}
                    className={`flex items-center gap-2 px-6 py-3 font-medium transition-colors whitespace-nowrap ${
                        activeTab === num 
                        ? 'border-b-2 border-blue-600 text-blue-600 bg-white' 
                        : 'text-gray-500 hover:text-gray-700 hover:bg-gray-100'
                    }`}
                >
                    <LayoutGrid size={16} />
                    Poule {num}
                </button>
            ))}
            
            {hasKnockout && (
                <button
                    onClick={() => setActiveTab('ko')}
                    className={`flex items-center gap-2 px-6 py-3 font-medium transition-colors whitespace-nowrap ${
                        activeTab === 'ko'
                        ? 'border-b-2 border-orange-500 text-orange-600 bg-white' 
                        : 'text-gray-500 hover:text-gray-700 hover:bg-gray-100'
                    }`}
                >
                    <GitMerge size={16} />
                    Knockout Bracket
                </button>
            )}
        </div>

        {/* CONTENT */}
        {activeTab !== 'ko' ? (
            // --- POULE VIEW (Tabel + Lijst) ---
            <div className="grid gap-8 lg:grid-cols-3">
                {/* Kolom 1: Stand */}
                <div className="lg:col-span-2">
                    <div className="bg-white rounded-lg shadow-sm overflow-hidden border border-gray-200 mb-6">
                        <div className="bg-gray-50 p-3 border-b border-gray-200">
                            <h3 className="font-bold text-gray-700 flex items-center gap-2">
                                <LayoutGrid size={18} className="text-gray-400"/> Stand
                            </h3>
                        </div>
                        <div className="overflow-x-auto">
                            <table className="w-full text-left text-sm">
                                <thead className="bg-gray-50 border-b border-gray-100">
                                    <tr>
                                        <th className="p-3 text-gray-500 w-10">#</th>
                                        <th className="p-3 text-gray-500">Speler</th>
                                        <th className="p-3 text-center text-gray-500">W</th>
                                        <th className="p-3 text-center text-gray-500">L</th>
                                        <th className="p-3 text-center text-gray-500">+/-</th>
                                        <th className="p-3 text-center text-gray-800 font-bold">PT</th>
                                    </tr>
                                </thead>
                                <tbody className="divide-y divide-gray-50">
                                    {standings.map((row, index) => (
                                        <tr key={row.name} className={`hover:bg-blue-50 transition-colors ${index < (tournament.qualifiers_per_poule || 2) ? 'bg-green-50/40' : ''}`}>
                                            <td className="p-3 text-gray-400 font-mono">{index + 1}</td>
                                            <td className="p-3 font-medium text-gray-900 flex items-center gap-2">
                                                {row.name}
                                                {index < (tournament.qualifiers_per_poule || 2) && <Medal size={12} className="text-green-600" />}
                                            </td>
                                            <td className="p-3 text-center text-green-600 font-medium">{row.w}</td>
                                            <td className="p-3 text-center text-red-400">{row.l}</td>
                                            <td className="p-3 text-center text-gray-500">{row.ld > 0 ? `+${row.ld}` : row.ld}</td>
                                            <td className="p-3 text-center font-bold text-blue-700">{row.pts}</td>
                                        </tr>
                                    ))}
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>

                {/* Kolom 2: Wedstrijden Lijst */}
                <div>
                      <div className="bg-white rounded-lg shadow-sm border border-gray-200">
                        <div className="bg-gray-50 p-3 border-b border-gray-200">
                            <h3 className="font-bold text-gray-700">Wedstrijden</h3>
                        </div>
                        <div className="divide-y divide-gray-100 max-h-[500px] overflow-y-auto">
                            {filteredMatches.map((match) => (
                                <div key={match.id} className="p-3 hover:bg-gray-50 text-sm">
                                    <div className="flex justify-between text-xs text-gray-400 mb-1">
                                        <span>Ronde {match.round_number}</span>
                                        {match.is_completed && <span className="text-green-600 font-bold">Afgerond</span>}
                                    </div>
                                    <div className="flex items-center justify-between">
                                        <span className={`truncate w-1/3 ${match.score_p1 > match.score_p2 && match.is_completed ? 'font-bold text-gray-900' : 'text-gray-600'}`}>{match.player1_name || 'Bye'}</span>
                                        <span className="bg-gray-100 px-2 py-0.5 rounded font-mono font-bold text-gray-700 text-xs">
                                            {match.is_completed ? `${match.score_p1} - ${match.score_p2}` : 'vs'}
                                        </span>
                                        <span className={`truncate w-1/3 text-right ${match.score_p2 > match.score_p1 && match.is_completed ? 'font-bold text-gray-900' : 'text-gray-600'}`}>{match.player2_name || 'Bye'}</span>
                                    </div>
                                </div>
                            ))}
                        </div>
                      </div>
                </div>
            </div>
        ) : (
            // --- KNOCKOUT VIEW (BRACKET) ---
            <div className="bg-gray-100/50 p-6 rounded-xl border border-gray-200 overflow-x-auto min-h-[400px]">
                <BracketView matches={filteredMatches} />
            </div>
        )}

      </div>
    </div>
  );
};

export default TournamentView;

==================================================
FILE: frontend/src\pages\scorer\MatchList.tsx
==================================================

import { useEffect, useState } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import api from '../../services/api';
import { PlayCircle, CheckCircle } from 'lucide-react';

interface Match {
  id: number;
  round_number: number;
  player1_name: string;
  player2_name: string;
  is_completed: boolean;
}

const ScorerMatchList = () => {
  const { scorer_uuid } = useParams();
  const navigate = useNavigate();
  const [matches, setMatches] = useState<Match[]>([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    // We reuse the public endpoint logic but fetch via the Scorer UUID
    // The backend logic we wrote handles looking up by Scorer UUID too
    const loadMatches = async () => {
      try {
        const res = await api.get(`/matches/by-tournament/${scorer_uuid}`);
        setMatches(res.data);
      } catch (err) {
        alert("Invalid Scorer Link");
      } finally {
        setLoading(false);
      }
    };
    loadMatches();
  }, [scorer_uuid]);

  if (loading) return <div className="p-8 text-center">Loading Matches...</div>;

  return (
    <div className="min-h-screen bg-slate-900 text-white p-4">
      <h1 className="text-2xl font-bold mb-6 text-center text-blue-400">Select Match to Score</h1>
      
      <div className="space-y-3 max-w-lg mx-auto">
        {matches.map((match) => (
          <div 
            key={match.id}
            onClick={() => navigate(`/board/${scorer_uuid}/match/${match.id}`)}
            className={`p-4 rounded-xl border border-slate-700 flex justify-between items-center cursor-pointer transition-transform active:scale-95 ${
              match.is_completed ? 'bg-slate-800 opacity-60' : 'bg-slate-800 hover:bg-slate-700 shadow-lg'
            }`}
          >
            <div className="flex-1 text-center">
              <div className="font-bold text-lg">{match.player1_name || 'Bye'}</div>
              <div className="text-xs text-slate-400">VS</div>
              <div className="font-bold text-lg">{match.player2_name || 'Bye'}</div>
            </div>
            
            <div className="ml-4">
              {match.is_completed ? (
                <CheckCircle className="text-green-500" size={32} />
              ) : (
                <PlayCircle className="text-blue-400" size={32} />
              )}
            </div>
          </div>
        ))}
      </div>
    </div>
  );
};

export default ScorerMatchList;

==================================================
FILE: frontend/src\pages\scorer\Scoreboard.tsx
==================================================

import { useEffect, useState } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import api from '../../services/api';
import { ArrowLeft, Save } from 'lucide-react';

const Scoreboard = () => {
  const { scorer_uuid, match_id } = useParams();
  const navigate = useNavigate();

  // Game State
  // Simplified for MVP: Just tracking legs won (Best of X)
  // In a full app, you'd track 501 countdown here.
  const [scoreP1, setScoreP1] = useState(0);
  const [scoreP2, setScoreP2] = useState(0);
  const [isCompleted, setIsCompleted] = useState(false);
  const [playerNames, setPlayerNames] = useState({ p1: 'Player 1', p2: 'Player 2' });

  // Load Match Data
  useEffect(() => {
    // We fetch the match list again to find OUR match names
    // (A dedicated single-match endpoint would be better for prod, but this works)
    api.get(`/matches/by-tournament/${scorer_uuid}`).then(res => {
      const match = res.data.find((m: any) => m.id === Number(match_id));
      if (match) {
        setPlayerNames({ p1: match.player1_name, p2: match.player2_name });
        setScoreP1(match.score_p1);
        setScoreP2(match.score_p2);
        setIsCompleted(match.is_completed);
      }
    });
  }, [scorer_uuid, match_id]);

  const updateScore = async (p1: number, p2: number, completed: boolean) => {
    setScoreP1(p1);
    setScoreP2(p2);
    setIsCompleted(completed);

    try {
      await api.put(
        `/matches/${match_id}/score`, 
        {
          score_p1: p1,
          score_p2: p2,
          is_completed: completed
        },
        {
          headers: { 'X-Scorer-Token': scorer_uuid } // Auth Magic!
        }
      );
    } catch (err) {
      console.error("Failed to sync score");
    }
  };

  return (
    <div className="min-h-screen bg-black text-white flex flex-col">
      {/* Header */}
      <div className="p-4 bg-slate-900 flex items-center justify-between">
        <button onClick={() => navigate(-1)} className="text-slate-400">
          <ArrowLeft />
        </button>
        <span className="font-mono text-yellow-400 font-bold">MATCH {match_id}</span>
        <div className="w-6" /> {/* Spacer */}
      </div>

      {/* Score Display */}
      <div className="flex-1 flex flex-col justify-center items-center gap-8 p-4">
        
        {/* Player 1 */}
        <div className="w-full bg-slate-800 rounded-2xl p-6 flex justify-between items-center border border-slate-700">
          <span className="text-xl font-bold text-blue-300 truncate w-32">{playerNames.p1}</span>
          <div className="flex items-center gap-4">
             <button 
                onClick={() => updateScore(Math.max(0, scoreP1 - 1), scoreP2, false)}
                className="w-12 h-12 rounded-full bg-slate-700 text-2xl font-bold text-white hover:bg-slate-600"
             >-</button>
             <span className="text-6xl font-mono font-bold w-24 text-center">{scoreP1}</span>
             <button 
                onClick={() => updateScore(scoreP1 + 1, scoreP2, false)}
                className="w-12 h-12 rounded-full bg-blue-600 text-2xl font-bold text-white hover:bg-blue-500"
             >+</button>
          </div>
        </div>

        {/* VS Divider */}
        <div className="text-slate-500 font-bold">LEGS WON</div>

        {/* Player 2 */}
        <div className="w-full bg-slate-800 rounded-2xl p-6 flex justify-between items-center border border-slate-700">
          <span className="text-xl font-bold text-blue-300 truncate w-32">{playerNames.p2}</span>
          <div className="flex items-center gap-4">
             <button 
                onClick={() => updateScore(scoreP1, Math.max(0, scoreP2 - 1), false)}
                className="w-12 h-12 rounded-full bg-slate-700 text-2xl font-bold text-white hover:bg-slate-600"
             >-</button>
             <span className="text-6xl font-mono font-bold w-24 text-center">{scoreP2}</span>
             <button 
                onClick={() => updateScore(scoreP1, scoreP2 + 1, false)}
                className="w-12 h-12 rounded-full bg-blue-600 text-2xl font-bold text-white hover:bg-blue-500"
             >+</button>
          </div>
        </div>
      </div>

      {/* Footer Controls */}
      <div className="p-6 bg-slate-900 border-t border-slate-800">
        <button 
          onClick={() => {
            updateScore(scoreP1, scoreP2, !isCompleted);
            if (!isCompleted) navigate(-1); // Go back if finishing
          }}
          className={`w-full py-4 rounded-xl text-xl font-bold flex items-center justify-center gap-3 transition-colors ${
            isCompleted 
              ? 'bg-slate-700 text-slate-300' 
              : 'bg-green-600 text-white hover:bg-green-500'
          }`}
        >
          <Save size={24} />
          {isCompleted ? 'Mark as In Progress' : 'Finish Match'}
        </button>
      </div>
    </div>
  );
};

export default Scoreboard;

==================================================
FILE: frontend/src\services\api.ts
==================================================

import axios from 'axios';

// 1. Create the instance (like requests.Session())
// const api = axios.create({
//   baseURL: 'http://localhost:8000/api', // Point to your FastAPI backend
//   headers: {
//     'Content-Type': 'application/json',
//   },
// });


const api = axios.create({
  // Verwijder de hardcoded localhost URL. 
  // Omdat Nginx op hetzelfde domein draait, gebruiken we een relatieve URL.
  // Als je app draait op http://mijn-server-ip/, wordt dit automatisch http://mijn-server-ip/api
  baseURL: '/api', 
  headers: {
    'Content-Type': 'application/json',
  },
});

// 2. Add an "Interceptor" (Middleware)
// Before every request is sent, check if we have a token in LocalStorage (browser memory)
api.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem('token');
    if (token) {
      // If token exists, attach it: Authorization: Bearer <token>
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

export default api;

==================================================
FILE: frontend/src\services\authService.ts
==================================================

import api from './api';

// The data shape expected by FastAPI's OAuth2PasswordRequestForm
// It expects form-data, not JSON!
export const loginUser = async (username: string, password: string) => {
  const formData = new FormData();
  formData.append('username', username);
  formData.append('password', password);

  const response = await api.post('/auth/login', formData, {
    headers: {
      'Content-Type': 'application/x-www-form-urlencoded',
    },
  });
  return response.data; // Returns { access_token: "...", token_type: "bearer" }
};

export const registerUser = async (userData: any) => {
    const response = await api.post('/auth/register', userData);
    return response.data;
};

==================================================
FILE: frontend/src\types\index.ts
==================================================

export interface User {
  id: number;
  email: string;
  first_name: string;
  last_name: string;
}

export interface Player {
  id: number;
  first_name: string;
  last_name?: string;
  nickname?: string;
  email?: string;
  name: string;
}

export interface Dartboard {
  id: number;
  name: string;
  number: number;
}

export interface Tournament {
  id: number;
  name: string;
  date: string;
  status: string; // 'draft', 'active', 'completed'
  format: string;
  public_uuid?: string;
  
  // Nieuwe velden die het dashboard nodig heeft:
  number_of_poules?: number;
  player_count?: number;
  board_count?: number;
  allow_byes?: boolean; // <--- Nieuw toegevoegd
}

// We voegen Match en Leg later toe
export interface Match {
    id: number;
    // ... later invullen
}
