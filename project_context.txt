
# PROJECT OVERVIEW: DART TOERNOOI MANAGER
================================================================================
1. Projectoverzicht
De Dart Toernooi Manager is een full-stack webapplicatie ontworpen voor het stroomlijnen van darttoernooien. 
Doelgroep: Lokale kroegen, dartverenigingen en regionale bonden.
Spelvormen: Singles (1v1) en Doubles (2v2).
Toernooi-modellen: Round Robin, Single/Double Elimination en Hybride.

2. Technische Stack
Backend: Python 3.12 met FastAPI.
Database: SQLModel (SQLAlchemy + Pydantic) met SQLite/PostgreSQL.
Frontend: React (TypeScript) met Tailwind CSS en Lucide Icons.
Real-time: WebSockets voor score-updates.
Deployment: Docker & Docker Compose.

3. Architectuur & Datamodel
Modellen: user, tournament, player, team, match, dartboard.

4. Kernfunctionaliteiten
- Wizard-configuratie & Auto-Generation van schema's.
- Slimme Arbitrage: Automatische toewijzing van schrijvers.
- Narrowcasting (TV Mode): Live carrousel voor toeschouwers.

5. Business Logic
- Match-validatie via state-machine (Best of X).
- Smart Scheduling Logic: Gebalanceerde verdeling van speel- en schrijfrondes om "clumping" (opeenvolgende taken) en lange wachttijden te minimaliseren, gebaseerd op een rustfactor-algoritme.
- Ranking-logica op basis van Punten (2 per winst) -> Leg-Difference (+/- Saldo) -> Head-to-Head (onderling resultaat) -> 9-dart-Shoot-out (indien 3 spelers gelijk staan). Dit is volgens Order of Merrit Rules

5b. Knock-out Transitie & Seeding
- Automatische Kwalificatie: Dynamische doorstroming van de top X spelers per poule naar een Single of Double Elimination bracket (2, 4, 8, 16, etc.).
- Bye-Management: Als de setting Byes bij het maken van het tournooi wordt gekozen. Zal bij een onregelmatig aantal gekwalificeerden worden "Byes" (vrijlotingen) prioritair toegewezen aan de hoogst geplaatste spelers (bijv. poulewinnaars) om de bracket te balanceren.
- Cross-Poule Matching: Om sportieve variatie te maximaliseren, worden spelers uit verschillende poules tegen elkaar gekoppeld (bijv. Winnaar Poule A vs. laagst geplaatste van Poule B).
- Bracket Protection (Seeding): Implementatie van een beschermde indeling waarbij de nummers 1 en 2 uit dezelfde poule aan weerszijden van de bracket worden geplaatst. Dit garandeert dat zij elkaar pas in de finale weer kunnen treffen.

6. Interface
- Publieke Pagina's: Home, Live Match View, TV Mode.
- Admin Dashboard: JWT beveiligd, Player/Tournament management.
- Scorer Interface: Geoptimaliseerd voor tablets met numeriek keypad.

7. DevOps & Security
- OAuth2 met JWT.
- Live systeemlogs via WebSockets.
================================================================================


################################################################################
# SOURCE CODE START
################################################################################


==================================================
CONFIG FILE: package.json
==================================================

{
  "name": "dart-tournament-manager",
  "version": "1.5.0",
  "scripts": {
    "release": "standard-version && git push --follow-tags",
    "prepare": "husky"
  },
  "standard-version": {
    "bumpFiles": [
      {
        "filename": "package.json",
        "type": "json"
      },
      {
        "filename": "backend/app/__init__.py",
        "updater": "backend/scripts/python-version-updater.js"
      },
      {
        "filename": "frontend/package.json",
        "type": "json"
      }
    ]
  },
  "devDependencies": {
    "@commitlint/cli": "^19.0.0",
    "@commitlint/config-conventional": "^19.0.0",
    "husky": "^9.0.0",
    "standard-version": "^9.5.0"
  },
  "dependencies": {
    "stringify-package": "^1.0.1",
    "detect-indent": "^6.1.0",
    "detect-newline": "^3.1.0"
  }
}


==================================================
CONFIG FILE: docker-compose.yml
==================================================

version: '3.8'

services:
  backend:
    build:
      context: .
      dockerfile: backend/Dockerfile
    container_name: darts-backend
    restart: always
    # BELANGRIJK: 'volumes' moet 4 spaties ingesprongen zijn (onder backend)
    volumes:
      - ./data:/app/data
      - ./logs:/app/logs
    environment:
      - DATABASE_URL=sqlite:////app/data/darts.db
      - SECRET_KEY=your_secret_key_here

  frontend:
    build:
      context: .
      dockerfile: frontend/Dockerfile
    container_name: darts-frontend
    restart: always
    ports:
      - "80:80"
    depends_on:
      - backend

==================================================
CONFIG FILE: README.md
==================================================

# Darts






Start dev enviroment:
 CTRL SHIFT B

 
.venv/Scripts/Activate.ps1
cd backend
uvicorn app.main:app --reload

cd frontend
npm run dev





Log in op je Proxmox VM (bijv. Ubuntu/Debian) en installeer Docker:

```bash
# Update pakketten
sudo apt update && sudo apt upgrade -y

# Installeer Docker & Docker Compose
curl -fsSL [https://get.docker.com](https://get.docker.com) -o get-docker.sh
sudo sh get-docker.sh
sudo usermod -aG docker $USER
# Log uit en weer in om de groepsrechten toe te passen


# 1. Clone de code
git clone [https://github.com/luukderooij/Darts.git](https://github.com/luukderooij/Darts.git)
cd Darts

# 2. Maak mappen voor persistente data
mkdir -p data logs

# 3. Start de containers
docker compose up -d --build


# 1. Haal de laatste versie van GitHub
git pull

# 2. Bouw de containers opnieuw (belangrijk voor nieuwe code!) en herstart ze
docker compose up -d --build

# 3. (Optioneel) Ruim oude, ongebruikte images op om schijfruimte te besparen
docker image prune -f

==================================================
CONFIG FILE: .env.example
==================================================



==================================================
FILE: backend/app\main.py
==================================================

from contextlib import asynccontextmanager
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware

# Import core settings and database logic
from app.core.config import settings
from app.db.session import init_db

# Import API route modules
from app.api import auth, users, players, tournaments, matches, websockets, dartboards, teams, system

@asynccontextmanager
async def lifespan(app: FastAPI):
    """
    Lifespan context manager for handling startup and shutdown events.
    """
    # --- Startup ---
    print("Starting up Dart Tournament Manager...")
    init_db()
    
    yield
    
    # --- Shutdown ---
    print("Shutting down...")

app = FastAPI(
    title="Dart Tournament Manager API",
    description="Backend for managing dart tournaments, players, and real-time scores.",
    version="1.0.0",
    lifespan=lifespan
)

# --- CORS Configuration ---
origins = [
    "http://localhost:5173",
    "http://localhost:3000",
    "http://127.0.0.1:5173",
    "*" 
]

app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# --- Register Routers ---
app.include_router(auth.router, prefix="/api/auth", tags=["Authentication"])
app.include_router(users.router, prefix="/api/users", tags=["Users"])
app.include_router(players.router, prefix="/api/players", tags=["Players"])
app.include_router(tournaments.router, prefix="/api/tournaments", tags=["Tournaments"])
app.include_router(matches.router, prefix="/api/matches", tags=["Matches"])
app.include_router(dartboards.router, prefix="/api/dartboards", tags=["Dartboards"])
app.include_router(teams.router, prefix="/api/teams", tags=["Teams"])
app.include_router(system.router, prefix="/api/system", tags=["system"])

# WebSocket router for real-time logs
# Note: The frontend will connect via ws://localhost:8000/ws/logs
app.include_router(websockets.router, prefix="/ws", tags=["WebSockets"])
app.include_router(dartboards.router, prefix="/api/dartboards", tags=["Dartboards"])

# --- Root Endpoint (Health Check) ---
@app.get("/")
def read_root():
    return {
        "status": "online",
        "message": "Dart Tournament Manager API is running",
        "docs_url": "/docs" 
    }

==================================================
FILE: backend/app\__init__.py
==================================================

__version__ = "1.5.0"

==================================================
FILE: backend/app\api\auth.py
==================================================

from datetime import timedelta
from typing import Annotated
from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordRequestForm
from sqlmodel import Session, select

from app.db.session import get_session
from app.core.security import (
    create_access_token,
    get_password_hash,
    verify_password,
    ACCESS_TOKEN_EXPIRE_MINUTES
)
from app.models.user import User
from app.schemas.user import UserCreate, UserRead
from app.schemas.token import Token

router = APIRouter()

# --- Helper Function ---
def authenticate_user(session: Session, email: str, password: str):
    # We look up the user by EMAIL
    statement = select(User).where(User.email == email)
    user = session.exec(statement).first()
    if not user:
        return False
    if not verify_password(password, user.hashed_password):
        return False
    return user

# --- Endpoints ---

@router.post("/login", response_model=Token)
def login_for_access_token(
    form_data: Annotated[OAuth2PasswordRequestForm, Depends()],
    session: Session = Depends(get_session)
):
    # Note: OAuth2PasswordRequestForm always has a field named 'username'.
    # We are using that field to carry the 'email' address.
    user = authenticate_user(session, form_data.username, form_data.password)
    
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect email or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
        
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    
    # We store the EMAIL in the 'sub' (subject) of the token
    access_token = create_access_token(
        data={"sub": user.email}, 
        expires_delta=access_token_expires
    )
    
    return {"access_token": access_token, "token_type": "bearer"}

@router.post("/register", response_model=UserRead)
def register_user(user_in: UserCreate, session: Session = Depends(get_session)):
    # 1. Check if email already exists
    existing_user = session.exec(select(User).where(User.email == user_in.email)).first()
    if existing_user:
        raise HTTPException(
            status_code=400, 
            detail="Email already registered"
        )
    
    # 2. Create new user
    user = User(
        first_name=user_in.first_name,
        last_name=user_in.last_name,
        email=user_in.email,
        hashed_password=get_password_hash(user_in.password)
    )
    
    session.add(user)
    session.commit()
    session.refresh(user)
    
    return user

==================================================
FILE: backend/app\api\dartboards.py
==================================================

from typing import List
from fastapi import APIRouter, Depends, HTTPException
from sqlmodel import Session, select

from app.db.session import get_session
from app.models.dartboard import Dartboard
from app.schemas.dartboard import DartboardCreate, DartboardRead
from app.api.users import get_current_user # Auth check

router = APIRouter()

@router.post("/", response_model=DartboardRead)
def create_board(
    board_in: DartboardCreate,
    session: Session = Depends(get_session),
    current_user = Depends(get_current_user)
):
    board = Dartboard(name=board_in.name, number=board_in.number)
    session.add(board)
    session.commit()
    session.refresh(board)
    return board

@router.get("/", response_model=List[DartboardRead])
def read_boards(
    session: Session = Depends(get_session),
    current_user = Depends(get_current_user)
):
    # Sort by number automatically (1, 2, 3...)
    statement = select(Dartboard).order_by(Dartboard.number)
    boards = session.exec(statement).all()
    return boards

@router.delete("/{board_id}")
def delete_board(
    board_id: int,
    session: Session = Depends(get_session),
    current_user = Depends(get_current_user)
):
    board = session.get(Dartboard, board_id)
    if not board:
        raise HTTPException(status_code=404, detail="Board not found")
    session.delete(board)
    session.commit()
    return {"ok": True}

==================================================
FILE: backend/app\api\matches.py
==================================================

import logging
from typing import List, Optional
from fastapi import APIRouter, Depends, HTTPException, status, Header
from sqlmodel import Session, select
from sqlalchemy.orm import selectinload 

from app.db.session import get_session
from app.models.match import Match
from app.models.player import Player
from app.models.team import Team 
from app.models.tournament import Tournament
from app.models.user import User
from app.schemas.match import MatchRead, MatchScoreUpdate
from app.api.users import get_current_user
from app.services.tournament_gen import check_and_advance_knockout

logger = logging.getLogger("dart_app")

router = APIRouter()

# --- Helpers ---

def get_match_or_404(match_id: int, session: Session) -> Match:
    match = session.get(Match, match_id)
    if not match:
        raise HTTPException(status_code=404, detail="Match not found")
    return match

# --- Endpoints ---

@router.put("/{match_id}/score", response_model=MatchRead)
def update_match_score(
    match_id: int,
    match_in: MatchScoreUpdate,
    session: Session = Depends(get_session),
    current_user: User = Depends(get_current_user)
):
    match = session.get(Match, match_id)
    if not match:
        raise HTTPException(status_code=404, detail="Match not found")

    # --- VALIDATION LOGIC ---
    if match.best_of_legs:
        limit = match.best_of_legs
        # In 'Best of 3', you win if you reach 2. (3 // 2 + 1 = 2)
        winning_threshold = (limit // 2) + 1
        
        # 1. Validate Total Legs
        # Example: Best of 3. Max score is 2-1 (Total 3). 2-2 (Total 4) is impossible.
        if match_in.score_p1 + match_in.score_p2 > limit:
            raise HTTPException(
                status_code=400, 
                detail=f"Impossible score: Total legs ({match_in.score_p1 + match_in.score_p2}) cannot exceed Best of {limit}."
            )

        # 2. Validate Individual Score
        # Example: Best of 3. You cannot win 3-0. Max is 2.
        if match_in.score_p1 > winning_threshold or match_in.score_p2 > winning_threshold:
             raise HTTPException(
                status_code=400, 
                detail=f"Impossible score: A player cannot win more than {winning_threshold} legs in a Best of {limit} match."
            )

        # 3. Auto-Complete Logic
        # If someone reached the threshold, the match is over.
        if match_in.score_p1 == winning_threshold or match_in.score_p2 == winning_threshold:
            match.is_completed = True
        else:
            # If no one reached the threshold, it CANNOT be finished yet.
            match.is_completed = False

    # Apply updates
    match.score_p1 = match_in.score_p1
    match.score_p2 = match_in.score_p2
    # We use our calculated is_completed, ignoring the one sent by frontend if we did logic above
    # But if best_of_legs is not set (e.g. infinite practice), we trust the input
    if not match.best_of_legs:
        match.is_completed = match_in.is_completed

    session.add(match)
    session.commit()
    session.refresh(match)
    
    # ... (Rest of the function: Check for Next Round generation) ...
    # Make sure you keep the existing logic that checks for poule completion / knockout advancement here!
    
    # Logic to trigger next round if knockout match is finished...
    if match.is_completed and match.poule_number is None:
         # ... existing knockout logic ...
         pass

    return match

@router.get("/by-tournament/{public_uuid}", response_model=List[MatchRead])
def get_matches_public(
    public_uuid: str,
    session: Session = Depends(get_session)
):
    # 1. Resolve Tournament
    statement = select(Tournament).where(Tournament.public_uuid == public_uuid)
    tournament = session.exec(statement).first()
    
    if not tournament:
        statement_scorer = select(Tournament).where(Tournament.scorer_uuid == public_uuid)
        tournament = session.exec(statement_scorer).first()
        
    if not tournament:
        raise HTTPException(status_code=404, detail="Tournament not found")
        
    # 2. Get Matches (MET RELATIES VOOR TEAMS EN SPELERS)
    statement_matches = (
        select(Match)
        .where(Match.tournament_id == tournament.id)
        .options(
            selectinload(Match.player1),
            selectinload(Match.player2),
            selectinload(Match.team1), 
            selectinload(Match.team2),
            selectinload(Match.referee),
            selectinload(Match.referee_team)
        )
        .order_by(Match.id)
    )
    matches = session.exec(statement_matches).all()
    
    # 3. Construct Response met de juiste namen
    results = []
    for m in matches:
        m_data = m.model_dump()
        
        # --- LOGICA: KIES NAAM (SPELER > TEAM > BYE) ---
        
        # Naam 1
        if m.player1:
            m_data['player1_name'] = m.player1.name
        elif m.team1:
            m_data['player1_name'] = m.team1.name # Hier pakken we de Team naam!
        else:
             m_data['player1_name'] = "Bye"

        # Naam 2
        if m.player2:
             m_data['player2_name'] = m.player2.name
        elif m.team2:
             m_data['player2_name'] = m.team2.name # Hier pakken we de Team naam!
        else:
             m_data['player2_name'] = "Bye"

        # Referee Naam
        if m.referee:
            m_data['referee_name'] = m.referee.name
        elif m.referee_team:
            m_data['referee_name'] = m.referee_team.name
        else:
            m_data['referee_name'] = "-" # Or "TBD"
             
        results.append(m_data)
        
    return results

==================================================
FILE: backend/app\api\players.py
==================================================

from typing import List
from fastapi import APIRouter, Depends, HTTPException
from sqlmodel import Session, select

from app.db.session import get_session
from app.models.player import Player
from app.schemas.player import PlayerCreate, PlayerRead

# --- THE FIX IS HERE ---
# We import from 'users', not 'auth'
from app.api.users import get_current_user 
from app.models.user import User

router = APIRouter()

@router.post("/", response_model=PlayerRead)
def create_player(
    player_in: PlayerCreate,
    session: Session = Depends(get_session),
    current_user: User = Depends(get_current_user)
):
    player = Player(
        first_name=player_in.first_name,
        last_name=player_in.last_name,
        nickname=player_in.nickname,
        email=player_in.email,
        # user_id=current_user.id (Uncomment if you want to link players to the admin who created them)
    )
    
    session.add(player)
    session.commit()
    session.refresh(player)
    return player

@router.get("/", response_model=List[PlayerRead])
def read_players(
    skip: int = 0,
    limit: int = 100,
    session: Session = Depends(get_session),
    current_user: User = Depends(get_current_user)
):
    statement = select(Player).offset(skip).limit(limit)
    players = session.exec(statement).all()
    return players

@router.delete("/{player_id}")
def delete_player(
    player_id: int,
    session: Session = Depends(get_session),
    current_user: User = Depends(get_current_user)
):
    player = session.get(Player, player_id)
    if not player:
        raise HTTPException(status_code=404, detail="Player not found")
        
    session.delete(player)
    session.commit()
    return {"ok": True}

==================================================
FILE: backend/app\api\system.py
==================================================

import os
import re
from typing import List, Optional
from fastapi import APIRouter
from pydantic import BaseModel

router = APIRouter()

class ChangeItem(BaseModel):
    type: str      
    text: str
    hash: Optional[str] = None
    link: Optional[str] = None

class Release(BaseModel):
    version: str
    date: str
    description: Optional[str] = None
    changes: List[ChangeItem]

def parse_changelog_line(line: str) -> Optional[ChangeItem]:
    # Regex: * message ([hash](link))
    match_hash = re.search(r'^\*\s+(.*?)\s+\(\[(.*?)\]\((.*?)\)\)', line)
    
    text = ""
    commit_hash = None
    link = None

    if match_hash:
        text = match_hash.group(1)
        commit_hash = match_hash.group(2)
        link = match_hash.group(3)
    else:
        # Fallback: tekst zonder link
        match_simple = re.search(r'^\*\s+(.*)', line)
        if match_simple:
            text = match_simple.group(1)
        else:
            return None

    # Markdown cleanup (**bold**)
    text = re.sub(r'\*\*(.*?)\*\*', r'\1', text)
    
    return ChangeItem(type="unknown", text=text, hash=commit_hash, link=link)

def determine_type_from_header(header: str) -> str:
    h = header.lower()
    if "features" in h: return "feat"
    if "bug fixes" in h: return "fix"
    if "performance" in h: return "perf"
    if "reverts" in h: return "revert"
    return "chore"

@router.get("/changelog", response_model=List[Release])
def get_changelog():
    # --- PAD FIX: We gaan 3 mappen omhoog vanuit api/system.py ---
    # api -> app -> backend -> ROOT
    root_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), "..", "..", ".."))
    changelog_path = os.path.join(root_dir, "CHANGELOG.md")
    
    # DEBUG: Als bestand niet bestaat, geef dat terug in de UI
    if not os.path.exists(changelog_path):
        # Probeer backend map als fallback
        backend_path = os.path.join(os.path.dirname(__file__), "..", "..", "CHANGELOG.md")
        if os.path.exists(backend_path):
            changelog_path = backend_path
        else:
            return [Release(
                version="Error", 
                date="Nu", 
                description=f"Kan CHANGELOG.md niet vinden op: {changelog_path}", 
                changes=[]
            )]

    releases = []
    current_release = None
    current_type = "chore"

    with open(changelog_path, "r", encoding="utf-8") as f:
        lines = f.readlines()

    for line in lines:
        line = line.strip()
        if not line: continue

        # Versie detectie: ## [1.0.0] of ### [1.0.0]
        version_match = re.search(r'^#{2,3}\s+\[(.*?)\]\(.*?\)\s+\((.*?)\)', line)
        if not version_match:
             version_match = re.search(r'^#{2,3}\s+\[(.*?)\]\s+\((.*?)\)', line)
        if not version_match:
             version_match = re.search(r'^#{2,3}\s+(.*?)\s+\((.*?)\)', line)

        if version_match:
            if current_release:
                releases.append(current_release)
            
            current_release = Release(
                version=version_match.group(1),
                date=version_match.group(2),
                changes=[]
            )
            continue

        # Categorie detectie (Features, Bug Fixes)
        if line.startswith("###") and not version_match:
            if "[" not in line and "(" not in line: 
                current_type = determine_type_from_header(line)
            continue

        # Change Line detectie
        if line.startswith("*") and current_release:
            change = parse_changelog_line(line)
            if change:
                change.type = current_type
                current_release.changes.append(change)

    if current_release:
        releases.append(current_release)

    return releases

==================================================
FILE: backend/app\api\teams.py
==================================================

import random
from typing import List, Optional
from fastapi import APIRouter, Depends, HTTPException, Query
from sqlmodel import Session, select

from app.db.session import get_session
from app.models.team import Team
from app.models.player import Player
from app.models.tournament import Tournament
from app.models.links import TournamentTeamLink # <--- Vergeet deze import niet!
from app.schemas.team import TeamCreateManual, TeamAutoGenerate, TeamRead, TeamLinkInput
from app.api.users import get_current_user 
from sqlalchemy.orm import selectinload

router = APIRouter()

# --- HELPER: Automatische Naam Genereren ---
def generate_team_name(players: List[Player]) -> str:
    names = []
    for p in players:
        name_part = p.last_name if p.last_name else p.first_name
        if p.nickname:
             name_part = p.nickname
        names.append(name_part)
    return " & ".join(names)

# --- ENDPOINT 1: Alle Teams Ophalen (Global) ---
@router.get("/", response_model=List[TeamRead])
def read_all_teams(
    session: Session = Depends(get_session),
    current_user = Depends(get_current_user)
):
    """Haal alle teams op die in de database staan (voor de 'Manage Teams' pagina)."""
    teams = session.exec(select(Team)).all()
    return teams

# --- ENDPOINT 2: Teams van een specifiek toernooi ophalen ---
@router.get("/by-tournament/{tournament_id}", response_model=List[TeamRead])
def read_teams_by_tournament(
    tournament_id: int,
    session: Session = Depends(get_session),
    current_user = Depends(get_current_user)
):
    """Haal alleen de teams op die gelinkt zijn aan dit toernooi."""
    # We joinen Team met de koppeltabel
    statement = (
        select(Team)
        .join(TournamentTeamLink)
        .where(TournamentTeamLink.tournament_id == tournament_id)
    )
    teams = session.exec(statement).all()
    return teams

# --- ENDPOINT 3: Handmatig Team Aanmaken (En optioneel linken) ---
@router.post("/manual", response_model=TeamRead)
def create_manual_team(
    team_in: TeamCreateManual,
    session: Session = Depends(get_session),
    current_user = Depends(get_current_user)
):
    # 1. Haal spelers op
    players = session.exec(select(Player).where(Player.id.in_(team_in.player_ids))).all()
    if len(players) != len(team_in.player_ids):
        raise HTTPException(status_code=400, detail="Eén of meer speler IDs bestaan niet.")
    
    if len(players) < 2:
        raise HTTPException(status_code=400, detail="Een team moet minimaal 2 spelers hebben.")

    # --- NIEUW: DUPLICATE CHECK ---
    # Haal alle teams op inclusief hun spelers
    existing_teams = session.exec(select(Team).options(selectinload(Team.players))).all()
    
    # Maak een 'set' van de nieuwe IDs (volgorde maakt niet uit: {1, 2} is hetzelfde als {2, 1})
    new_team_ids = set(p.id for p in players)

    for team in existing_teams:
        existing_team_ids = set(p.id for p in team.players)
        
        if existing_team_ids == new_team_ids:
            # We hebben een match!
            raise HTTPException(
                status_code=400, 
                detail=f"Dit team bestaat al onder de naam '{team.name}'."
            )
    # ------------------------------

    # 2. Bepaal de naam
    final_name = team_in.name
    if not final_name or final_name.strip() == "":
        final_name = generate_team_name(players)

    # 3. Maak het Team object (ZONDER tournament_id)
    team = Team(name=final_name)
    team.players = players
    session.add(team)
    session.commit()
    session.refresh(team)

    # 4. Linken als tournament_id is meegegeven
    if team_in.tournament_id:
        tournament = session.get(Tournament, team_in.tournament_id)
        if not tournament:
            raise HTTPException(status_code=404, detail="Toernooi niet gevonden")
            
        link = TournamentTeamLink(tournament_id=tournament.id, team_id=team.id)
        session.add(link)
        session.commit()
    
    return team

# --- ENDPOINT 4: Bestaande Teams Linken aan Toernooi ---
@router.post("/link", response_model=dict)
def link_teams(
    link_in: TeamLinkInput,
    session: Session = Depends(get_session),
    current_user = Depends(get_current_user)
):
    tournament = session.get(Tournament, link_in.tournament_id)
    if not tournament:
        raise HTTPException(status_code=404, detail="Toernooi niet gevonden")

    count = 0
    for team_id in link_in.team_ids:
        # Check of link al bestaat om dubbelen te voorkomen
        existing = session.get(TournamentTeamLink, (link_in.tournament_id, team_id))
        if not existing:
            link = TournamentTeamLink(tournament_id=link_in.tournament_id, team_id=team_id)
            session.add(link)
            count += 1
    
    session.commit()
    return {"message": f"{count} teams succesvol gekoppeld."}

# --- ENDPOINT 5: Automatisch Random Teams (Blijft grotendeels gelijk, maar met links) ---
@router.post("/auto", response_model=List[TeamRead])
def create_auto_teams(
    auto_in: TeamAutoGenerate,
    session: Session = Depends(get_session),
    current_user = Depends(get_current_user)
):
    # 1. Haal spelers op
    players = session.exec(select(Player).where(Player.id.in_(auto_in.player_ids))).all()
    if len(players) % 2 != 0:
        raise HTTPException(status_code=400, detail="Aantal spelers moet even zijn.")

    # 2. Husselen
    shuffled_players = list(players)
    random.shuffle(shuffled_players)

    new_teams = []
    
    # 3. Check Toernooi
    tournament = session.get(Tournament, auto_in.tournament_id)
    if not tournament:
        raise HTTPException(status_code=404, detail="Toernooi niet gevonden")

    for i in range(0, len(shuffled_players), 2):
        p1 = shuffled_players[i]
        p2 = shuffled_players[i+1]
        
        pair_players = [p1, p2]
        auto_name = generate_team_name(pair_players)
        
        # A. Maak Team
        team = Team(name=auto_name)
        team.players = pair_players
        session.add(team)
        session.commit() 
        session.refresh(team)
        
        # B. Maak Link
        link = TournamentTeamLink(tournament_id=tournament.id, team_id=team.id)
        session.add(link)
        
        new_teams.append(team)

    session.commit()
    
    # Refresh voor return
    for t in new_teams:
        session.refresh(t)
        
    return new_teams

@router.delete("/{team_id}")
def delete_team(
    team_id: int,
    session: Session = Depends(get_session),
    current_user = Depends(get_current_user)
):
    team = session.get(Team, team_id)
    if not team:
        raise HTTPException(status_code=404, detail="Team niet gevonden")
    
    # Optioneel: Check of team al wedstrijden heeft gespeeld om integriteitsfouten te voorkomen
    # Voor nu verwijderen we hem gewoon hard (SQLAlchemy regelt vaak de link-tabellen)
    session.delete(team)
    session.commit()
    return {"ok": True}

==================================================
FILE: backend/app\api\tournaments.py
==================================================

# FILE: backend/app/api/tournaments.py
import uuid
import math 
from typing import List, Optional, Any, Dict
from fastapi import APIRouter, Depends, HTTPException, Query
from sqlmodel import Session, select
from sqlalchemy.orm import selectinload

from app.db.session import get_session
from app.models.tournament import Tournament
from app.models.user import User
from app.models.player import Player
from app.models.match import Match
from app.models.dartboard import Dartboard 
from app.models.team import Team
from app.api.users import get_current_user
from app.models.links import TournamentTeamLink

from app.schemas.tournament import (
    TournamentCreate, 
    TournamentRead, 
    TournamentUpdate, 
    TournamentReadWithMatches
)

# Toegevoegd: calculate_poule_standings
from app.services.tournament_gen import (
    generate_poule_phase, 
    generate_round_robin_global,
    generate_knockout,
    generate_knockout_bracket,
    assign_referees,
    calculate_poule_standings 
)
from app.models import tournament

router = APIRouter()

@router.post("/", response_model=TournamentRead)
def create_tournament(
    tourn_in: TournamentCreate,
    session: Session = Depends(get_session),
    current_user: User = Depends(get_current_user)
):
    # 1. Verify Players
    players_to_link = []
    if tourn_in.player_ids:
        players_to_link = session.exec(select(Player).where(Player.id.in_(tourn_in.player_ids))).all()
    
    # Check minimum players (raw count)
    if len(players_to_link) < 2:
        raise HTTPException(status_code=400, detail="Selecteer minimaal 2 spelers.")

    # 2. Validatie Poulegrootte
    if tourn_in.format == "hybrid" and tourn_in.number_of_poules > 0:
            
            # Bepaal hoeveel 'entiteiten' (spelers of teams) er in de poule komen
            entity_count = len(players_to_link)
            
            # Als het koppels zijn, delen we het aantal spelers door 2
            if tourn_in.mode == "doubles":
                entity_count = math.ceil(entity_count / 2)

            avg_entities = math.ceil(entity_count / tourn_in.number_of_poules)
            
            if avg_entities > 7:
                raise HTTPException(
                    status_code=400, 
                    detail=f"Te veel deelnames per poule! Je probeert {avg_entities} teams/spelers per poule te stoppen. Het maximum is 7."
                )

    # 3. Verify Boards
    boards_to_link = []
    if tourn_in.board_ids:
        boards_to_link = session.exec(select(Dartboard).where(Dartboard.id.in_(tourn_in.board_ids))).all()
        if not boards_to_link:
             raise HTTPException(status_code=400, detail="Ongeldige borden geselecteerd.")

    # 4. Create Tournament Object
    # We exclude ids because we link them manually via relationships
    tourn_data = tourn_in.model_dump(exclude={"player_ids", "board_ids"})
    tournament = Tournament.model_validate(tourn_data)
    
    tournament.user_id = current_user.id
    tournament.status = "active"
    tournament.scorer_uuid = str(uuid.uuid4())
    tournament.public_uuid = str(uuid.uuid4())
    
    # 5. Link Relations
    tournament.players = players_to_link
    tournament.boards = boards_to_link 
    
    session.add(tournament)
    session.commit()
    session.refresh(tournament)
    
    # 6. Generate Matches based on Format (ONLY FOR SINGLES)
    # For doubles, we wait for the /finalize endpoint because teams need to be created first
    if tournament.mode == "singles":
            if tournament.format == "hybrid":
                generate_poule_phase(
                    tournament_id=tournament.id, 
                    players=players_to_link, 
                    num_poules=tournament.number_of_poules, 
                    legs_best_of=tournament.starting_legs_group,
                    sets_best_of=tournament.sets_per_match,
                    session=session
                )
            elif tournament.format == "round_robin":
                generate_round_robin_global(
                    tournament_id=tournament.id,
                    players=players_to_link,
                    legs_best_of=tournament.starting_legs_group,
                    sets_best_of=tournament.sets_per_match,
                    session=session
                )
            elif tournament.format == "knockout":
                generate_knockout(
                    tournament_id=tournament.id,
                    players=players_to_link,
                    legs_best_of=tournament.starting_legs_ko,
                    sets_best_of=tournament.sets_per_match,
                    session=session
                )
        
    return tournament

@router.get("/{tournament_id}", response_model=TournamentRead)
def read_tournament_by_id(
    tournament_id: int,
    session: Session = Depends(get_session),
    current_user: User = Depends(get_current_user)
):
    tournament = session.get(Tournament, tournament_id)
    if not tournament:
        raise HTTPException(status_code=404, detail="Tournament not found")
    return tournament

# --- NIEUW ENDPOINT: Centrale Standen Berekening ---
@router.get("/{tournament_id}/standings")
def get_tournament_standings(
    tournament_id: int,
    session: Session = Depends(get_session)
):
    """
    Geeft de berekende stand terug voor alle poules.
    Bevat logica voor:
    - 2 punten per winst
    - Leg Saldo
    - Head-to-Head
    - 9-dart Shoot-out detectie (needs_shootout=True)
    """
    tournament = session.get(Tournament, tournament_id)
    if not tournament:
        raise HTTPException(status_code=404, detail="Tournament not found")
    
    # Roep de centrale logica aan in tournament_gen.py
    return calculate_poule_standings(session, tournament)
# ---------------------------------------------------

@router.get("/", response_model=List[TournamentRead])
def read_tournaments(
    offset: int = 0,
    limit: int = 100,
    session: Session = Depends(get_session),
    current_user: User = Depends(get_current_user)
):
    tournaments = session.exec(
        select(Tournament)
        .where(Tournament.user_id == current_user.id)
        .options(selectinload(Tournament.players), selectinload(Tournament.boards))
        .order_by(Tournament.created_at.desc()) # Sorteer op nieuwste eerst
        .offset(offset)
        .limit(limit)
    ).all()
    
    # Fill counts manually
    results = []
    for t in tournaments:
        t_data = t.model_dump()
        t_data['player_count'] = len(t.players)
        t_data['board_count'] = len(t.boards)
        results.append(t_data)
        
    return results

@router.get("/public/{public_uuid}", response_model=TournamentReadWithMatches)
def read_public_tournament(public_uuid: str, session: Session = Depends(get_session)):
    # 1. Fetch tournament with matches and players
    # We use options to efficiently load relationships in one go
    t = session.exec(
        select(Tournament)
        .where(Tournament.public_uuid == public_uuid)
        .options(
            selectinload(Tournament.matches).options(
                selectinload(Match.referee),      # Load Referee Player
                selectinload(Match.referee_team)  # Load Referee Team
            ), 
            selectinload(Tournament.players)
        )
    ).first()
    
    if not t:
        raise HTTPException(status_code=404, detail="Tournament not found")

    # 2. Create map for players and teams for fast lookup
    player_map = {p.id: p.name for p in t.players}
    
    # We also need teams if it's a doubles tournament
    teams = session.exec(
        select(Team)
        .join(TournamentTeamLink)
        .where(TournamentTeamLink.tournament_id == t.id)
    ).all()
    team_map = {team.id: team.name for team in teams}

    # 3. Enrich matches with names
    matches_data = []
    # Sort matches by ID to keep order
    sorted_matches = sorted(t.matches, key=lambda m: m.id)
    
    for m in sorted_matches:
        m_dict = m.model_dump()
        
        # Resolve Name 1 (Player > Team > Bye)
        if m.player1_id:
            m_dict['player1_name'] = player_map.get(m.player1_id, "Bye")
        elif m.team1_id:
             m_dict['player1_name'] = team_map.get(m.team1_id, "Bye")
        else:
             m_dict['player1_name'] = "Bye"

        # Resolve Name 2
        if m.player2_id:
            m_dict['player2_name'] = player_map.get(m.player2_id, "Bye")
        elif m.team2_id:
             m_dict['player2_name'] = team_map.get(m.team2_id, "Bye")
        else:
             m_dict['player2_name'] = "Bye"
             
        # --- Resolve Referee Name ---
        if m.referee:
            m_dict['referee_name'] = m.referee.name
        elif m.referee_team:
            m_dict['referee_name'] = m.referee_team.name
        else:
            m_dict['referee_name'] = "-" 
        # ---------------------------------

        matches_data.append(m_dict)

    # 4. Build response
    response = t.model_dump()
    response['matches'] = matches_data
    response['player_count'] = len(t.players)
    response['board_count'] = len(t.boards)

    return response

@router.post("/{tournament_id}/start-knockout")
def start_knockout(
    tournament_id: int,
    session: Session = Depends(get_session),
    current_user: User = Depends(get_current_user)
):
    t = session.get(Tournament, tournament_id)
    if not t:
        raise HTTPException(status_code=404, detail="Tournament not found")
        
    # Call the NEW function from tournament_gen
    generate_knockout_bracket(session, t)
    
    return {"message": "Knockout phase generated"}


@router.patch("/{tournament_id}", response_model=TournamentRead)
def update_tournament_settings(
    tournament_id: int,
    tourn_update: TournamentUpdate,
    session: Session = Depends(get_session),
    current_user: User = Depends(get_current_user)
):
    """
    Update tournament settings (e.g. allow_byes) on the fly.
    """
    tournament = session.get(Tournament, tournament_id)
    if not tournament:
        raise HTTPException(status_code=404, detail="Tournament not found")
    
    tourn_data = tourn_update.model_dump(exclude_unset=True)
    for key, value in tourn_data.items():
        setattr(tournament, key, value)
        
    session.add(tournament)
    session.commit()
    session.refresh(tournament)
    return tournament

@router.post("/{tournament_id}/rounds/{round_number}/update-format")
def update_round_format(
    tournament_id: int,
    round_number: int,
    best_of_legs: int = Query(...),
    session: Session = Depends(get_session),
    current_user: User = Depends(get_current_user)
):
    """
    Batch update: Adjust 'Best of X' for ALL unplayed matches in a specific round.
    """
    statement = select(Match).where(
        Match.tournament_id == tournament_id,
        Match.round_number == round_number,
        Match.is_completed == False 
    )
    matches = session.exec(statement).all()
    
    if not matches:
        return {"message": "Geen ongespeelde wedstrijden gevonden in deze ronde om aan te passen."}
        
    for match in matches:
        match.best_of_legs = best_of_legs
        session.add(match)
        
    session.commit()
    return {"message": f"{len(matches)} wedstrijden geüpdatet naar Best of {best_of_legs} legs."}


@router.delete("/{tournament_id}")
def delete_tournament(
    tournament_id: int,
    session: Session = Depends(get_session),
    current_user: User = Depends(get_current_user)
):
    tournament = session.get(Tournament, tournament_id)
    if not tournament:
        raise HTTPException(status_code=404, detail="Tournament not found")
    
    # 1. Delete Matches
    matches = session.exec(select(Match).where(Match.tournament_id == tournament_id)).all()
    for m in matches:
        session.delete(m)
        
    # 2. Delete Teams (FIX: Via de koppeltabel zoeken)
    # Omdat Team geen 'tournament_id' heeft, joinen we met TournamentTeamLink
    teams = session.exec(
        select(Team)
        .join(TournamentTeamLink)
        .where(TournamentTeamLink.tournament_id == tournament_id)
    ).all()
    
    for t in teams:
        session.delete(t)
        
    # 3. Delete Tournament
    session.delete(tournament)
    session.commit()
    
    return {"ok": True}


@router.post("/{tournament_id}/finalize")
def finalize_tournament_setup(
    tournament_id: int, 
    session: Session = Depends(get_session)
):
    """
    Trigger match generation after teams are created.
    Specific for Doubles/Teams tournaments.
    """
    tournament = session.get(Tournament, tournament_id)
    if not tournament:
        raise HTTPException(status_code=404, detail="Toernooi niet gevonden")

    if tournament.mode == "singles":
        return {"message": "Already generated (singles)"}

    # Fetch all teams
    teams = session.exec(select(Team).where(Team.tournament_id == tournament_id)).all()
    
    if len(teams) < 2:
        raise HTTPException(status_code=400, detail="Te weinig teams om wedstrijden te genereren.")

    # Remove old matches (safety)
    existing_matches = session.exec(select(Match).where(Match.tournament_id == tournament_id)).all()
    for m in existing_matches:
        session.delete(m)
    
    # --- Generation Logic for Teams (Poule Phase) ---
    num_poules = tournament.number_of_poules
    poules = [[] for _ in range(num_poules)]
    
    for i, team in enumerate(teams):
        poule_index = i % num_poules
        poules[poule_index].append(team)

        matches_created = []
    
    for poule_idx, poule_teams in enumerate(poules):
        poule_number = poule_idx + 1
        n = len(poule_teams)
        
        # Temporary list for this poule's matches
        poule_matches = [] 

        # Round Robin Generation
        for i in range(n):
            for j in range(i + 1, n):
                t1 = poule_teams[i]
                t2 = poule_teams[j]
                
                match = Match(
                    tournament_id=tournament.id,
                    poule_number=poule_number,
                    team1_id=t1.id,
                    team2_id=t2.id,
                    round_number=1, # Note: Round logic is simple here, might need improvement for perfect referee spacing
                    best_of_legs=tournament.starting_legs_group,
                    best_of_sets=tournament.sets_per_match,
                    is_completed=False,
                    score_p1=0,
                    score_p2=0
                )
                poule_matches.append(match) # Add to temp list

        # --- Referee Toewijzen ---
        assign_referees(poule_matches, poule_teams, is_doubles=True)
        # -------------------------

        # Add to main list to save later
        matches_created.extend(poule_matches)
        session.add_all(poule_matches)

    session.commit()
    return {"message": f"Setup finalized. {len(matches_created)} matches generated for {len(teams)} teams."}

==================================================
FILE: backend/app\api\users.py
==================================================

from typing import Annotated
from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from jose import JWTError, jwt
from sqlmodel import Session, select

from app.db.session import get_session
from app.models.user import User
from app.core.security import SECRET_KEY, ALGORITHM
from app.schemas.token import TokenData

router = APIRouter()

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="api/auth/login")

async def get_current_user(
    token: Annotated[str, Depends(oauth2_scheme)],
    session: Session = Depends(get_session)
):
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        # We stored the email in the 'sub' field in auth.py
        email: str = payload.get("sub")
        if email is None:
            raise credentials_exception
        token_data = TokenData(email=email)
    except JWTError:
        raise credentials_exception
        
    # FIX: Look up by email, NOT username
    statement = select(User).where(User.email == token_data.email)
    user = session.exec(statement).first()
    
    if user is None:
        raise credentials_exception
    return user

@router.get("/me", response_model=User)
async def read_users_me(
    current_user: Annotated[User, Depends(get_current_user)]
):
    return current_user

==================================================
FILE: backend/app\api\websockets.py
==================================================

import asyncio
import logging
from fastapi import APIRouter, WebSocket, WebSocketDisconnect
from app.core.logging_config import log_buffer

router = APIRouter()
logger = logging.getLogger("dart_app")

@router.websocket("/logs")
async def websocket_endpoint(websocket: WebSocket):
    await websocket.accept()
    
    # 1. Send existing logs immediately upon connection
    # Convert deque to list so it is JSON serializable
    await websocket.send_json(list(log_buffer))
    
    try:
        while True:
            # 2. Wait a bit (Poll)
            # In a production app, we would use an event trigger, 
            # but polling the buffer every 2 seconds is fine for this.
            await asyncio.sleep(2)
            
            # Send the current buffer state
            await websocket.send_json(list(log_buffer))
            
    except WebSocketDisconnect:
        logger.info("Logs Client disconnected")

==================================================
FILE: backend/app\api\__init__.py
==================================================

from . import auth, users, players, tournaments, matches, websockets, dartboards

==================================================
FILE: backend/app\core\config.py
==================================================

from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    # Application Info
    PROJECT_NAME: str = "Dart Tournament Manager"
    
    # Database
    # Default to SQLite for dev, but ready for Postgres
    DATABASE_URL: str = "sqlite:///./darts.db"
    
    # Security
    # In production, this should be a long, random string!
    SECRET_KEY: str = "change_this_secret_in_production_9823749823"
    ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 1440  # 24 hours

    class Config:
        case_sensitive = True
        env_file = ".env"

settings = Settings()

==================================================
FILE: backend/app\core\logging_config.py
==================================================

import logging
import sys
from collections import deque

# 1. The Shared Buffer
# This holds the last 100 log messages in memory.
# It is exported so websockets.py can import it and send it to the frontend.
log_buffer = deque(maxlen=100)

class BufferHandler(logging.Handler):
    """Custom handler that pushes logs into the deque."""
    def emit(self, record):
        try:
            msg = self.format(record)
            log_buffer.append(msg)
        except Exception:
            self.handleError(record)

def setup_logging():
    """Configures the logger to write to Console, File, and WebSocket Buffer."""
    logger = logging.getLogger("dart_app")
    logger.setLevel(logging.INFO)
    
    # Prevent adding handlers multiple times if the app reloads
    if logger.hasHandlers():
        return logger

    formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')

    # A. Console Handler (Print to terminal)
    console_handler = logging.StreamHandler(sys.stdout)
    console_handler.setFormatter(formatter)
    logger.addHandler(console_handler)

    # B. File Handler (Save to disk)
    # The 'logs' folder was created by our structure script
    try:
        file_handler = logging.FileHandler("logs/app.log")
        file_handler.setFormatter(formatter)
        logger.addHandler(file_handler)
    except FileNotFoundError:
        print("Warning: logs directory not found. Skipping file logging.")

    # C. Buffer Handler (For WebSockets)
    buffer_handler = BufferHandler()
    buffer_handler.setFormatter(formatter)
    logger.addHandler(buffer_handler)

    return logger

# Initialize immediately so it runs on import
logger = setup_logging()

==================================================
FILE: backend/app\core\security.py
==================================================

from datetime import datetime, timedelta
from typing import Any, Union
from jose import jwt
from passlib.context import CryptContext

# --- Configuration ---
# In a real production app, you would load these from an environment variable
SECRET_KEY = "CHANGE_THIS_TO_A_SECURE_RANDOM_STRING_IN_PRODUCTION"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30  # <--- This is the missing line causing your error!

# --- Password Hashing Setup ---
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

def verify_password(plain_password, hashed_password):
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password):
    return pwd_context.hash(password)

# --- Token Generation ---
def create_access_token(data: dict, expires_delta: Union[timedelta, None] = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=15)
    
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

==================================================
FILE: backend/app\core\__init__.py
==================================================



==================================================
FILE: backend/app\db\session.py
==================================================

from sqlmodel import SQLModel, create_engine, Session
from app.core.config import settings

# check_same_thread=False is needed only for SQLite
connect_args = {"check_same_thread": False} if "sqlite" in settings.DATABASE_URL else {}

engine = create_engine(
    settings.DATABASE_URL, 
    echo=True, # Set to False in production to reduce log noise
    connect_args=connect_args
)

def init_db():
    """
    Creates all tables defined in SQLModel models.
    Called during startup in main.py.
    """
    # Import ALL models here so SQLModel knows about them before creating tables
    # --- FIX: Added 'dartboard' and 'links' to this list ---
    from app.models import user, player, tournament, match, dartboard, links, team # noqa: F401
    
    SQLModel.metadata.create_all(engine)

def get_session():
    """
    Dependency to be used in FastAPI endpoints.
    Yields a database session and closes it automatically.
    """
    with Session(engine) as session:
        yield session

==================================================
FILE: backend/app\db\__init__.py
==================================================



==================================================
FILE: backend/app\models\dartboard.py
==================================================

from typing import Optional
from sqlmodel import Field, SQLModel

class Dartboard(SQLModel, table=True):
    id: Optional[int] = Field(default=None, primary_key=True)
    name: str  # e.g., "Main Stage"
    number: int # e.g., 1

==================================================
FILE: backend/app\models\links.py
==================================================

from typing import Optional
from sqlmodel import Field, SQLModel

class TournamentPlayerLink(SQLModel, table=True):
    tournament_id: Optional[int] = Field(default=None, foreign_key="tournament.id", primary_key=True)
    player_id: Optional[int] = Field(default=None, foreign_key="player.id", primary_key=True)

class TournamentBoardLink(SQLModel, table=True):
    tournament_id: Optional[int] = Field(default=None, foreign_key="tournament.id", primary_key=True)
    board_id: Optional[int] = Field(default=None, foreign_key="dartboard.id", primary_key=True)

class TeamPlayerLink(SQLModel, table=True):
    team_id: Optional[int] = Field(default=None, foreign_key="team.id", primary_key=True)
    player_id: Optional[int] = Field(default=None, foreign_key="player.id", primary_key=True)

class TournamentTeamLink(SQLModel, table=True):
    tournament_id: Optional[int] = Field(default=None, foreign_key="tournament.id", primary_key=True)
    team_id: Optional[int] = Field(default=None, foreign_key="team.id", primary_key=True)

==================================================
FILE: backend/app\models\match.py
==================================================

from typing import Optional
from sqlmodel import SQLModel, Field, Relationship

class Match(SQLModel, table=True):
    id: Optional[int] = Field(default=None, primary_key=True)
    
    # --- Structure info ---
    round_number: int 
    poule_number: Optional[int] = None # Als dit ingevuld is, is het een groepswedstrijd
    board_number: Optional[int] = None 
    
    # --- Game Settings ---
    best_of_legs: int = Field(default=5) # Bijv. "5" (betekent first to 3)
    best_of_sets: int = Field(default=1) 
    
    # --- Status ---
    is_completed: bool = False
    
    # --- Scores ---
    score_p1: int = 0
    score_p2: int = 0
    
    # --- Relationships: TOERNOOI ---
    tournament_id: int = Field(foreign_key="tournament.id")
    tournament: Optional["Tournament"] = Relationship(back_populates="matches")
    
    # --- Relationships: SPELERS (Singles) ---
    player1_id: Optional[int] = Field(default=None, foreign_key="player.id")
    player2_id: Optional[int] = Field(default=None, foreign_key="player.id")


    player1: Optional["Player"] = Relationship(
        sa_relationship_kwargs={"foreign_keys": "[Match.player1_id]"}
    )
    player2: Optional["Player"] = Relationship(
        sa_relationship_kwargs={"foreign_keys": "[Match.player2_id]"}
    )

    # ... existing fields (id, round_number, poule_number, etc.) ...
    
    # --- REFEREE FIELDS (NEW) ---
    referee_id: Optional[int] = Field(default=None, foreign_key="player.id")
    referee_team_id: Optional[int] = Field(default=None, foreign_key="team.id")

    # --- RELATIONS (NEW) ---
    referee: Optional["Player"] = Relationship(
        sa_relationship_kwargs={"foreign_keys": "[Match.referee_id]"}
    )
    referee_team: Optional["Team"] = Relationship(
        sa_relationship_kwargs={"foreign_keys": "[Match.referee_team_id]"}
    )


    # --- Relationships: TEAMS (Koppels) ---
    team1_id: Optional[int] = Field(default=None, foreign_key="team.id")
    team2_id: Optional[int] = Field(default=None, foreign_key="team.id")

    # Idem voor de teams: relatie objecten toevoegen
    team1: Optional["Team"] = Relationship(
        sa_relationship_kwargs={"foreign_keys": "[Match.team1_id]"}
    )
    team2: Optional["Team"] = Relationship(
        sa_relationship_kwargs={"foreign_keys": "[Match.team2_id]"}
    )

==================================================
FILE: backend/app\models\player.py
==================================================

from typing import Optional, List
from sqlmodel import Field, SQLModel, Relationship
from app.models.team import Team
from app.models.links import TeamPlayerLink

class Player(SQLModel, table=True):
    id: Optional[int] = Field(default=None, primary_key=True)
    
    first_name: str
    last_name: Optional[str] = None
    nickname: Optional[str] = None
    email: Optional[str] = None # We keep this loose as a string in the DB
    
    user_id: Optional[int] = Field(default=None, foreign_key="user.id")
    user: Optional["User"] = Relationship(back_populates="players")

    teams: List[Team] = Relationship(back_populates="players", link_model=TeamPlayerLink)

    @property
    def name(self) -> str:
        full_name = self.first_name
        if self.nickname:
            full_name += f' "{self.nickname}"'
        if self.last_name:
            full_name += f" {self.last_name}"
        return full_name
    

==================================================
FILE: backend/app\models\team.py
==================================================

from typing import Optional, List
from sqlmodel import Field, SQLModel, Relationship
from app.models.links import TeamPlayerLink, TournamentTeamLink

class Team(SQLModel, table=True):
    id: Optional[int] = Field(default=None, primary_key=True)
    name: str
    
    # Relaties
    players: List["Player"] = Relationship(back_populates="teams", link_model=TeamPlayerLink)
    
    
    #tournament: "Tournament" = Relationship(back_populates="teams")



    tournaments: List["Tournament"] = Relationship(back_populates="teams", link_model=TournamentTeamLink)

==================================================
FILE: backend/app\models\tournament.py
==================================================

import uuid
from typing import Optional, List
from sqlmodel import SQLModel, Field, Relationship
from datetime import datetime
from app.models.links import TournamentPlayerLink, TournamentBoardLink, TournamentTeamLink

class Tournament(SQLModel, table=True):
    id: Optional[int] = Field(default=None, primary_key=True)
    
    name: str = Field(default_factory=lambda: f"Toernooi {datetime.now().strftime('%Y-%m-%d')}")
    date: str 
    created_at: datetime = Field(default_factory=datetime.utcnow)
    status: str = Field(default="draft") # draft, active, knockout_ready, finished
    
    # --- Format Settings ---
    mode: str = Field(default="singles") # "singles" of "doubles"
    format: str = Field(default="hybrid") 
    
    number_of_poules: int = Field(default=1)
    
    # Hoeveel spelers gaan er per poule door naar de KO?
    qualifiers_per_poule: int = Field(default=2) 

    allow_byes: bool = Field(default=True)
    
    # --- Game Settings (Best of X) ---
    starting_legs_group: int = Field(default=3) 
    starting_legs_ko: int = Field(default=3)    
    sets_per_match: int = Field(default=1)
    
    # --- Access Control ---
    public_uuid: str = Field(default_factory=lambda: str(uuid.uuid4()), index=True, unique=True)
    scorer_uuid: str = Field(default_factory=lambda: str(uuid.uuid4()), index=True, unique=True)
    
    # --- Ownership ---
    user_id: Optional[int] = Field(default=None, foreign_key="user.id")
    user: Optional["User"] = Relationship(back_populates="tournaments")
    
    # --- Relationships ---
    players: List["Player"] = Relationship(back_populates=None, link_model=TournamentPlayerLink)
    boards: List["Dartboard"] = Relationship(back_populates=None, link_model=TournamentBoardLink)
    matches: List["Match"] = Relationship(back_populates="tournament")
    
    teams: List["Team"] = Relationship(back_populates="tournaments", link_model=TournamentTeamLink)

==================================================
FILE: backend/app\models\user.py
==================================================

from typing import Optional
from sqlmodel import Field, SQLModel, Relationship

class User(SQLModel, table=True):
    id: Optional[int] = Field(default=None, primary_key=True)
    
    first_name: str
    last_name: str
    email: str = Field(unique=True, index=True)
    
    hashed_password: str

    players: list["Player"] = Relationship(back_populates="user")
    tournaments: list["Tournament"] = Relationship(back_populates="user")

==================================================
FILE: backend/app\models\__init__.py
==================================================

from .user import User
from .player import Player
from .tournament import Tournament
from .match import Match

==================================================
FILE: backend/app\schemas\auth.py
==================================================

from typing import Optional
from pydantic import BaseModel

class Token(BaseModel):
    access_token: str
    token_type: str

class TokenData(BaseModel):
    username: Optional[str] = None

class UserCreate(BaseModel):
    username: str
    password: str

class UserRead(BaseModel):
    id: int
    username: str

==================================================
FILE: backend/app\schemas\dartboard.py
==================================================

from pydantic import BaseModel

class DartboardBase(BaseModel):
    name: str
    number: int

class DartboardCreate(DartboardBase):
    pass

class DartboardRead(DartboardBase):
    id: int

==================================================
FILE: backend/app\schemas\match.py
==================================================

from typing import Optional
from pydantic import BaseModel

class MatchScoreUpdate(BaseModel):
    score_p1: int
    score_p2: int
    is_completed: bool = False

class MatchRead(BaseModel):
    id: int
    tournament_id: int
    round_number: int
    
    poule_number: Optional[int] = None 
    best_of_legs: Optional[int] = 5
    best_of_sets: Optional[int] = 1

    player1_id: Optional[int]
    player2_id: Optional[int]
    player1_name: Optional[str] = "Bye"
    player2_name: Optional[str] = "Bye"

    referee_id: Optional[int] = None
    referee_team_id: Optional[int] = None
    referee_name: Optional[str] = None
    
    score_p1: int
    score_p2: int
    is_completed: bool
    
    class Config:
        from_attributes = True

==================================================
FILE: backend/app\schemas\player.py
==================================================

from typing import Optional
from pydantic import BaseModel, EmailStr, field_validator

class PlayerBase(BaseModel):
    first_name: str
    last_name: Optional[str] = None
    nickname: Optional[str] = None
    email: Optional[EmailStr] = None

class PlayerCreate(PlayerBase):
    # This magic function converts empty strings "" into None (null)
    # automatically, preventing validation errors.
    @field_validator('email', 'nickname', 'last_name', mode='before')
    @classmethod
    def empty_to_none(cls, v):
        if v == "":
            return None
        return v

class PlayerRead(PlayerBase):
    id: int
    name: str

==================================================
FILE: backend/app\schemas\team.py
==================================================

from typing import List, Optional
from pydantic import BaseModel
from app.schemas.player import PlayerRead

# --- INPUT SCHEMAS ---

# Voor handmatig 1 team maken (Global of direct in toernooi)
class TeamCreateManual(BaseModel):
    tournament_id: Optional[int] = None
    player_ids: List[int]       # De IDs van de spelers in dit team
    name: Optional[str] = None  # Optioneel (wordt automatisch gegenereerd indien leeg)

# Voor automatisch teams genereren (random)
class TeamAutoGenerate(BaseModel):
    tournament_id: int
    player_ids: List[int]       # De pool van spelers die verdeeld moeten worden

# Voor het koppelen van bestaande teams aan een toernooi
class TeamLinkInput(BaseModel):
    tournament_id: int
    team_ids: List[int]


# --- OUTPUT SCHEMA ---

# Wat sturen we terug naar de frontend?
class TeamRead(BaseModel):
    id: int
    name: str
    # tournament_id is hier verwijderd om de validatie error te voorkomen!
    players: List[PlayerRead] = [] # We willen de speler details zien in het team

    class Config:
        from_attributes = True

==================================================
FILE: backend/app\schemas\token.py
==================================================

from typing import Optional
from pydantic import BaseModel

class Token(BaseModel):
    access_token: str
    token_type: str

class TokenData(BaseModel):
    email: Optional[str] = None

==================================================
FILE: backend/app\schemas\tournament.py
==================================================

# FILE: backend/app/schemas/tournament.py
from typing import List, Optional
from pydantic import BaseModel
from datetime import datetime

# --- Input Schema (Create) ---
class TournamentCreate(BaseModel):
    name: str
    date: str  
    number_of_poules: int = 1  
    format: str = "hybrid"
    mode: str = "singles"
    allow_byes: bool = True
    
    # Settings
    qualifiers_per_poule: int = 2
    starting_legs_group: int = 3
    starting_legs_ko: int = 5
    sets_per_match: int = 1
    
    # IDs voor relaties
    player_ids: List[int]
    board_ids: List[int]  

# --- Input Schema (Update) ---
class TournamentUpdate(BaseModel):
    name: Optional[str] = None
    date: Optional[str] = None
    status: Optional[str] = None
    format: Optional[str] = None
    scorer_uuid: Optional[str] = None

# --- Output Schema (Read) ---
class TournamentRead(BaseModel):
    id: int
    name: str
    date: str 
    status: str
    format: str
    allow_byes: bool = True
    number_of_poules: int  
    created_at: datetime
    public_uuid: str
    scorer_uuid: str
    
    # Settings terugsturen
    qualifiers_per_poule: int = 2
    starting_legs_group: int = 3
    starting_legs_ko: int = 5
    
    # Counts
    player_count: int = 0
    board_count: int = 0
    
    class Config:
        from_attributes = True

# --- Detailed View (Public Page) ---
class MatchReadSimple(BaseModel):
    id: int
    round_number: int
    poule_number: Optional[int] = None
    player1_name: Optional[str] = None
    player2_name: Optional[str] = None
    score_p1: int
    score_p2: int
    is_completed: bool
    referee_name: Optional[str] = None

class TournamentReadWithMatches(TournamentRead):
    matches: List[MatchReadSimple] = []

==================================================
FILE: backend/app\schemas\user.py
==================================================

from typing import Optional
from pydantic import BaseModel, EmailStr

class UserCreate(BaseModel):
    first_name: str
    last_name: str
    email: EmailStr
    password: str  # No username here

class UserRead(BaseModel):
    id: int
    first_name: str
    last_name: str
    email: str 
    # No username here

class UserUpdate(BaseModel):
    first_name: Optional[str] = None
    last_name: Optional[str] = None
    email: Optional[EmailStr] = None

==================================================
FILE: backend/app\schemas\__init__.py
==================================================



==================================================
FILE: backend/app\services\tournament_gen.py
==================================================

import math
import random
import functools
from typing import List, Dict, Any
from sqlmodel import Session, select
from app.models.match import Match
from app.models.team import Team
from app.models.player import Player
from app.models.tournament import Tournament

# ==========================================
# 1. POULE FASE LOGICA (VOOR SINGLES)
# ==========================================

def generate_poule_phase(
    tournament_id: int,
    players: List[Player],
    num_poules: int,
    legs_best_of: int,
    sets_best_of: int,
    session: Session
):
    """
    Verdeelt spelers over N poules en genereert voor elke poule een Round Robin schema.
    """
    if len(players) < num_poules:
        num_poules = 1

    # 1. Spelers husselen
    shuffled_players = list(players)
    random.shuffle(shuffled_players)

    # 2. Verdeel over poules
    poules_map = {i: [] for i in range(1, num_poules + 1)}
    
    for idx, player in enumerate(shuffled_players):
        target_poule = (idx % num_poules) + 1
        poules_map[target_poule].append(player)

    # 3. Genereer wedstrijden
    matches_to_add = []
    for poule_num, pool_players in poules_map.items():
        new_matches = _create_round_robin_matches(
            tournament_id=tournament_id,
            players=pool_players,
            poule_number=poule_num,
            legs=legs_best_of,
            sets=sets_best_of
        )
        
        new_matches.sort(key=lambda m: m.round_number)
        assign_referees(new_matches, pool_players, is_doubles=False)
        # --------------------------------

        matches_to_add.extend(new_matches)

    session.add_all(matches_to_add)
    session.commit()


def generate_round_robin_global(
    tournament_id: int, 
    players: List[Player], 
    legs_best_of: int,
    sets_best_of: int,
    session: Session
):
    """Klassieke Round Robin (alles in 1 grote groep)."""
    matches = _create_round_robin_matches(tournament_id, players, None, legs_best_of, sets_best_of)
    session.add_all(matches)
    session.commit()


def _create_round_robin_matches(
    tournament_id: int, 
    players: List[Player], 
    poule_number: int | None,
    legs: int,
    sets: int
) -> List[Match]:
    matches = []
    if len(players) < 2:
        return matches

    rotation = list(players)
    if len(rotation) % 2 != 0:
        rotation.append(None)
    
    num_players = len(rotation)
    num_rounds = num_players - 1
    half = num_players // 2

    for round_idx in range(num_rounds):
        round_num = round_idx + 1
        for i in range(half):
            p1 = rotation[i]
            p2 = rotation[num_players - 1 - i]
            
            if p1 and p2:
                match = Match(
                    tournament_id=tournament_id,
                    round_number=round_num,
                    poule_number=poule_number,
                    player1_id=p1.id,
                    player2_id=p2.id,
                    best_of_legs=legs,
                    best_of_sets=sets,
                    is_completed=False
                )
                matches.append(match)
        rotation.insert(1, rotation.pop())
    
    return matches


# ==========================================
# 2. NIEUWE KNOCKOUT LOGICA (TEAMS + SINGLES)
# ==========================================

# backend/app/services/tournament_gen.py

import functools
# Voeg functools toe aan de imports bovenin backend/app/services/tournament_gen.py

# backend/app/services/tournament_gen.py

def calculate_poule_standings(session: Session, tournament: Tournament) -> Dict[int, List[dict]]:
    """
    Berekent de stand per poule volgens Order of Merit Rules:
    Punten (2 per winst) -> Leg-Difference -> Head-to-Head -> 9-dart-Shoot-out.
    """
    matches = session.exec(
        select(Match)
        .where(Match.tournament_id == tournament.id)
        .where(Match.poule_number != None)
        .where(Match.is_completed == True)
    ).all()

    is_doubles = tournament.mode == "doubles"
    raw_standings = {} 
    h2h_winners = {} 

    def init_entity(poule_num, entity_id, entity_name):
        if poule_num not in raw_standings:
            raw_standings[poule_num] = {}
        if entity_id not in raw_standings[poule_num]:
            raw_standings[poule_num][entity_id] = {
                "id": entity_id,
                "name": entity_name,
                "points": 0,
                "played": 0,
                "legs_won": 0,
                "legs_lost": 0,
                "leg_diff": 0,
                "needs_shootout": False  # Nieuwe vlag voor stap 3
            }

    for m in matches:
        if is_doubles:
            if not m.team1 or not m.team2: session.refresh(m, ["team1", "team2"])
            id_1, id_2 = m.team1_id, m.team2_id
            name_1, name_2 = (m.team1.name if m.team1 else "Team ?"), (m.team2.name if m.team2 else "Team ?")
        else:
            if not m.player1 or not m.player2: session.refresh(m, ["player1", "player2"])
            id_1, id_2 = m.player1_id, m.player2_id
            name_1, name_2 = (m.player1.name if m.player1 else "Player ?"), (m.player2.name if m.player2 else "Player ?")

        if not id_1 or not id_2: continue

        init_entity(m.poule_number, id_1, name_1)
        init_entity(m.poule_number, id_2, name_2)

        stats_1 = raw_standings[m.poule_number][id_1]
        stats_2 = raw_standings[m.poule_number][id_2]

        stats_1["played"] += 1
        stats_2["played"] += 1
        stats_1["legs_won"] += m.score_p1
        stats_1["legs_lost"] += m.score_p2
        stats_2["legs_won"] += m.score_p2
        stats_2["legs_lost"] += m.score_p1

        winner_id = id_1 if m.score_p1 > m.score_p2 else id_2
        if m.score_p1 > m.score_p2:
            stats_1["points"] += 2
        else:
            stats_2["points"] += 2
            
        pair = tuple(sorted([id_1, id_2]))
        h2h_winners[(m.poule_number, pair)] = winner_id

    def compare_entities(a, b, poule_num):
        # 1. Punten
        if a["points"] != b["points"]:
            return a["points"] - b["points"]
        # 2. Leg Difference
        if a["leg_diff"] != b["leg_diff"]:
            return a["leg_diff"] - b["leg_diff"]
        # 3. Head-to-Head
        pair = tuple(sorted([a["id"], b["id"]]))
        winner_id = h2h_winners.get((poule_num, pair))
        if winner_id == a["id"]: return 1
        if winner_id == b["id"]: return -1
        return 0

    final_standings = {}
    for p_num in range(1, tournament.number_of_poules + 1):
        if p_num in raw_standings:
            poule_list = list(raw_standings[p_num].values())
            for p in poule_list:
                p["leg_diff"] = p["legs_won"] - p["legs_lost"]
            
            # Sortering uitvoeren
            poule_list.sort(key=functools.cmp_to_key(lambda a, b: compare_entities(a, b, p_num)), reverse=True)

            # STAP 3 FIX: Controleer op onbesliste standen (Shoot-out nodig)
            for i in range(len(poule_list) - 1):
                # Als de comparator 0 teruggeeft tussen twee opeenvolgende spelers in de lijst
                if compare_entities(poule_list[i], poule_list[i+1], p_num) == 0:
                    poule_list[i]["needs_shootout"] = True
                    poule_list[i+1]["needs_shootout"] = True

            final_standings[p_num] = poule_list
        else:
            final_standings[p_num] = []

    return final_standings


# HIER IS DE FUNCTIE WAAR DE ERROR OVER KLAAGDE
def generate_knockout_bracket(session: Session, tournament: Tournament):
    """
    Genereert bracket op basis van standings voor Singles én Doubles.
    """
    standings = calculate_poule_standings(session, tournament)
    is_doubles = tournament.mode == "doubles"

    # Verzamel Qualifiers
    qualifiers = []
    q_per_poule = tournament.qualifiers_per_poule if tournament.qualifiers_per_poule else 2
    
    for p_num in range(1, tournament.number_of_poules + 1):
        poule_list = standings.get(p_num, [])
        top_x = poule_list[:q_per_poule]
        qualifiers.extend(top_x)

    if not qualifiers:
        print("Geen qualifiers. Zijn poules gespeeld?")
        return

    # Bracket Grootte (Macht van 2)
    count = len(qualifiers)
    bracket_size = 2
    while bracket_size < count:
        bracket_size *= 2
    
    qualified_ids = [q["id"] for q in qualifiers]
    
    # Byes toevoegen
    while len(qualified_ids) < bracket_size:
        qualified_ids.append(None)

    # Husselen (Simple Seeding)
    random.shuffle(qualified_ids)
    
    # Matches aanmaken
    matches_in_first_round = bracket_size // 2
    current_round = 1 
    
    for i in range(matches_in_first_round):
        p1_id = qualified_ids[i * 2]
        p2_id = qualified_ids[i * 2 + 1]
        
        match = Match(
            tournament_id=tournament.id,
            round_number=current_round,
            poule_number=None, # KO Match
            best_of_legs=tournament.starting_legs_ko,
            best_of_sets=tournament.sets_per_match,
            is_completed=False,
            score_p1=0,
            score_p2=0
        )
        
        # KOPPEL JUISTE KOLOMMEN
        if is_doubles:
            match.team1_id = p1_id
            match.team2_id = p2_id
            # Bye logica
            if p2_id is None and p1_id is not None:
                match.score_p1 = math.ceil(tournament.starting_legs_ko / 2) + 1
                match.is_completed = True
            if p1_id is None:
                match.is_completed = True
        else: # Singles
            match.player1_id = p1_id
            match.player2_id = p2_id
            # Bye logica
            if p2_id is None and p1_id is not None:
                match.score_p1 = math.ceil(tournament.starting_legs_ko / 2) + 1
                match.is_completed = True
            if p1_id is None:
                match.is_completed = True

        session.add(match)
    
    session.commit()
    print(f"Knockout (Teams/Singles) gegenereerd: {matches_in_first_round} wedstrijden.")


def check_and_advance_knockout(tournament_id: int, current_round: int, session: Session):
    """
    Checkt of ronde klaar is en genereert de volgende.
    Werkt nu ook voor TEAMS.
    """
    tournament = session.get(Tournament, tournament_id)
    if not tournament: return
    is_doubles = tournament.mode == "doubles"

    matches = session.exec(
        select(Match)
        .where(Match.tournament_id == tournament_id)
        .where(Match.round_number == current_round)
        .where(Match.poule_number == None) 
    ).all()
    
    if not matches: return 
    if not all(m.is_completed for m in matches): return 

    # Check of volgende ronde al bestaat
    next_round = current_round + 1
    existing = session.exec(select(Match).where(Match.tournament_id==tournament_id).where(Match.round_number==next_round).where(Match.poule_number==None)).first()
    if existing: return

    # Sorteer op ID om bracket structuur te behouden
    matches.sort(key=lambda m: m.id)
    
    next_round_count = len(matches) // 2
    if next_round_count < 1:
        print("Toernooi afgelopen.")
        return

    new_matches = []
    for i in range(next_round_count):
        m1 = matches[i * 2]
        m2 = matches[i * 2 + 1]
        
        # Bepaal winnaars
        if is_doubles:
            w1 = m1.team1_id if m1.score_p1 > m1.score_p2 else m1.team2_id
            w2 = m2.team1_id if m2.score_p1 > m2.score_p2 else m2.team2_id
        else:
            w1 = m1.player1_id if m1.score_p1 > m1.score_p2 else m1.player2_id
            w2 = m2.player1_id if m2.score_p1 > m2.score_p2 else m2.player2_id
            
        new_match = Match(
            tournament_id=tournament_id,
            round_number=next_round,
            poule_number=None,
            best_of_legs=tournament.starting_legs_ko,
            best_of_sets=tournament.sets_per_match,
            is_completed=False,
            score_p1=0, score_p2=0
        )
        
        if is_doubles:
            new_match.team1_id = w1
            new_match.team2_id = w2
        else:
            new_match.player1_id = w1
            new_match.player2_id = w2
            
        new_matches.append(new_match)
        
    session.add_all(new_matches)
    session.commit()
    print(f"Ronde {next_round} gegenereerd.")


# ==========================================
# 3. DIRECT KNOCKOUT & HELPERS
# ==========================================

def generate_knockout(
    tournament_id: int, 
    players: List[Player], 
    legs_best_of: int,
    sets_best_of: int,
    session: Session
):
    """Direct Knockout generator (Oud, voor Singles zonder poules)."""
    random.shuffle(players)
    
    class FakeTournament:
        id = tournament_id
        starting_legs_ko = legs_best_of
        sets_per_match = sets_best_of
        
    fake_tourn = FakeTournament()
    player_ids = [p.id for p in players]
    _create_bracket_matches(fake_tourn, player_ids, session)

def _create_bracket_matches(tournament, player_ids, session):
    n = len(player_ids)
    bracket_size = 1
    while bracket_size < n:
        bracket_size *= 2
        
    padded_players = list(player_ids)
    while len(padded_players) < bracket_size:
        padded_players.append(None)
        
    matches = []
    for i in range(bracket_size // 2):
        p1 = padded_players[i]
        p2 = padded_players[bracket_size - 1 - i]
        
        if p1 and p2:
            matches.append(_create_ko_match(tournament, p1, p2))
            
    session.add_all(matches)
    session.commit()

def _create_ko_match(tournament, p1_id, p2_id):
    return Match(
        tournament_id=tournament.id,
        round_number=1, 
        poule_number=None, 
        player1_id=p1_id,
        player2_id=p2_id,
        best_of_legs=tournament.starting_legs_ko,
        best_of_sets=tournament.sets_per_match,
        is_completed=False
    )

# ==========================================
# 4. TEAM HELPERS
# ==========================================

def create_random_teams(tournament_id: int, player_ids: list[int], session: Session):
    players = session.exec(select(Player).where(Player.id.in_(player_ids))).all()
    if len(players) % 2 != 0:
        raise ValueError("Aantal spelers moet even zijn voor koppels!")

    random.shuffle(players)
    teams = []
    for i in range(0, len(players), 2):
        p1 = players[i]
        p2 = players[i+1]
        team_name = f"{p1.last_name or p1.first_name} & {p2.last_name or p2.first_name}"
        team = Team(name=team_name, tournament_id=tournament_id)
        team.players = [p1, p2]
        session.add(team)
        teams.append(team)
    
    session.commit()
    return teams

def create_manual_team(tournament_id: int, player_ids: list[int], custom_name: str | None, session: Session):
    players = session.exec(select(Player).where(Player.id.in_(player_ids))).all()
    if not players:
        raise ValueError("Geen geldige spelers geselecteerd")

    if custom_name and custom_name.strip() != "":
        final_name = custom_name
    else:
        names = [p.last_name or p.first_name for p in players]
        final_name = " & ".join(names)

    team = Team(name=final_name, tournament_id=tournament_id)
    team.players = players
    session.add(team)
    session.commit()
    session.refresh(team)
    return team

def assign_referees(matches: List[Match], participants: List[Any], is_doubles: bool):
    """
    Assigns referees to a list of matches ensuring:
    1. Equal distribution (everyone refs same amount).
    2. Spacing (try not to ref immediately after playing).
    """
    if len(participants) < 3:
        return # Not enough people to have a referee

    # Track how many times each entity has refereed
    ref_counts = {p.id: 0 for p in participants}
    
    # Track the last match index where an entity was involved (playing or reffing)
    # Used to calculate 'rest' periods. Initialize to -1.
    last_active_index = {p.id: -1 for p in participants}

    for i, match in enumerate(matches):
        # 1. Identify who is playing
        if is_doubles:
            p1_id = match.team1_id
            p2_id = match.team2_id
        else:
            p1_id = match.player1_id
            p2_id = match.player2_id

        # Update activity for players (they are busy playing this match)
        if p1_id: last_active_index[p1_id] = i
        if p2_id: last_active_index[p2_id] = i

        # 2. Find Candidates (Everyone in poule NOT playing this match)
        candidates = [p for p in participants if p.id not in (p1_id, p2_id)]

        if not candidates:
            continue

        # 3. Scoring Algorithm
        # We want the candidate with the LOWEST ref_count.
        # Tie-breaker: The one who has been inactive the longest
        def get_score(candidate):
            count = ref_counts[candidate.id]
            
            # Calculate gap since last activity
            last_idx = last_active_index[candidate.id]
            gap = i - last_idx if last_idx != -1 else 999 
            
            # Score = (Count * 100) - Gap
            return (count * 100) - gap

        # Sort candidates by score (Lowest is best)
        candidates.sort(key=get_score)
        
        if not candidates:
            continue
            
        best_ref = candidates[0]

        # 4. Assign
        if is_doubles:
            match.referee_team_id = best_ref.id
        else:
            match.referee_id = best_ref.id

        # 5. Update Tracking
        ref_counts[best_ref.id] += 1
        last_active_index[best_ref.id] = i

==================================================
FILE: backend/app\services\__init__.py
==================================================



==================================================
FILE: frontend/src\App.tsx
==================================================

import { BrowserRouter, Routes, Route, Navigate } from 'react-router-dom';
import { AuthProvider } from './context/AuthContext';

// Auth Pages
import Login from './pages/auth/Login';
import Register from './pages/auth/Register';

// Admin Pages
import ManagePlayers from './pages/admin/ManagePlayers';
import CreateTournament from './pages/admin/CreateTournament';
import SystemLogs from './pages/admin/SystemLogs';
import ManageBoards from './pages/admin/ManageBoards';
import Dashboard from './pages/admin/Dashboard';
import ManageTournament from './pages/admin/ManageTournament'; 
import Changelog from './pages/admin/Changelog'; 
import ManageTeams from './pages/admin/ManageTeams';

// Public Pages
import TournamentView from './pages/public/TournamentView';
import Home from './pages/Home'; 
// Scorer Pages

import ScorerMatchList from './pages/scorer/MatchList';
import Scoreboard from './pages/scorer/Scoreboard';

function App() {
  return (
    <AuthProvider>
      <BrowserRouter>
        <Routes>
          {/* Default Route: Show Home instead of redirecting */}
          <Route path="/" element={<Home />} /> 

          {/* Auth Routes */}
          <Route path="/login" element={<Login />} />
          <Route path="/register" element={<Register />} />
          
          {/* Public Routes (No Login Required) */}
          <Route path="/t/:public_uuid" element={<TournamentView />} />

          {/* Admin Routes */}
          <Route path="/dashboard" element={<Dashboard />} />
          <Route path="/dashboard/tournament/:id" element={<ManageTournament />} />
          <Route path="/dashboard/players" element={<ManagePlayers />} />
          <Route path="/dashboard/teams" element={<ManageTeams />} />
          <Route path="/dashboard/create-tournament" element={<CreateTournament />} />
          <Route path="/dashboard/logs" element={<SystemLogs />} />
          <Route path="/dashboard/boards" element={<ManageBoards />} />
          <Route path="/dashboard/changelog" element={<Changelog />} />

          {/* Scorer Routes (Tablet View) */}
          <Route path="/board/:scorer_uuid" element={<ScorerMatchList />} />
          <Route path="/board/:scorer_uuid/match/:match_id" element={<Scoreboard />} />

          {/* Default Redirect */}
          <Route path="/" element={<Navigate to="/dashboard" replace />} />
        </Routes>
      </BrowserRouter>
    </AuthProvider>
  );
}

export default App;

==================================================
FILE: frontend/src\index.css
==================================================

@tailwind base;
@tailwind components;
@tailwind utilities;

==================================================
FILE: frontend/src\main.tsx
==================================================

import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App.tsx'
import './index.css'

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
)

==================================================
FILE: frontend/src\vite-env.d.ts
==================================================

/// <reference types="vite/client" />

// This tells TypeScript: "Hey, if I import something ending in .md?raw, 
// treat it as a plain string."
declare module '*.md?raw' {
  const content: string;
  export default content;
}

==================================================
FILE: frontend/src\components\layout\AdminLayout.tsx
==================================================

import { ReactNode, useState } from 'react';
import Sidebar from './Sidebar';
import { Menu } from 'lucide-react'; // Hamburger icoon

interface AdminLayoutProps {
  children: ReactNode;
}

const AdminLayout = ({ children }: AdminLayoutProps) => {
  const [isSidebarOpen, setIsSidebarOpen] = useState(false);

  return (
    <div className="flex h-screen bg-gray-100 overflow-hidden">
      {/* Sidebar Component (beheert zelf desktop/mobiel gedrag via CSS classes) */}
      <Sidebar isOpen={isSidebarOpen} onClose={() => setIsSidebarOpen(false)} />

      {/* Main Content Area */}
      <div className="flex-1 flex flex-col h-full w-full relative">
        
        {/* Mobile Header (Alleen zichtbaar op klein scherm) */}
        <header className="bg-white border-b border-gray-200 p-4 flex items-center gap-4 md:hidden shrink-0">
          <button 
            onClick={() => setIsSidebarOpen(true)}
            className="text-gray-600 hover:text-blue-600 p-1"
          >
            <Menu size={24} />
          </button>
          <span className="font-bold text-gray-800">Dart Manager</span>
        </header>

        {/* Scrollable Content */}
        {/* We veranderen p-8 naar p-4 op mobiel (md:p-8) voor meer ruimte */}
        <main className="flex-1 overflow-auto p-4 md:p-8 w-full">
          {children}
        </main>
      </div>
    </div>
  );
};

export default AdminLayout;

==================================================
FILE: frontend/src\components\layout\Sidebar.tsx
==================================================

import { Link, useLocation, useNavigate } from 'react-router-dom';
import { useAuth } from '../../hooks/useAuth';
import { LayoutDashboard, Users, Trophy, LogOut, Activity, Target, FileText, X, Shield } from 'lucide-react';

interface SidebarProps {
  isOpen: boolean;
  onClose: () => void;
}

const Sidebar = ({ isOpen, onClose }: SidebarProps) => {
  const { logout, user } = useAuth();
  const navigate = useNavigate();
  const location = useLocation();

  const handleLogout = () => {
    logout();
    navigate('/login');
  };

  const menuItems = [
    { icon: LayoutDashboard, label: 'Dashboard', path: '/dashboard' },
    { icon: Users, label: 'Manage Players', path: '/dashboard/players' },
    { icon: Shield, label: 'Manage Teams', path: '/dashboard/teams' },
    { icon: Target, label: 'Manage Boards', path: '/dashboard/boards' },
    { icon: Trophy, label: 'Create Tournament', path: '/dashboard/create-tournament' },
    { icon: Activity, label: 'System Logs', path: '/dashboard/logs' },
    { icon: FileText, label: 'Changelog', path: '/dashboard/changelog' },
  ];

  return (
    <>
      {/* 1. Mobile Overlay (Alleen zichtbaar als menu open is op mobiel) */}
      {isOpen && (
        <div 
          className="fixed inset-0 bg-black bg-opacity-50 z-20 md:hidden"
          onClick={onClose}
        />
      )}

      {/* 2. De Sidebar zelf */}
      <div className={`
        fixed md:static inset-y-0 left-0 z-30
        w-64 bg-slate-900 text-white flex flex-col min-h-screen shadow-xl
        transition-transform duration-300 ease-in-out
        ${isOpen ? 'translate-x-0' : '-translate-x-full md:translate-x-0'}
      `}>
        <div className="p-6 border-b border-slate-700 flex justify-between items-center">
          <div>
            <h1 className="text-2xl font-bold text-blue-400">Dart Manager</h1>
            <p className="text-xs text-slate-400 mt-1">
               Logged in as: {user?.first_name || 'Admin'}
            </p>
          </div>
          {/* Sluit knop (Alleen mobiel) */}
          <button onClick={onClose} className="md:hidden text-slate-400 hover:text-white">
            <X size={24} />
          </button>
        </div>

        <nav className="flex-1 p-4 overflow-y-auto">
          <ul className="space-y-2">
            {menuItems.map((item) => {
              const Icon = item.icon;
              const isActive = location.pathname === item.path;
              return (
                <li key={item.path}>
                  <Link
                    to={item.path}
                    onClick={() => onClose()} // Sluit menu na klik op mobiel
                    className={`flex items-center space-x-3 p-3 rounded-lg transition-colors ${
                      isActive 
                        ? 'bg-blue-600 text-white' 
                        : 'text-slate-300 hover:bg-slate-800'
                    }`}
                  >
                    <Icon size={20} />
                    <span>{item.label}</span>
                  </Link>
                </li>
              );
            })}
          </ul>
        </nav>

        <div className="p-4 border-t border-slate-700">
          <button
            onClick={handleLogout}
            className="flex items-center space-x-3 text-red-400 hover:text-red-300 w-full p-3 hover:bg-slate-800 rounded-lg transition-colors"
          >
            <LogOut size={20} />
            <span>Sign Out</span>
          </button>
        </div>
      </div>
    </>
  );
};

export default Sidebar;

==================================================
FILE: frontend/src\context\AuthContext.tsx
==================================================

import { createContext, useState, useEffect, ReactNode } from 'react';
import api from '../services/api';
// IMPORT the correct User type from your central types file
import { User } from '../types'; 

interface AuthContextType {
  user: User | null;
  login: (token: string) => void;
  logout: () => void;
  isLoading: boolean;
}

export const AuthContext = createContext<AuthContextType | null>(null);

export const AuthProvider = ({ children }: { children: ReactNode }) => {
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    const initAuth = async () => {
      const token = localStorage.getItem('token');
      if (token) {
        try {
          const response = await api.get('/users/me');
          setUser(response.data);
        } catch (error) {
          console.error("Token invalid", error);
          localStorage.removeItem('token');
        }
      }
      setIsLoading(false);
    };
    initAuth();
  }, []);

  const login = async (token: string) => {
    localStorage.setItem('token', token);
    try {
      const response = await api.get('/users/me');
      setUser(response.data);
    } catch (error) {
      console.error("Login failed fetching user", error);
    }
  };

  const logout = () => {
    localStorage.removeItem('token');
    setUser(null);
  };

  return (
    <AuthContext.Provider value={{ user, login, logout, isLoading }}>
      {children}
    </AuthContext.Provider>
  );
};

==================================================
FILE: frontend/src\hooks\useAuth.ts
==================================================

import { useContext } from 'react';
import { AuthContext } from '../context/AuthContext';

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};

==================================================
FILE: frontend/src\hooks\useWebSocket.ts
==================================================



==================================================
FILE: frontend/src\pages\Home.tsx
==================================================

import { Link } from 'react-router-dom';
import { Trophy, Target, Users, BarChart3, ArrowRight, Play } from 'lucide-react';

const Home = () => {
  return (
    <div className="min-h-screen bg-white flex flex-col">
      {/* --- NAVIGATION --- */}
      <nav className="border-b border-gray-100 bg-white sticky top-0 z-50">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 h-16 flex justify-between items-center">
          <div className="flex items-center gap-2">
            <Trophy className="text-blue-600 h-8 w-8" />
            <span className="font-bold text-xl text-gray-900 tracking-tight">Dart Manager</span>
          </div>
            <div className="flex items-center gap-2 md:gap-4">
            <Link to="/login" className="text-gray-600 hover:text-blue-600 font-medium transition text-sm md:text-base">
                Sign In
            </Link>
            <Link 
                to="/register" 
                className="bg-blue-600 text-white px-3 py-2 md:px-5 md:py-2 rounded-lg font-bold hover:bg-blue-700 transition shadow-sm text-sm md:text-base"
            >
                Get Started
            </Link>
            </div>
        </div>
      </nav>

      {/* --- HERO SECTION --- */}
      <div className="bg-gradient-to-b from-blue-50 to-white pt-20 pb-32">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 text-center">
          <h1 className="text-5xl md:text-6xl font-extrabold text-slate-900 mb-6 tracking-tight">
            Manage your Dart Tournaments <br />
            <span className="text-blue-600">Like a Pro.</span>
          </h1>
          <p className="text-xl text-gray-500 mb-10 max-w-2xl mx-auto leading-relaxed">
            Create tournaments, manage players, and track live scores with ease. 
            The all-in-one solution for your local dart club.
          </p>
          <div className="flex justify-center gap-4">
            <Link 
              to="/register" 
              className="flex items-center gap-2 bg-blue-600 text-white px-8 py-4 rounded-xl font-bold text-lg hover:bg-blue-700 transition shadow-lg hover:shadow-xl transform hover:-translate-y-1"
            >
              Start for Free <ArrowRight size={20} />
            </Link>
            <Link 
              to="/login" 
              className="flex items-center gap-2 bg-white text-gray-700 border border-gray-200 px-8 py-4 rounded-xl font-bold text-lg hover:bg-gray-50 transition shadow-sm"
            >
              <Play size={20} className="text-gray-400" /> Demo View
            </Link>
          </div>
        </div>
      </div>

      {/* --- FEATURES GRID --- */}
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 -mt-20 mb-24">
        <div className="grid md:grid-cols-3 gap-8">
          {/* Card 1 */}
          <div className="bg-white p-8 rounded-2xl shadow-xl border border-gray-100 hover:border-blue-200 transition">
            <div className="bg-blue-100 w-12 h-12 rounded-xl flex items-center justify-center mb-6">
              <Target className="text-blue-600" size={24} />
            </div>
            <h3 className="text-xl font-bold text-gray-900 mb-3">Live Scoring</h3>
            <p className="text-gray-500 leading-relaxed">
              Use our tablet-friendly scorer interface to track matches in real-time. Scores update instantly across all devices.
            </p>
          </div>

          {/* Card 2 */}
          <div className="bg-white p-8 rounded-2xl shadow-xl border border-gray-100 hover:border-blue-200 transition">
            <div className="bg-green-100 w-12 h-12 rounded-xl flex items-center justify-center mb-6">
              <BarChart3 className="text-green-600" size={24} />
            </div>
            <h3 className="text-xl font-bold text-gray-900 mb-3">Automated Brackets</h3>
            <p className="text-gray-500 leading-relaxed">
              Run Poules, Knockouts, or Hybrid formats. We automatically calculate standings and generate the bracket.
            </p>
          </div>

          {/* Card 3 */}
          <div className="bg-white p-8 rounded-2xl shadow-xl border border-gray-100 hover:border-blue-200 transition">
            <div className="bg-purple-100 w-12 h-12 rounded-xl flex items-center justify-center mb-6">
              <Users className="text-purple-600" size={24} />
            </div>
            <h3 className="text-xl font-bold text-gray-900 mb-3">Player Management</h3>
            <p className="text-gray-500 leading-relaxed">
              Keep a database of all your players, track their stats, and easily add them to new tournaments.
            </p>
          </div>
        </div>
      </div>

      {/* --- FOOTER --- */}
      <footer className="mt-auto bg-slate-900 text-slate-400 py-12">
        <div className="max-w-7xl mx-auto px-4 text-center">
          <Trophy className="mx-auto h-8 w-8 text-gray-600 mb-4" />
          <p>&copy; {new Date().getFullYear()} Dart Tournament Manager. Built for the love of the game.</p>
        </div>
      </footer>
    </div>
  );
};

export default Home;

==================================================
FILE: frontend/src\pages\SystemLogs.tsx
==================================================



==================================================
FILE: frontend/src\pages\admin\Changelog.tsx
==================================================

import React, { useEffect, useState } from 'react';
import api from '../../services/api';
import AdminLayout from '../../components/layout/AdminLayout';
import { Tag, Calendar, AlertCircle, Wrench, Sparkles, GitCommit, Loader2 } from 'lucide-react';

type ChangeType = 'feat' | 'fix' | 'chore' | 'refactor' | 'docs' | 'perf' | 'revert' | 'unknown';

interface Change {
  type: ChangeType;
  text: string;
  hash?: string; 
  link?: string; 
}

interface Release {
  version: string;
  date: string;
  description?: string;
  changes: Change[];
}

const ChangeBadge = ({ type }: { type: string }) => {
  switch (type) {
    case 'feat':
      return <span className="px-2 py-0.5 rounded text-[10px] font-bold bg-green-100 text-green-700 uppercase tracking-wide border border-green-200">Feat</span>;
    case 'fix':
      return <span className="px-2 py-0.5 rounded text-[10px] font-bold bg-red-100 text-red-700 uppercase tracking-wide border border-red-200">Fix</span>;
    case 'docs':
      return <span className="px-2 py-0.5 rounded text-[10px] font-bold bg-yellow-100 text-yellow-700 uppercase tracking-wide border border-yellow-200">Docs</span>;
    default:
      return <span className="px-2 py-0.5 rounded text-[10px] font-bold bg-gray-100 text-gray-600 uppercase tracking-wide border border-gray-200">{type}</span>;
  }
};

const Changelog = () => {
  const [releases, setReleases] = useState<Release[]>([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    api.get('/system/changelog')
       .then(res => setReleases(res.data))
       .catch(err => console.error(err))
       .finally(() => setLoading(false));
  }, []);

  return (
    <AdminLayout>
      <div className="max-w-5xl mx-auto py-8 px-4 sm:px-6 lg:px-8">
        
        <div className="mb-10 border-b pb-6">
          <h1 className="text-3xl font-bold text-gray-900">Project Geschiedenis</h1>
          <p className="text-gray-500 mt-2">Een overzicht van alle updates, verbeteringen en fixes.</p>
        </div>

        {loading ? (
            <div className="flex justify-center py-20"><Loader2 className="animate-spin text-blue-600" size={32} /></div>
        ) : (
            <div className="space-y-8 relative before:absolute before:inset-0 before:ml-5 before:-translate-x-px md:before:mx-auto md:before:translate-x-0 before:h-full before:w-0.5 before:bg-gradient-to-b before:from-transparent before:via-gray-300 before:to-transparent">
            
            {releases.map((release, index) => (
                <div key={index} className="relative flex items-center justify-between md:justify-normal md:odd:flex-row-reverse group is-active">
                    
                    {/* ICON BOLLETJE */}
                    <div className="flex items-center justify-center w-10 h-10 rounded-full border-4 border-white bg-gray-100 group-hover:bg-blue-500 group-hover:text-white text-gray-500 shadow shrink-0 md:order-1 md:group-odd:-translate-x-1/2 md:group-even:translate-x-1/2 transition-colors">
                        <Tag size={18} />
                    </div>
                    
                    {/* KAARTJE */}
                    <div className="w-[calc(100%-4rem)] md:w-[calc(50%-2.5rem)] bg-white p-6 rounded-xl border border-gray-200 shadow-sm hover:shadow-md transition-all">
                        
                        {/* HEADER VAN DE KAART */}
                        <div className="flex items-center justify-between mb-4">
                            <h3 className="font-bold text-gray-800 text-lg flex items-center gap-2">
                                v{release.version}
                            </h3>
                            <time className="font-mono text-xs text-gray-400 flex items-center gap-1">
                                <Calendar size={12}/> {release.date}
                            </time>
                        </div>

                        {/* LIJST MET CHANGES */}
                        <ul className="space-y-3">
                            {release.changes.map((change, i) => (
                                <li key={i} className="text-sm text-gray-600 flex items-start gap-3">
                                    <div className="shrink-0 mt-0.5">
                                        <ChangeBadge type={change.type} />
                                    </div>
                                    <div className="flex-1 leading-relaxed">
                                        {change.text}
                                    </div>
                                    {change.hash && (
                                        <a href={change.link || "#"} target="_blank" rel="noreferrer" className="shrink-0 text-[10px] font-mono text-gray-400 hover:text-blue-500 flex items-center mt-0.5">
                                            <GitCommit size={10} className="mr-0.5"/> {change.hash.substring(0,6)}
                                        </a>
                                    )}
                                </li>
                            ))}
                        </ul>
                    </div>
                </div>
            ))}
            </div>
        )}
      </div>
    </AdminLayout>
  );
};

export default Changelog;

==================================================
FILE: frontend/src\pages\admin\CreateTournament.tsx
==================================================

import { useEffect, useState } from 'react';
import { useNavigate } from 'react-router-dom';
import api from '../../services/api';
import AdminLayout from '../../components/layout/AdminLayout';
import { Player, Dartboard } from '../../types';
import { 
    Trophy, Users, Target, Scissors, Shuffle, UserPlus, 
    Save, Shield, Plus, X, ArrowRight, ArrowLeft, Dna, AlertTriangle 
} from 'lucide-react';

// --- TYPES ---
interface GlobalTeam {
    id: number;
    name: string;
    players: Player[];
}

interface CartItem {
    id: string; 
    type: 'existing_team' | 'new_team' | 'single_player';
    name: string;
    players: Player[];      
    teamId?: number;        
}

// --- STYLING ---
const LABEL_STYLE = "block text-xs font-bold text-gray-500 uppercase mb-1";
const INPUT_STYLE = "w-full border border-gray-300 rounded-md p-2 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 transition-all shadow-sm";
const TAB_active = "border-b-2 border-blue-600 text-blue-600 bg-blue-50";
const TAB_inactive = "text-gray-500 hover:text-gray-700 hover:bg-gray-50";

const CreateTournament = () => {
    const navigate = useNavigate();

    // --- STATE ---
    const [step, setStep] = useState<1 | 2 | 3>(1); 
    const [loading, setLoading] = useState(true);

    // Data
    const [allPlayers, setAllPlayers] = useState<Player[]>([]);
    const [allBoards, setAllBoards] = useState<Dartboard[]>([]);
    const [globalTeams, setGlobalTeams] = useState<GlobalTeam[]>([]);

    // Step 1: Mode
    const [participationMode, setParticipationMode] = useState<'singles' | 'doubles'>('doubles'); 

    // Step 2: Participants (Cart)
    const [cart, setCart] = useState<CartItem[]>([]);
    const [activeTab, setActiveTab] = useState<'teams' | 'players'>('teams'); 
    const [manualSelection, setManualSelection] = useState<number[]>([]); 
    const [manualTeamName, setManualTeamName] = useState("");

    // Step 3: Settings
    const defaultName = `Toernooi ${new Date().toLocaleDateString('nl-NL')}`;
    const [name, setName] = useState(defaultName);
    const [date, setDate] = useState(new Date().toISOString().split('T')[0]);
    const [format, setFormat] = useState('hybrid');
    const [poules, setPoules] = useState(1);
    const [qualifiersPerPoule, setQualifiersPerPoule] = useState(2);
    const [allowByes, setAllowByes] = useState(false); // Standaard UIT
    const [groupLegs, setGroupLegs] = useState(3);
    const [koLegs, setKoLegs] = useState(3);
    const [sets, setSets] = useState(1);
    const [selectedBoardIds, setSelectedBoardIds] = useState<number[]>([]);

    // --- LOAD DATA ---
    useEffect(() => {
        const fetchData = async () => {
            try {
                const [pRes, bRes, tRes] = await Promise.all([
                    api.get('/players/'),
                    api.get('/dartboards/'),
                    api.get('/teams/') 
                ]);
                setAllPlayers(pRes.data);
                setAllBoards(bRes.data);
                setGlobalTeams(tRes.data);
                
                // Selecteer standaard alle borden als suggestie
                if (bRes.data.length > 0) {
                    setSelectedBoardIds(bRes.data.map((b: Dartboard) => b.id));
                }
            } catch (err) {
                console.error(err);
            } finally {
                setLoading(false);
            }
        };
        fetchData();
    }, []);

    // --- LOGIC: AUTO-CALCULATE SETTINGS (De "Regels") ---
    useEffect(() => {
        if (step !== 3) return;

        const count = cart.length;
        if (count < 2) return;

        // REGEL 1: Max 7 spelers in 1 poule
        // 7 spelers = 1 poule. 8 spelers = 2 poules. 15 spelers = 3 poules.
        let suggestedPoules = Math.ceil(count / 7);
        if (suggestedPoules < 1) suggestedPoules = 1;

        // REGEL 2 & 3: Knockout & Byes
        let suggestedQualifiers = 1;

        if (allowByes) {
            // REGEL: "Iedereen door naar knockout"
            // We zetten qualifiers zo hoog dat iedereen in de grootste poule doorgaat.
            // Gemiddeld aantal spelers per poule (naar boven afgerond)
            suggestedQualifiers = Math.ceil(count / suggestedPoules);
        } else {
            // REGEL: "Byes uit -> Hoogst mogelijke macht van 2"
            // Zoek grootste macht van 2 <= totaal aantal deelnemers
            let targetKO = 1;
            while (targetKO * 2 <= count) {
                targetKO *= 2;
            }
            
            // Verdeel deze plekken over de poules
            // Bijv: 8 plekken / 2 poules = 4 per poule.
            // Bijv: 4 plekken / 1 poule = 4 per poule.
            suggestedQualifiers = Math.floor(targetKO / suggestedPoules);
        }

        if (suggestedQualifiers < 1) suggestedQualifiers = 1;

        // Apply settings (alleen bij initial load van stap 3 of toggle van allowByes)
        setPoules(suggestedPoules);
        setQualifiersPerPoule(suggestedQualifiers);

    }, [step, allowByes, cart.length]); // Herberekenen als Step, Byes of Aantal deelnemers wijzigt


    // --- ACTIONS: CART ---
    const isPlayerInCart = (playerId: number) => {
        return cart.some(item => item.players.some(p => p.id === playerId));
    };

    const addGlobalTeamToCart = (team: GlobalTeam) => {
        const conflict = team.players.find(p => isPlayerInCart(p.id));
        if (conflict) return alert(`${conflict.name} zit al in het toernooi!`);
        setCart(prev => [...prev, {
            id: `existing-${team.id}`, type: 'existing_team', name: team.name, players: team.players, teamId: team.id
        }]);
    };

    const createAdHocTeam = () => {
        if (manualSelection.length !== 2) return;
        const p1 = allPlayers.find(p => p.id === manualSelection[0]);
        const p2 = allPlayers.find(p => p.id === manualSelection[1]);
        if (!p1 || !p2) return;
        const teamName = manualTeamName.trim() || `${p1.first_name} & ${p2.first_name}`;
        setCart(prev => [...prev, {
            id: `new-${Date.now()}`, type: 'new_team', name: teamName, players: [p1, p2]
        }]);
        setManualSelection([]);
        setManualTeamName("");
    };

    const toggleSinglePlayerInCart = (player: Player) => {
        if (isPlayerInCart(player.id)) {
            setCart(prev => prev.filter(item => item.players[0].id !== player.id));
        } else {
            setCart(prev => [...prev, {
                id: `single-${player.id}`, type: 'single_player', name: player.name, players: [player]
            }]);
        }
    };

    const removeFromCart = (itemId: string) => setCart(prev => prev.filter(x => x.id !== itemId));

    const toggleManualSelection = (id: number) => {
        if (isPlayerInCart(id)) return; 
        setManualSelection(prev => {
            if (prev.includes(id)) return prev.filter(p => p !== id);
            if (prev.length >= 2) return prev; 
            return [...prev, id];
        });
    };

    const toggleBoard = (id: number) => setSelectedBoardIds(prev => prev.includes(id) ? prev.filter(b => b !== id) : [...prev, id]);

    // --- RANDOM GENERATOR ---
    const generateRandomTeams = () => {
        const usedIds = new Set<number>();
        cart.forEach(item => item.players.forEach(p => usedIds.add(p.id)));
        let available = allPlayers.filter(p => !usedIds.has(p.id));
        
        if (available.length < 2) return alert("Te weinig beschikbare spelers over.");

        available = available.sort(() => Math.random() - 0.5);

        const newItems: CartItem[] = [];
        for (let i = 0; i < available.length - 1; i += 2) {
             const p1 = available[i];
             const p2 = available[i+1];
             newItems.push({
                 id: `random-${Date.now()}-${i}`,
                 type: 'new_team',
                 name: `${p1.first_name} & ${p2.first_name}`,
                 players: [p1, p2]
             });
        }
        setCart(prev => [...prev, ...newItems]);
        if (available.length % 2 !== 0) alert(`Teams gegenereerd! 1 speler (${available[available.length-1].name}) is overgebleven.`);
    };


    // --- SUBMIT ---
    const handleStartTournament = async () => {
        if (selectedBoardIds.length < poules) {
            if (!confirm(`LET OP: Je hebt ${poules} poules maar slechts ${selectedBoardIds.length} borden. Elke poule zou idealiter zijn eigen bord moeten hebben. Wil je toch doorgaan?`)) {
                return;
            }
        }

        setLoading(true);
        try {
            const allPlayerIds = new Set<number>();
            cart.forEach(item => item.players.forEach(p => allPlayerIds.add(p.id)));

            const payload = {
                name: name.trim() === "" ? defaultName : name,
                date, format, mode: participationMode, allow_byes: allowByes,
                number_of_poules: poules, qualifiers_per_poule: qualifiersPerPoule,
                starting_legs_group: groupLegs, starting_legs_ko: koLegs, sets_per_match: sets,
                board_ids: selectedBoardIds,
                player_ids: Array.from(allPlayerIds)
            };
            
            const res = await api.post('/tournaments/', payload);
            const tournamentId = res.data.id;

            if (participationMode === 'doubles') {
                const existingIds = cart.filter(c => c.type === 'existing_team').map(c => c.teamId as number);
                if (existingIds.length > 0) {
                    await api.post('/teams/link', { tournament_id: tournamentId, team_ids: existingIds });
                }
                const newTeams = cart.filter(c => c.type === 'new_team');
                for (const newItem of newTeams) {
                    await api.post('/teams/manual', {
                        tournament_id: tournamentId,
                        player_ids: newItem.players.map(p => p.id),
                        name: newItem.name
                    });
                }
                await api.post(`/tournaments/${tournamentId}/finalize`);
            } 
            navigate(`/dashboard/tournament/${tournamentId}`);

        } catch (err: any) {
            console.error(err);
            alert("Error: " + (err.response?.data?.detail || err.message));
        } finally {
            setLoading(false);
        }
    };

    // Helper voor statistieken
    const getCalculatedStats = () => {
        const total = cart.length;
        const avgPerPoule = poules > 0 ? (total / poules).toFixed(1) : 0;
        const totalQualifiers = poules * qualifiersPerPoule;
        
        let bracketSize = 1;
        while (bracketSize < totalQualifiers) bracketSize *= 2;

        return { total, avgPerPoule, totalQualifiers, bracketSize };
    };
    const stats = getCalculatedStats();

    return (
        <AdminLayout>
            <div className="max-w-6xl mx-auto pb-20">
                
                {/* --- HEADER --- */}
                <div className="mb-8">
                    <h2 className="text-3xl font-bold text-gray-800 flex items-center gap-2">
                        {step === 1 && <Dna className="text-purple-500" />}
                        {step === 2 && <Users className="text-blue-500" />}
                        {step === 3 && <Target className="text-red-500" />}
                        {step === 1 ? "Stap 1: Kies Modus" : step === 2 ? "Stap 2: Deelnemers" : "Stap 3: Instellingen"}
                    </h2>
                    <div className="w-full bg-gray-200 h-2 rounded-full mt-4 flex">
                        <div className={`h-full rounded-full transition-all duration-300 ${step >= 1 ? 'bg-purple-500 w-1/3' : ''}`}></div>
                        <div className={`h-full rounded-full transition-all duration-300 ${step >= 2 ? 'bg-blue-500 w-1/3' : ''}`}></div>
                        <div className={`h-full rounded-full transition-all duration-300 ${step >= 3 ? 'bg-red-500 w-1/3' : ''}`}></div>
                    </div>
                </div>

                {/* --- STEP 1: MODE --- */}
                {step === 1 && (
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-6 animate-fade-in">
                        <div onClick={() => { setParticipationMode('singles'); setStep(2); setCart([]); }} className="bg-white p-10 rounded-xl shadow-sm border-2 border-transparent hover:border-blue-500 cursor-pointer transition flex flex-col items-center text-center group">
                            <div className="bg-blue-100 p-4 rounded-full mb-4 group-hover:scale-110 transition"><Users size={48} className="text-blue-600"/></div>
                            <h3 className="text-2xl font-bold text-gray-800">1 vs 1 (Singles)</h3>
                            <p className="text-gray-500 mt-2">Iedereen speelt voor zichzelf.</p>
                        </div>
                        <div onClick={() => { setParticipationMode('doubles'); setStep(2); setCart([]); }} className="bg-white p-10 rounded-xl shadow-sm border-2 border-transparent hover:border-purple-500 cursor-pointer transition flex flex-col items-center text-center group">
                            <div className="bg-purple-100 p-4 rounded-full mb-4 group-hover:scale-110 transition"><Scissors size={48} className="text-purple-600"/></div>
                            <h3 className="text-2xl font-bold text-gray-800">Koppels (2 vs 2)</h3>
                            <p className="text-gray-500 mt-2">Kies vaste teams of maak random duo's.</p>
                        </div>
                    </div>
                )}

                {/* --- STEP 2: DEELNEMERS --- */}
                {step === 2 && (
                    <div className="grid grid-cols-1 lg:grid-cols-12 gap-6 animate-fade-in">
                        <div className="lg:col-span-7 flex flex-col h-[600px]">
                            <div className="bg-white rounded-lg shadow-sm border border-gray-200 flex-1 flex flex-col overflow-hidden">
                                {participationMode === 'doubles' ? (
                                    <div className="flex border-b bg-gray-50">
                                        <button onClick={() => setActiveTab('teams')} className={`flex-1 py-3 text-sm font-bold flex items-center justify-center gap-2 ${activeTab==='teams' ? TAB_active : TAB_inactive}`}><Shield size={16}/> Bestaande Teams</button>
                                        <button onClick={() => setActiveTab('players')} className={`flex-1 py-3 text-sm font-bold flex items-center justify-center gap-2 ${activeTab==='players' ? TAB_active : TAB_inactive}`}><UserPlus size={16}/> Nieuw / Random</button>
                                    </div>
                                ) : (
                                    <div className="p-3 bg-gray-50 border-b font-bold text-gray-700 flex items-center gap-2"><Users size={16}/> Klik op spelers om toe te voegen</div>
                                )}

                                <div className="flex-1 overflow-y-auto p-4 custom-scrollbar bg-white">
                                    {/* ... INHOUD VAN TABS (Doubles/Singles) ... */}
                                    {participationMode === 'doubles' && activeTab === 'teams' && (
                                        <div className="space-y-2">
                                            {globalTeams.map(team => {
                                                const disabled = team.players.some(p => isPlayerInCart(p.id));
                                                const alreadyIn = cart.some(c => c.teamId === team.id);
                                                return (
                                                    <div key={team.id} className={`flex justify-between items-center p-3 rounded border ${disabled ? 'opacity-50 bg-gray-50' : 'hover:border-blue-400 bg-white'}`}>
                                                        <div><div className="font-bold text-gray-800">{team.name}</div><div className="text-xs text-gray-500">{team.players.map(p => p.name).join(' & ')}</div></div>
                                                        <button onClick={() => addGlobalTeamToCart(team)} disabled={disabled} className={`p-2 rounded-full ${alreadyIn ? 'text-green-600' : 'bg-blue-100 text-blue-600'}`}>{alreadyIn ? <Save size={20}/> : <Plus size={20}/>}</button>
                                                    </div>
                                                )
                                            })}
                                        </div>
                                    )}

                                    {participationMode === 'doubles' && activeTab === 'players' && (
                                        <div className="space-y-6">
                                            <div className="bg-purple-50 p-4 rounded border border-purple-100">
                                                <h4 className="font-bold text-purple-800 text-sm mb-2 flex items-center gap-2"><Shuffle size={16}/> Random Vullling</h4>
                                                <button onClick={generateRandomTeams} className="w-full bg-white border border-purple-300 text-purple-700 font-bold py-2 rounded hover:bg-purple-100 text-sm">Genereer Random Teams</button>
                                            </div>
                                            <div>
                                                <h4 className="font-bold text-gray-700 text-sm mb-2">Handmatig Samenstellen</h4>
                                                <div className="flex gap-2 mb-2">
                                                    <input type="text" className={INPUT_STYLE} placeholder="Team naam" value={manualTeamName} onChange={e => setManualTeamName(e.target.value)} />
                                                    <button onClick={createAdHocTeam} disabled={manualSelection.length !== 2} className="bg-green-600 text-white px-4 rounded font-bold disabled:opacity-50"><Plus size={20}/></button>
                                                </div>
                                                <div className="grid grid-cols-2 gap-2 max-h-60 overflow-y-auto">
                                                    {allPlayers.map(p => {
                                                        const taken = isPlayerInCart(p.id);
                                                        const selected = manualSelection.includes(p.id);
                                                        return <div key={p.id} onClick={() => toggleManualSelection(p.id)} className={`p-2 rounded border text-sm cursor-pointer truncate ${taken ? 'opacity-40' : selected ? 'bg-blue-100 border-blue-500 font-bold' : 'hover:bg-gray-50'}`}>{p.name}</div>
                                                    })}
                                                </div>
                                            </div>
                                        </div>
                                    )}

                                    {participationMode === 'singles' && (
                                        <div className="grid grid-cols-2 sm:grid-cols-3 gap-2">
                                            {allPlayers.map(p => {
                                                const inCart = isPlayerInCart(p.id);
                                                return <div key={p.id} onClick={() => toggleSinglePlayerInCart(p)} className={`p-2 rounded border text-sm cursor-pointer flex justify-between ${inCart ? 'bg-green-50 border-green-500 font-bold' : 'hover:bg-gray-50'}`}><span className="truncate">{p.name}</span>{inCart && <div className="w-2 h-2 rounded-full bg-green-500 mt-1.5"></div>}</div>
                                            })}
                                        </div>
                                    )}
                                </div>
                            </div>
                        </div>

                        {/* WINKELMANDJE RECHTS */}
                        <div className="lg:col-span-5 flex flex-col h-[600px]">
                            <div className="bg-white rounded-lg shadow-xl border border-blue-100 flex-1 flex flex-col overflow-hidden">
                                <div className="bg-slate-800 text-white p-4 flex justify-between items-center">
                                    <h3 className="font-bold flex items-center gap-2"><Trophy size={18} className="text-yellow-400"/> Deelnemers</h3>
                                    <span className="bg-blue-600 px-3 py-1 rounded-full text-xs font-bold">{cart.length}</span>
                                </div>
                                <div className="flex-1 overflow-y-auto p-4 space-y-2 bg-gray-50">
                                    {cart.length === 0 && <div className="text-center text-gray-400 mt-20">Nog niemand geselecteerd.</div>}
                                    {cart.map(item => (
                                        <div key={item.id} className="bg-white p-2 rounded border flex justify-between items-center text-sm">
                                            <div><div className="font-bold text-gray-800">{item.name}{item.type === 'new_team' && <span className="text-[10px] bg-purple-100 text-purple-600 px-1 ml-2 rounded">NIEUW</span>}</div></div>
                                            <button onClick={() => removeFromCart(item.id)} className="text-gray-300 hover:text-red-500"><X size={18}/></button>
                                        </div>
                                    ))}
                                </div>
                                <div className="p-4 bg-white border-t border-gray-200 flex gap-2">
                                    <button onClick={() => setStep(1)} className="px-4 py-3 rounded-lg border text-gray-600 font-bold hover:bg-gray-50"><ArrowLeft size={20}/></button>
                                    <button onClick={() => setStep(3)} disabled={cart.length < 2} className="flex-1 bg-blue-600 text-white font-bold py-3 rounded-lg hover:bg-blue-700 flex justify-center items-center gap-2 disabled:opacity-50">Naar Instellingen <ArrowRight size={20}/></button>
                                </div>
                            </div>
                        </div>
                    </div>
                )}

                {/* --- STEP 3: SETTINGS --- */}
                {step === 3 && (
                    <div className="grid grid-cols-1 lg:grid-cols-12 gap-6 animate-fade-in">
                        <div className="lg:col-span-8 space-y-6">
                            
                            {/* STATS CARD */}
                            <div className="bg-blue-50 border border-blue-100 p-4 rounded-lg flex flex-wrap gap-6 items-center">
                                <div><span className="block text-xs font-bold text-blue-400 uppercase">Deelnemers</span><span className="text-xl font-bold text-blue-900">{stats.total}</span></div>
                                <div><span className="block text-xs font-bold text-blue-400 uppercase">Spelers per Poule</span><span className="text-xl font-bold text-blue-900">~{stats.avgPerPoule}</span></div>
                                <div><span className="block text-xs font-bold text-blue-400 uppercase">Naar Knockout</span><span className="text-xl font-bold text-blue-900">{stats.totalQualifiers}</span></div>
                                <div className="ml-auto bg-white px-3 py-1 rounded shadow-sm"><span className="block text-xs font-bold text-gray-400 uppercase">Bracket Maat</span><span className="text-lg font-bold text-gray-700">Laatste {stats.bracketSize}</span></div>
                            </div>

                            {/* WARNING BORDEN */}
                            {selectedBoardIds.length < poules && (
                                <div className="bg-yellow-50 border border-yellow-200 text-yellow-800 p-4 rounded-lg flex items-start gap-3">
                                    <AlertTriangle className="shrink-0 mt-0.5" />
                                    <div>
                                        <p className="font-bold text-sm">Let op: Te weinig borden</p>
                                        <p className="text-xs mt-1">Je hebt {poules} poules, maar slechts {selectedBoardIds.length} borden geselecteerd. Het advies is minimaal 1 bord per poule.</p>
                                    </div>
                                </div>
                            )}

                            <div className="bg-white p-6 rounded-lg shadow-sm border border-gray-200">
                                <h3 className="font-bold text-gray-700 mb-4 border-b pb-2">Algemeen</h3>
                                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                    <div><label className={LABEL_STYLE}>Naam</label><input type="text" className={INPUT_STYLE} value={name} onChange={e => setName(e.target.value)} placeholder={defaultName} /></div>
                                    <div><label className={LABEL_STYLE}>Datum</label><input type="date" className={INPUT_STYLE} value={date} onChange={e => setDate(e.target.value)} /></div>
                                </div>
                            </div>

                            <div className="bg-white p-6 rounded-lg shadow-sm border border-gray-200">
                                <h3 className="font-bold text-gray-700 mb-4 border-b pb-2">Format</h3>
                                <div className="space-y-4">
                                    <select className={INPUT_STYLE} value={format} onChange={e => setFormat(e.target.value)}>
                                        <option value="hybrid">Hybride (Poules + Knockout)</option>
                                        <option value="knockout">Direct Knockout</option>
                                        <option value="round_robin">Alleen Poules</option>
                                    </select>
                                    
                                    {format === 'hybrid' && (
                                        <div className="grid grid-cols-2 gap-4 bg-gray-50 p-4 rounded border">
                                            <div><label className={LABEL_STYLE}>Aantal Poules</label><input type="number" min="1" max={cart.length} className={INPUT_STYLE} value={poules} onChange={e => setPoules(parseInt(e.target.value))} /></div>
                                            <div><label className={LABEL_STYLE}>Qualifiers per Poule</label><input type="number" min="1" className={INPUT_STYLE} value={qualifiersPerPoule} onChange={e => setQualifiersPerPoule(parseInt(e.target.value))} /></div>
                                        </div>
                                    )}
                                    <div className="flex items-center gap-2 p-2 rounded hover:bg-gray-50 transition cursor-pointer" onClick={() => setAllowByes(!allowByes)}>
                                        <input type="checkbox" checked={allowByes} onChange={e => setAllowByes(e.target.checked)} className="w-4 h-4 cursor-pointer" />
                                        <span className="text-sm select-none">Sta <b>Byes</b> toe (Vrijloting) - <i>Iedereen gaat door naar KO</i></span>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div className="lg:col-span-4 space-y-6">
                            <div className="bg-white p-6 rounded-lg shadow-sm border border-gray-200">
                                <h3 className="font-bold text-gray-700 mb-4 border-b pb-2">Wedstrijd Instellingen</h3>
                                <div className="grid grid-cols-2 gap-3 mb-4">
                                    <div><label className={LABEL_STYLE}>Poule (Best of)</label><input type="number" className={INPUT_STYLE} value={groupLegs} onChange={e => setGroupLegs(Number(e.target.value))}/></div>
                                    <div><label className={LABEL_STYLE}>KO (Best of)</label><input type="number" className={INPUT_STYLE} value={koLegs} onChange={e => setKoLegs(Number(e.target.value))}/></div>
                                </div>
                                <label className={LABEL_STYLE}>Borden ({selectedBoardIds.length})</label>
                                <div className="max-h-40 overflow-y-auto border rounded p-2 bg-gray-50">
                                    {allBoards.map(board => (
                                        <label key={board.id} className="flex items-center p-2 hover:bg-white rounded cursor-pointer">
                                            <input type="checkbox" className="mr-3" checked={selectedBoardIds.includes(board.id)} onChange={() => toggleBoard(board.id)} />
                                            <span className="text-sm">Bord {board.number}</span>
                                        </label>
                                    ))}
                                </div>
                            </div>
                            
                            <div className="flex gap-2">
                                <button onClick={() => setStep(2)} className="px-4 py-3 rounded-lg border text-gray-600 font-bold hover:bg-gray-50"><ArrowLeft size={20}/></button>
                                <button onClick={handleStartTournament} disabled={loading} className="flex-1 bg-green-600 text-white font-bold py-4 rounded-lg hover:bg-green-700 transition shadow-lg flex justify-center items-center gap-2 disabled:opacity-50">
                                    {loading ? "Bezig..." : "Start Toernooi"} <Trophy size={20}/>
                                </button>
                            </div>
                        </div>
                    </div>
                )}
            </div>
        </AdminLayout>
    );
};
export default CreateTournament;

==================================================
FILE: frontend/src\pages\admin\Dashboard.tsx
==================================================

import { useEffect, useState, useRef } from 'react';
import { Link, useNavigate } from 'react-router-dom';
import api from '../../services/api';
import AdminLayout from '../../components/layout/AdminLayout';
import { Trophy, Calendar, Users, ExternalLink, Copy, Target, LayoutGrid, Tablet, ChevronDown, GitMerge, Trash2 } from 'lucide-react';
import { Tournament } from '../../types';

// --- Helper Component for the Dropdown ---
const ScorerMenu = ({ tournament }: { tournament: Tournament }) => {
  const [isOpen, setIsOpen] = useState(false);
  const menuRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (menuRef.current && !menuRef.current.contains(event.target as Node)) {
        setIsOpen(false);
      }
    };
    document.addEventListener("mousedown", handleClickOutside);
    return () => document.removeEventListener("mousedown", handleClickOutside);
  }, []);

  const pouleCount = tournament.number_of_poules || 1;
  const poules = Array.from({ length: pouleCount }, (_, i) => i + 1);

  return (
    <div className="relative" ref={menuRef}>
      <button 
        onClick={() => setIsOpen(!isOpen)}
        className="flex items-center gap-2 px-4 py-2 bg-indigo-50 text-indigo-700 border border-indigo-200 rounded font-medium hover:bg-indigo-100 transition"
      >
        <Tablet size={18} />
        Scorer
        <ChevronDown size={14} />
      </button>

      {isOpen && (
        <div className="absolute right-0 mt-2 w-56 bg-white rounded-lg shadow-xl border border-gray-100 z-50 overflow-hidden">
          {/* Main Link: All Matches */}
          <Link 
            to={`/board/${tournament.scorer_uuid}`}
            target="_blank"
            className="block px-4 py-2 text-sm text-gray-700 hover:bg-indigo-50 hover:text-indigo-700 font-bold border-b border-gray-100"
          >
            All Matches
          </Link>
          
          {/* Poule Links */}
          <div className="max-h-48 overflow-y-auto">
            {poules.map(num => (
              <Link
                key={num}
                to={`/board/${tournament.scorer_uuid}?poule=${num}`}
                target="_blank"
                className="block px-4 py-2 text-sm text-gray-600 hover:bg-gray-50 flex justify-between items-center"
              >
                <span>Poule {num}</span>
                <Target size={12} className="opacity-50"/>
              </Link>
            ))}
          </div>

          {/* Knockout Link */}
          {(tournament.format === 'hybrid' || tournament.format === 'knockout') && (
            <Link
                to={`/board/${tournament.scorer_uuid}?poule=ko`}
                target="_blank"
                className="block px-4 py-2 text-sm text-orange-600 hover:bg-orange-50 flex justify-between items-center border-t border-gray-100 font-medium"
            >
                <span>Knockout Phase</span>
                <GitMerge size={14} />
            </Link>
          )}
        </div>
      )}
    </div>
  );
};

const Dashboard = () => {
  const [tournaments, setTournaments] = useState<Tournament[]>([]);
  const [loading, setLoading] = useState(true);
  const navigate = useNavigate();

  useEffect(() => {
    const fetchTournaments = async () => {
      try {
        const res = await api.get('/tournaments/');
        const sorted = res.data.sort((a: Tournament, b: Tournament) => 
          new Date(b.date).getTime() - new Date(a.date).getTime()
        );
        setTournaments(sorted);
      } catch (error) {
        console.error("Failed to load tournaments");
      } finally {
        setLoading(false);
      }
    };
    fetchTournaments();
  }, []);

  const copyToClipboard = (uuid: string) => {
    const url = `${window.location.origin}/t/${uuid}`;
    navigator.clipboard.writeText(url);
    alert("Public link copied to clipboard!");
  };

  // --- RESTORED: Delete Logic ---
  const handleDelete = async (id: number) => {
    const confirmed = window.confirm(
        "Are you sure you want to delete this tournament?\n\nThis will permanently delete all matches, scores, and teams associated with it."
    );
    
    if (!confirmed) return;

    try {
        await api.delete(`/tournaments/${id}`);
        // Remove from UI immediately
        setTournaments(prev => prev.filter(t => t.id !== id));
    } catch (error) {
        alert("Error deleting tournament. Check logs.");
        console.error(error);
    }
  };

  return (
    <AdminLayout>
      <div className="flex justify-between items-center mb-8">
        <div>
          <h2 className="text-3xl font-bold text-gray-800">Dashboard</h2>
          <p className="text-gray-500">Welcome back to your tournament center.</p>
        </div>
        <Link 
          to="/dashboard/create-tournament" 
          className="bg-blue-600 text-white px-4 py-2 rounded-lg font-bold hover:bg-blue-700 transition flex items-center gap-2 shadow-sm"
        >
          <Trophy size={18} />
          New Tournament
        </Link>
      </div>

      {loading ? (
        <div className="text-center py-12 text-gray-400">Loading tournaments...</div>
      ) : (
        <div className="grid gap-6">
          {tournaments.length === 0 ? (
            <div className="bg-white p-12 rounded-lg shadow-sm text-center border-2 border-dashed border-gray-200">
              <Trophy className="mx-auto h-12 w-12 text-gray-300 mb-4" />
              <h3 className="text-lg font-medium text-gray-900">No tournaments yet</h3>
              <p className="mt-1 text-gray-500">Get started by creating your first tournament.</p>
            </div>
          ) : (
            tournaments.map((t) => (
              <div key={t.id} className="bg-white p-6 rounded-lg shadow-sm border border-gray-100 hover:shadow-md transition-shadow">
                <div className="flex flex-col xl:flex-row justify-between xl:items-center gap-4">
                  
                  {/* Left: Info */}
                  <div>
                    <div className="flex items-center gap-3 mb-1">
                      <h3 className="text-xl font-bold text-blue-900">{t.name}</h3>
                      <span className={`text-xs px-2 py-1 rounded-full uppercase font-bold tracking-wide ${
                        t.status === 'active' ? 'bg-green-100 text-green-700' : 'bg-gray-100 text-gray-600'
                      }`}>
                        {t.status}
                      </span>
                    </div>
                    
                    <div className="flex flex-wrap items-center gap-4 text-sm text-gray-500 mt-2">
                      <span className="flex items-center gap-1"><Calendar size={14} /> {new Date(t.date).toLocaleDateString()}</span>
                      <span className="flex items-center gap-1"><Users size={14} /> {t.player_count || 0} Players</span>
                      <span className="flex items-center gap-1"><Target size={14} /> {t.board_count || 0} Boards</span>
                      <span className="flex items-center gap-1"><LayoutGrid size={14} /> {t.number_of_poules || 1} Poules</span>
                    </div>
                  </div>

                  {/* Right: Actions */}
                  <div className="flex flex-wrap items-center gap-3">
                    <button 
                      onClick={() => copyToClipboard(t.public_uuid || '')}
                      className="p-2 text-gray-400 hover:text-blue-600 hover:bg-blue-50 rounded transition"
                      title="Copy Public Link"
                    >
                      <Copy size={20} />
                    </button>
                    
                    <Link 
                      to={`/t/${t.public_uuid}`}
                      target="_blank"
                      className="flex items-center gap-2 px-4 py-2 border border-gray-200 rounded text-gray-600 font-medium hover:bg-gray-50 transition"
                    >
                      <ExternalLink size={18} />
                      Public View
                    </Link>

                    {/* Scorer Menu */}
                    {t.scorer_uuid && (
                        <ScorerMenu tournament={t} />
                    )}

                    <button 
                      onClick={() => navigate(`/dashboard/tournament/${t.id}`)}
                      className="bg-slate-800 text-white px-5 py-2 rounded font-medium hover:bg-slate-900 transition shadow-sm"
                    >
                      Manage
                    </button>

                    {/* RESTORED: Delete Button */}
                    <button 
                      onClick={() => handleDelete(t.id)}
                      className="p-2 text-red-300 hover:text-red-600 hover:bg-red-50 rounded transition border border-transparent hover:border-red-200"
                      title="Delete Tournament"
                    >
                      <Trash2 size={20} />
                    </button>

                  </div>

                </div>
              </div>
            ))
          )}
        </div>
      )}
    </AdminLayout>
  );
};

export default Dashboard;

==================================================
FILE: frontend/src\pages\admin\ManageBoards.tsx
==================================================

import { useEffect, useState } from 'react';
import api from '../../services/api';
import { Trash2, Target } from 'lucide-react';
import AdminLayout from '../../components/layout/AdminLayout';
import { Dartboard } from '../../types';

const ManageBoards = () => {
  const [boards, setBoards] = useState<Dartboard[]>([]);
  const [formData, setFormData] = useState({ name: '', number: '' });

  useEffect(() => { loadBoards(); }, []);

  const loadBoards = async () => {
    try {
      const response = await api.get('/dartboards/');
      setBoards(response.data);
    } catch (err) { console.error(err); }
  };

  const handleAdd = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      await api.post('/dartboards/', {
        name: formData.name,
        number: parseInt(formData.number)
      });
      setFormData({ name: '', number: '' });
      loadBoards();
    } catch (err) { alert("Error adding board"); }
  };

  const handleDelete = async (id: number) => {
    if(!confirm("Delete this board?")) return;
    try { await api.delete(`/dartboards/${id}`); loadBoards(); }
    catch (err) { alert("Error deleting board"); }
  };

  return (
    <AdminLayout>
      <h2 className="text-3xl font-bold text-gray-800 mb-8">Manage Dartboards</h2>
      
      <div className="grid grid-cols-1 md:grid-cols-3 gap-8">
        {/* Form */}
        <div className="bg-white p-6 rounded-lg shadow-sm h-fit">
          <h3 className="font-semibold mb-4 flex items-center gap-2">
            <Target className="text-blue-600" /> Add Board
          </h3>
          <form onSubmit={handleAdd} className="space-y-4">
            <div>
              <label className="block text-xs font-bold text-gray-700 mb-1">Board Number</label>
              <input type="number" required className="w-full border rounded p-2"
                value={formData.number}
                onChange={e => setFormData({...formData, number: e.target.value})}
              />
            </div>
            <div>
              <label className="block text-xs font-bold text-gray-700 mb-1">Location Name</label>
              <input type="text" required placeholder="e.g. Main Stage" className="w-full border rounded p-2"
                value={formData.name}
                onChange={e => setFormData({...formData, name: e.target.value})}
              />
            </div>
            <button type="submit" className="w-full bg-blue-600 text-white font-bold py-2 rounded hover:bg-blue-700">
              Add Board
            </button>
          </form>
        </div>

        {/* List */}
        <div className="md:col-span-2 grid grid-cols-1 sm:grid-cols-2 gap-4">
          {boards.map(board => (
            <div key={board.id} className="bg-white p-4 rounded-lg shadow-sm border-l-4 border-blue-500 flex justify-between items-center">
              <div>
                <span className="text-xs font-bold text-gray-400 uppercase">Board {board.number}</span>
                <div className="text-lg font-bold text-gray-800">{board.name}</div>
              </div>
              <button onClick={() => handleDelete(board.id)} className="text-gray-400 hover:text-red-500">
                <Trash2 size={20} />
              </button>
            </div>
          ))}
        </div>
      </div>
    </AdminLayout>
  );
};

export default ManageBoards;

==================================================
FILE: frontend/src\pages\admin\ManagePlayers.tsx
==================================================

import { useEffect, useState } from 'react';
import api from '../../services/api';
import { Trash2, UserPlus } from 'lucide-react';
import AdminLayout from '../../components/layout/AdminLayout';
import { Player } from '../../types';

const ManagePlayers = () => {
  const [players, setPlayers] = useState<Player[]>([]);
  const [loading, setLoading] = useState(true);
  
  // State for the 4 input fields
  const [formData, setFormData] = useState({
    first_name: '',
    last_name: '',
    nickname: '',
    email: ''
  });

  // Load players when page opens
  useEffect(() => {
    loadPlayers();
  }, []);

  const loadPlayers = async () => {
    try {
      const response = await api.get('/players/');
      setPlayers(response.data);
    } catch (error) {
      console.error("Failed to load players");
    } finally {
      setLoading(false);
    }
  };

  const handleAddPlayer = async (e: React.FormEvent) => {
    e.preventDefault();
    
    // DATA CLEANING:
    // We must convert empty strings "" to null, otherwise the backend
    // will think we are sending an invalid email address.
    const payload = {
      first_name: formData.first_name,
      last_name: formData.last_name.trim() === '' ? null : formData.last_name,
      nickname: formData.nickname.trim() === '' ? null : formData.nickname,
      email: formData.email.trim() === '' ? null : formData.email
    };

    try {
      await api.post('/players/', payload);
      
      // Clear the form
      setFormData({
        first_name: '',
        last_name: '',
        nickname: '',
        email: ''
      });
      
      // Refresh the list
      loadPlayers(); 
    } catch (error: any) {
      console.error("Error adding player:", error.response?.data);
      alert("Error adding player. Please check that the email is valid (or leave it empty).");
    }
  };

  const handleDelete = async (id: number) => {
    if (!confirm("Are you sure you want to delete this player?")) return;
    try {
      await api.delete(`/players/${id}`);
      loadPlayers();
    } catch (error) {
      alert("Error deleting player");
    }
  };

  return (
    <AdminLayout>
      <div className="max-w-4xl mx-auto">
        <h2 className="text-3xl font-bold text-gray-800 mb-8">Manage Players</h2>

        {/* --- Add Player Form --- */}
        <div className="bg-white p-6 rounded-lg shadow-sm mb-8">
          <h3 className="text-lg font-semibold mb-4 text-gray-700">Add New Player</h3>
          
          <form onSubmit={handleAddPlayer} className="space-y-4">
            
            {/* Row 1: First & Last Name */}
            <div className="grid grid-cols-2 gap-4">
              <div>
                <label className="block text-xs font-bold text-gray-700 mb-1">First Name*</label>
                <input 
                  type="text" 
                  required
                  className="w-full border rounded p-2 text-sm focus:ring-2 focus:ring-blue-500 outline-none"
                  value={formData.first_name}
                  onChange={(e) => setFormData({...formData, first_name: e.target.value})}
                  placeholder="Luke"
                />
              </div>
              
              <div>
                <label className="block text-xs font-bold text-gray-700 mb-1">Last Name</label>
                <input 
                  type="text" 
                  className="w-full border rounded p-2 text-sm focus:ring-2 focus:ring-blue-500 outline-none"
                  value={formData.last_name}
                  onChange={(e) => setFormData({...formData, last_name: e.target.value})}
                  placeholder="Littler"
                />
              </div>
            </div>

            {/* Row 2: Nickname & Email */}
            <div className="grid grid-cols-2 gap-4">
              <div>
                <label className="block text-xs font-bold text-gray-700 mb-1">Nickname</label>
                <input 
                  type="text" 
                  className="w-full border rounded p-2 text-sm focus:ring-2 focus:ring-blue-500 outline-none"
                  value={formData.nickname}
                  onChange={(e) => setFormData({...formData, nickname: e.target.value})}
                  placeholder='e.g. "The Nuke"'
                />
              </div>
              <div>
                <label className="block text-xs font-bold text-gray-700 mb-1">Email</label>
                <input 
                  type="email" 
                  className="w-full border rounded p-2 text-sm focus:ring-2 focus:ring-blue-500 outline-none"
                  value={formData.email}
                  onChange={(e) => setFormData({...formData, email: e.target.value})}
                  placeholder="luke@darts.com"
                />
              </div>
            </div>

            <button
              type="submit"
              className="w-full bg-blue-600 text-white px-6 py-2 rounded-lg hover:bg-blue-700 flex items-center justify-center gap-2 font-medium mt-4 transition-colors"
            >
              <UserPlus size={20} />
              Add Player
            </button>
          </form>
        </div>

        {/* --- Players List --- */}
        <div className="bg-white rounded-lg shadow-sm overflow-hidden">
          <div className="p-4 border-b bg-gray-50 font-medium text-gray-500 flex justify-between items-center">
            <span>Total Players: {players.length}</span>
          </div>
          
          {loading ? (
             <div className="p-8 text-center text-gray-500">Loading players...</div>
          ) : players.length === 0 ? (
            <div className="p-8 text-center text-gray-500">No players found. Add one above!</div>
          ) : (
            <ul className="divide-y divide-gray-100">
              {players.map((player) => (
                <li key={player.id} className="p-4 flex items-center justify-between hover:bg-gray-50 transition">
                  <div>
                    {/* The 'name' property comes formatted from the backend (e.g. Luke "The Nuke" Littler) */}
                    <div className="text-lg text-gray-800 font-medium">{player.name}</div>
                    
                    <div className="text-xs text-gray-400">
                       {player.email ? player.email : "No email linked"}
                    </div>
                  </div>
                  
                  <button
                    onClick={() => handleDelete(player.id)}
                    className="text-gray-400 hover:text-red-600 p-2 rounded-full hover:bg-red-50 transition"
                    title="Delete Player"
                  >
                    <Trash2 size={20} />
                  </button>
                </li>
              ))}
            </ul>
          )}
        </div>
      </div>
    </AdminLayout>
  );
};

export default ManagePlayers;

==================================================
FILE: frontend/src\pages\admin\ManageTeams.tsx
==================================================

import { useEffect, useState } from 'react';
import api from '../../services/api';
import AdminLayout from '../../components/layout/AdminLayout';
import { Player, Team } from '../../types';
import { Users, UserPlus, Trash2, Shield } from 'lucide-react';

const ManageTeams = () => {
    const [teams, setTeams] = useState<Team[]>([]);
    const [players, setPlayers] = useState<Player[]>([]);
    const [loading, setLoading] = useState(true);

    // Form State
    const [selectedPlayerIds, setSelectedPlayerIds] = useState<number[]>([]);
    const [teamName, setTeamName] = useState("");

    useEffect(() => {
        loadData();
    }, []);

    const loadData = async () => {
        try {
            const [tRes, pRes] = await Promise.all([
                api.get('/teams/'),    // Haalt nu ALLE teams op
                api.get('/players/')
            ]);
            setTeams(tRes.data);
            setPlayers(pRes.data);
        } catch (err) {
            console.error(err);
        } finally {
            setLoading(false);
        }
    };

    const togglePlayer = (id: number) => {
        setSelectedPlayerIds(prev => {
            if (prev.includes(id)) return prev.filter(p => p !== id);
            if (prev.length >= 2) return prev; // Max 2
            return [...prev, id];
        });
    };

    const handleCreate = async (e: React.FormEvent) => {
        e.preventDefault();
        if (selectedPlayerIds.length !== 2) return alert("Selecteer precies 2 spelers.");

        try {
            // We sturen GEEN tournament_id mee -> Global Team
            const payload = {
                player_ids: selectedPlayerIds,
                name: teamName.trim() === "" ? null : teamName
            };
            
            await api.post('/teams/manual', payload);
            
            // Reset & Reload
            setTeamName("");
            setSelectedPlayerIds([]);
            loadData();
        } catch (err) {
            alert("Kon team niet maken.");
        }
    };

    // Optioneel: Delete functie (moet je backend endpoint voor hebben, anders weglaten)
    const handleDelete = async (id: number) => {
            if(!confirm("Weet je zeker dat je dit team wilt verwijderen?")) return;
            
            try {
                await api.delete(`/teams/${id}`);
                // Verwijder het team direct uit de lokale state (sneller dan herladen)
                setTeams(prev => prev.filter(t => t.id !== id));
            } catch (err) {
                console.error(err);
                alert("Kon team niet verwijderen. Mogelijk is dit team al gekoppeld aan wedstrijden.");
            }
        };

    return (
        <AdminLayout>
            <div className="max-w-6xl mx-auto pb-20">
                <h2 className="text-3xl font-bold text-gray-800 mb-6 flex items-center gap-2">
                    <Shield className="text-blue-600" /> Manage Teams
                </h2>

                <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
                    
                    {/* LINKER KOLOM: TEAM MAKEN */}
                    <div className="bg-white p-6 rounded-lg shadow-sm border border-gray-200 h-fit">
                        <h3 className="font-bold text-gray-700 mb-4 flex items-center gap-2">
                            <UserPlus size={20} className="text-green-600"/> Nieuw Team Maken
                        </h3>
                        
                        <form onSubmit={handleCreate}>
                            <div className="mb-4">
                                <label className="block text-xs font-bold text-gray-500 uppercase mb-1">Naam (Optioneel)</label>
                                <input 
                                    type="text" 
                                    className="w-full border border-gray-300 rounded-md p-2 text-sm focus:ring-2 focus:ring-blue-500 outline-none"
                                    placeholder="Bijv. The Power Duo"
                                    value={teamName}
                                    onChange={e => setTeamName(e.target.value)}
                                />
                            </div>

                            <div className="mb-4">
                                <label className="block text-xs font-bold text-gray-500 uppercase mb-1">
                                    Selecteer 2 Spelers ({selectedPlayerIds.length}/2)
                                </label>
                                <div className="grid grid-cols-2 gap-2 max-h-60 overflow-y-auto pr-1 border rounded p-2 bg-gray-50">
                                    {players.map(p => (
                                        <div 
                                            key={p.id} 
                                            onClick={() => togglePlayer(p.id)}
                                            className={`p-2 rounded border text-sm cursor-pointer select-none transition-colors ${
                                                selectedPlayerIds.includes(p.id) 
                                                ? 'bg-blue-100 border-blue-500 text-blue-700 font-bold' 
                                                : 'bg-white hover:bg-gray-100 border-gray-200'
                                            }`}
                                        >
                                            {p.name}
                                        </div>
                                    ))}
                                </div>
                            </div>

                            <button 
                                type="submit" 
                                disabled={selectedPlayerIds.length !== 2}
                                className="w-full bg-blue-600 text-white font-bold py-2 rounded hover:bg-blue-700 transition disabled:opacity-50 disabled:cursor-not-allowed"
                            >
                                Team Opslaan
                            </button>
                        </form>
                    </div>

                    {/* RECHTER KOLOM: TEAM LIJST */}
                    <div className="bg-white p-6 rounded-lg shadow-sm border border-gray-200">
                        <h3 className="font-bold text-gray-700 mb-4 flex items-center gap-2">
                            <Users size={20} className="text-purple-600"/> Bestaande Teams
                        </h3>
                        
                        <div className="space-y-3 max-h-[600px] overflow-y-auto pr-2">
                            {loading ? <p>Laden...</p> : teams.length === 0 ? (
                                <p className="text-gray-400 italic text-sm">Nog geen teams aangemaakt.</p>
                            ) : (
                                teams.map(team => (
                                    <div key={team.id} className="flex items-center justify-between p-3 bg-gray-50 rounded border border-gray-200 hover:shadow-sm transition">
                                        <div>
                                            <div className="font-bold text-gray-800">{team.name}</div>
                                            <div className="text-xs text-gray-500 flex gap-1 mt-1">
                                                {team.players.map(p => (
                                                    <span key={p.id} className="bg-white border px-1.5 py-0.5 rounded shadow-sm">
                                                        {p.name}
                                                    </span>
                                                ))}
                                            </div>
                                        </div>
                                        {/* Placeholder voor delete knop */}
                                        <button className="text-gray-300 hover:text-red-500 transition" onClick={() => handleDelete(team.id)}>
                                            <Trash2 size={18} />
                                        </button>
                                    </div>
                                ))
                            )}
                        </div>
                    </div>

                </div>
            </div>
        </AdminLayout>
    );
};

export default ManageTeams;

==================================================
FILE: frontend/src\pages\admin\ManageTournament.tsx
==================================================

import { useEffect, useState } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import api from '../../services/api';
import AdminLayout from '../../components/layout/AdminLayout';
import { Save, RefreshCcw, ShieldAlert, Settings, ChevronDown, ChevronRight, SaveAll, GitMerge, Trophy , AlertCircle, Info} from 'lucide-react';
import { Tournament, Match } from '../../types';

interface MatchWithUI extends Match {
  best_of_legs: number;
  player1_name: string;
  player2_name: string;
  score_p1: number;
  score_p2: number;
  is_completed: boolean;
  round_number: number;
  poule_number: number | null;
  is_saving?: boolean;
  save_success?: boolean;
}

const ManageTournament = () => {
  const { id } = useParams();
  const navigate = useNavigate();
  
  const [tournament, setTournament] = useState<Tournament | null>(null);
  const [matches, setMatches] = useState<MatchWithUI[]>([]);
  const [loading, setLoading] = useState(true);
  
  // Settings State
  const [allowByes, setAllowByes] = useState(true);
  const [settingsDirty, setSettingsDirty] = useState(false);

  // Round Collapses
  const [openRounds, setOpenRounds] = useState<Record<string, boolean>>({});

  useEffect(() => {
    loadData();
  }, [id]);

  const loadData = async () => {
    setLoading(true);
    try {
      const tournRes = await api.get(`/tournaments/${id}`);
      const currentTourn = tournRes.data;
      setTournament(currentTourn);
      setAllowByes(currentTourn.allow_byes);

      if (currentTourn.public_uuid) {
          const matchesRes = await api.get(`/matches/by-tournament/${currentTourn.public_uuid}`);
          
          setMatches(matchesRes.data);
          
          // Open automatisch de hoogste ronde of poule fase
          if (matchesRes.data.length > 0) {
              const maxRoundMatch = matchesRes.data.reduce((prev: any, current: any) => {
                  return (prev.id > current.id) ? prev : current;
              });
              
              const type = maxRoundMatch.poule_number !== null ? 'P' : 'K';
              // Als het een poule is, gebruiken we poule nummer, anders ronde nummer
              const num = maxRoundMatch.poule_number !== null ? maxRoundMatch.poule_number : maxRoundMatch.round_number;
              const key = `${type}-${num}`;
              
              setOpenRounds((prev) => ({ ...prev, [key]: true }));
          }
      }
    } catch (error) {
      console.error("Fout bij laden data:", error);
    } finally {
      setLoading(false);
    }
  };

  // --- ACTIES ---

  const handleUpdateSettings = async () => {
    if (!tournament) return;
    try {
        await api.patch(`/tournaments/${tournament.id}`, { allow_byes: allowByes });
        setSettingsDirty(false);
        alert("Instellingen opgeslagen.");
    } catch (err) {
        alert("Fout bij opslaan instellingen.");
    }
  };

  const handleResetMatch = async (matchId: number) => {
    if (!confirm("Resetten naar 0-0 en open zetten?")) return;
    try {
        await api.put(`/matches/${matchId}/score`, {
            score_p1: 0,
            score_p2: 0,
            is_completed: false
        });
        setMatches(prev => prev.map(m => m.id === matchId ? { ...m, score_p1: 0, score_p2: 0, is_completed: false } : m));
    } catch (err) {
        alert("Reset mislukt.");
    }
  };

  const handleBatchUpdateRound = async (roundNum: number, legs: number) => {
    if (!tournament) return;
    if (!confirm(`Zet alle ONGESPEELDE wedstrijden in ronde ${roundNum} naar Best of ${legs}?`)) return;
    try {
        await api.post(`/tournaments/${tournament.id}/rounds/${roundNum}/update-format?best_of_legs=${legs}`);
        loadData();
    } catch (err) {
        alert("Update mislukt.");
    }
  };

  const toggleRound = (key: string) => setOpenRounds(prev => ({...prev, [key]: !prev[key]}));

  // --- SPREADSHEET LOGICA ---

  const handleScoreChange = (id: number, field: 'score_p1' | 'score_p2', value: string) => {
      const numVal = value === '' ? 0 : parseInt(value);
      setMatches(prev => prev.map(m => 
          m.id === id ? { ...m, [field]: numVal, save_success: false } : m
      ));
  };

  const calculateStandings = (matches: MatchWithUI[]) => {
  const stats: Record<string, { pts: number, ld: number, needs_shootout: boolean }> = {};
  const h2hWinners: Record<string, string> = {};

  matches.forEach(m => {
    const p1 = m.player1_name || 'Bye';
    const p2 = m.player2_name || 'Bye';
    if (!stats[p1]) stats[p1] = { pts: 0, ld: 0, needs_shootout: false };
    if (!stats[p2]) stats[p2] = { pts: 0, ld: 0, needs_shootout: false };

    if (m.is_completed && m.player1_name && m.player2_name) {
      stats[p1].ld += (m.score_p1 - m.score_p2);
      stats[p2].ld += (m.score_p2 - m.score_p1);

      const winner = m.score_p1 > m.score_p2 ? p1 : p2;
      if (m.score_p1 > m.score_p2) stats[p1].pts += 2;
      else stats[p2].pts += 2;

      const pairKey = [p1, p2].sort().join('_vs_');
      h2hWinners[pairKey] = winner;
    }
  });

  const list = Object.entries(stats).map(([name, data]) => ({ name, ...data }));
  list.sort((a, b) => {
    if (b.pts !== a.pts) return b.pts - a.pts;
    if (b.ld !== a.ld) return b.ld - a.ld;
    const pairKey = [a.name, b.name].sort().join('_vs_');
    const winner = h2hWinners[pairKey];
    if (winner === a.name) return -1;
    if (winner === b.name) return 1;
    a.needs_shootout = true;
    b.needs_shootout = true;
    return 0;
  });
  return list;
};

  const canStartKnockout = () => {
    if (!tournament || !matches.length) return false;
    if (tournament.format !== 'hybrid') return false; 

    const pouleMatches = matches.filter(m => m.poule_number !== null);
    const koMatches = matches.filter(m => m.poule_number === null);

    if (pouleMatches.length === 0) return false;
    const allPoulesFinished = pouleMatches.every(m => m.is_completed);
    const koNotStarted = koMatches.length === 0;

    // Check voor 9-dart shootouts per poule
    const pouleNumbers = [...new Set(pouleMatches.map(m => m.poule_number))];
    const hasUnresolvedTies = pouleNumbers.some(pNum => {
        const mInPoule = pouleMatches.filter(m => m.poule_number === pNum);
        return calculateStandings(mInPoule).some(s => s.needs_shootout);
    });

    return allPoulesFinished && koNotStarted && !hasUnresolvedTies;
};

  const handleStartKnockout = async () => {
      if (!confirm("Weet je zeker dat je de Poule-fase wilt afsluiten en de Knockout wilt genereren?")) return;
      
      try {
          await api.post(`/tournaments/${id}/start-knockout`);
          alert("Knockout fase gegenereerd!");
          loadData(); 
      } catch (err) {
          console.error(err);
          alert("Er ging iets mis bij het starten van de knockout.");
      }
  };

  const saveMatchScore = async (match: MatchWithUI) => {
      setMatches(prev => prev.map(m => m.id === match.id ? { ...m, is_saving: true } : m));

      try {
          await api.put(`/matches/${match.id}/score`, {
              score_p1: match.score_p1,
              score_p2: match.score_p2,
              is_completed: true 
          });

          setMatches(prev => prev.map(m => m.id === match.id ? { ...m, is_saving: false, save_success: true, is_completed: true } : m));
          
          setTimeout(() => {
            setMatches(prev => prev.map(m => m.id === match.id ? { ...m, save_success: false } : m));
          }, 2000);

    } catch (err: any) {
          console.error(err);
          
          // Get error message from backend
          const errorMessage = err.response?.data?.detail || "Error saving score";
          alert(errorMessage); // <--- SHOW POPUP TO USER

          setMatches(prev => prev.map(m => m.id === match.id ? { ...m, is_saving: false } : m));
      }
  };

  const handleKeyDown = (e: React.KeyboardEvent, match: MatchWithUI) => {
      if (e.key === 'Enter') {
          saveMatchScore(match);
          (e.currentTarget as HTMLInputElement).blur(); 
      }
  };

  const getRoundName = (roundNum: number, matchCount: number) => {
    if (matchCount === 1) return "Finale";
    if (matchCount === 2) return "Halve Finale";
    if (matchCount === 4) return "Kwartfinale";
    return `Ronde ${roundNum}`;
  };

  // --- UPDATED GROUPING LOGIC ---
  const groupedMatches = matches.reduce((acc, match) => {
    let key = '';
    
    // Group by Poule Number if it exists
    if (match.poule_number !== null) {
        key = `P-${match.poule_number}`;
    } else {
        // Otherwise group by Round (Knockout)
        key = `K-${match.round_number}`;
    }
    
    if (!acc[key]) acc[key] = [];
    acc[key].push(match);
    return acc;
  }, {} as Record<string, MatchWithUI[]>);

  // Sort groups: Poules first (numeric), then Knockout (numeric)
  const sortedGroupKeys = Object.keys(groupedMatches).sort((a, b) => {
      const [typeA, numStrA] = a.split('-');
      const [typeB, numStrB] = b.split('-');
      const numA = Number(numStrA);
      const numB = Number(numStrB);

      if (typeA !== typeB) return typeA === 'P' ? -1 : 1;
      return numA - numB;
  });

  // --- RENDERING ---

  if (loading) {
    return (
      <AdminLayout>
          <div className="flex justify-center items-center h-64 text-gray-500">
              <span className="animate-pulse">Gegevens ophalen...</span>
          </div>
      </AdminLayout>
    );
  }

  if (!tournament) {
    return (
      <AdminLayout>
          <div className="max-w-5xl mx-auto mt-8 bg-red-50 text-red-600 p-6 rounded-lg border border-red-200">
              <h3 className="font-bold text-lg flex items-center gap-2"><ShieldAlert /> Toernooi niet gevonden</h3>
              <button onClick={() => navigate('/dashboard')} className="mt-4 text-blue-600 hover:underline">&larr; Terug</button>
          </div>
      </AdminLayout>
    );
  }

  return (
    <AdminLayout>
      <style>{`
        .no-spinner::-webkit-inner-spin-button, 
        .no-spinner::-webkit-outer-spin-button { 
          -webkit-appearance: none; 
          margin: 0; 
        } 
        .no-spinner { 
          -moz-appearance: textfield; 
        }
      `}</style>

      <div className="max-w-5xl mx-auto pb-20">
        <div className="flex justify-between items-center mb-6">
            <h2 className="text-3xl font-bold text-gray-800 flex items-center gap-3">
                <Settings className="text-gray-600" />
                Beheer: <span className="text-blue-600">{tournament.name}</span>
            </h2>
            <button onClick={loadData} className="p-2 bg-gray-200 rounded hover:bg-gray-300">
                <RefreshCcw size={20} />
            </button>
        </div>

        {/* Sectie voor het starten van de Knockout Fase */}
        {tournament.status === 'active' && 
        matches.filter(m => m.poule_number !== null).length > 0 && 
        matches.filter(m => m.poule_number !== null).every(m => m.is_completed) && 
        matches.filter(m => m.poule_number === null).length === 0 && (
            <div className={`rounded-lg p-4 mb-6 flex justify-between items-center shadow-sm border ${
                canStartKnockout() ? 'bg-green-50 border-green-200' : 'bg-amber-50 border-amber-200'
            }`}>
                <div className="flex items-center gap-3">
                    <div className={`p-2 rounded-full ${
                        canStartKnockout() ? 'bg-green-100 text-green-600' : 'bg-amber-100 text-amber-600'
                    }`}>
                        {canStartKnockout() ? <GitMerge size={24} /> : <AlertCircle size={24} />}
                    </div>
                    <div>
                        <h4 className={`font-bold ${canStartKnockout() ? 'text-green-800' : 'text-amber-800'}`}>
                            {canStartKnockout() ? 'Klaar voor Knockout!' : 'Gelijkstand gedetecteerd'}
                        </h4>
                        <p className="text-sm opacity-80">
                            {canStartKnockout() 
                                ? 'Alle poulewedstrijden zijn klaar. Genereer nu de bracket.' 
                                : 'Er is een 9-dart shootout nodig of pas scores aan om de tie te breken.'}
                        </p>
                    </div>
                </div>
                <button 
                    disabled={!canStartKnockout()}
                    onClick={handleStartKnockout}
                    className={`font-bold py-2 px-6 rounded-lg shadow transition-all ${
                        canStartKnockout() 
                        ? 'bg-green-600 hover:bg-green-700 text-white transform hover:scale-105' 
                        : 'bg-gray-300 text-gray-500 cursor-not-allowed'
                    }`}
                >
                    Start Knockout Fase
                </button>
            </div>
        )}

        <div className="bg-white p-6 rounded-lg shadow-sm border border-yellow-200 mb-8">
            <h3 className="font-bold text-lg mb-4 flex items-center gap-2">
                <ShieldAlert className="text-yellow-500" /> Instellingen
            </h3>
            <div className="flex items-center gap-6">
                <label className="flex items-center gap-2 cursor-pointer">
                    <input type="checkbox" checked={allowByes} onChange={e => { setAllowByes(e.target.checked); setSettingsDirty(true); }} className="w-5 h-5 accent-blue-600"/>
                    <span className="font-medium text-gray-700">Allow Byes</span>
                </label>
                {settingsDirty && (
                    <button onClick={handleUpdateSettings} className="bg-blue-600 text-white px-4 py-1 rounded shadow hover:bg-blue-700 flex items-center gap-2 animate-pulse">
                        <Save size={16} /> Opslaan
                    </button>
                )}
            </div>
        </div>

        <div className="space-y-4">
            {sortedGroupKeys.map((groupKey) => {
                const [type, numStr] = groupKey.split('-');
                const number = Number(numStr);
                
                // Sort matches inside the group: Round Number ascending, then ID
                const roundMatches = groupedMatches[groupKey].sort((a,b) => {
                    if (a.round_number !== b.round_number) return a.round_number - b.round_number;
                    return a.id - b.id;
                });
                
                const isOpen = openRounds[groupKey];
                const isPoule = type === 'P';

                return (
                    <div key={groupKey} className={`rounded-lg shadow-sm border overflow-hidden ${isPoule ? 'bg-white border-gray-200' : 'bg-orange-50/50 border-orange-200'}`}>
                        <div 
                            className={`p-4 flex justify-between items-center cursor-pointer select-none ${isPoule ? 'bg-gray-50' : 'bg-orange-100 text-orange-900'}`} 
                            onClick={() => toggleRound(groupKey)}
                        >
                            <div className="flex items-center gap-2 font-bold text-gray-700">
                                {isOpen ? <ChevronDown size={20} /> : <ChevronRight size={20} />}
                                
                                {isPoule ? (
                                    <span className="flex items-center gap-2"><Trophy size={16} className="text-blue-500"/> Poule {number}</span>
                                ) : (
                                    <span className="text-orange-800 flex items-center gap-2">
                                        <GitMerge size={16}/> Knockout - {getRoundName(number, roundMatches.length)}
                                    </span>
                                )}
                                
                                <span className={`text-xs px-2 py-0.5 rounded font-normal ${isPoule ? 'bg-gray-200 text-gray-600' : 'bg-orange-200 text-orange-800'}`}>
                                    {roundMatches.length} wedstrijden
                                </span>
                            </div>
                            
                            {/* Only show Batch Update for Knockout rounds to avoid confusion */}
                            {isOpen && !isPoule && (
                                <div className="flex items-center gap-2" onClick={e => e.stopPropagation()}>
                                    <span className="text-xs text-gray-500 font-bold">Zet Best of:</span>
                                    <input type="number" min="1" className="w-12 text-center border rounded p-1 text-xs no-spinner" 
                                        placeholder={roundMatches[0].best_of_legs?.toString() || "5"}
                                        onKeyDown={(e) => e.key === 'Enter' && handleBatchUpdateRound(number, parseInt(e.currentTarget.value))}
                                    />
                                </div>
                            )}
                        </div>

                        {isOpen && (
                            <div className="divide-y divide-gray-100">
                                {roundMatches.map(match => (
                                    <div key={match.id} className={`p-3 transition-colors flex items-center justify-between ${match.save_success ? 'bg-green-50' : 'hover:bg-white'}`}>
                                        
                                        <div className="w-16 flex flex-col items-center justify-center gap-1 border-r border-gray-100 mr-2 pr-2">
                                            <div className="text-xs text-gray-400 font-mono">#{match.id}</div>
                                            
                                            <div className="flex flex-col items-center mt-1">
                                                <span className="text-[9px] text-gray-400 uppercase leading-none">Ref:</span>
                                                <div className="text-[10px] text-blue-400 font-bold uppercase tracking-tighter" title={`Referee: ${match.referee_name}`}>
                                                    {match.referee_name ? match.referee_name.split(' ')[0] : '-'}
                                                </div>
                                            </div>
                                        </div>

                                        <div className="flex-1 flex items-center justify-center gap-2">
                                            
                                            {/* SPELER 1 (Of Team 1) */}
                                            <div className={`flex-1 text-right truncate font-medium ${match.score_p1 > match.score_p2 && match.is_completed ? 'text-green-700 font-bold' : 'text-gray-700'}`}>
                                                {match.player1_name || <span className="italic text-gray-400">Bye</span>}
                                            </div>

                                            <div className="flex items-center bg-white border rounded shadow-sm overflow-hidden focus-within:ring-2 focus-within:ring-blue-400 focus-within:border-blue-400 transition-all">
                                                <input 
                                                    type="number" 
                                                    className={`w-12 text-center p-2 outline-none font-bold no-spinner ${match.save_success ? 'text-green-600' : 'text-gray-800'}`}
                                                    value={match.score_p1}
                                                    onChange={(e) => handleScoreChange(match.id, 'score_p1', e.target.value)}
                                                    onFocus={(e) => e.target.select()} 
                                                    onBlur={() => saveMatchScore(match)}
                                                    onKeyDown={(e) => handleKeyDown(e, match)}
                                                />
                                                <span className="text-gray-300 font-light px-1">|</span>
                                                <input 
                                                    type="number" 
                                                    className={`w-12 text-center p-2 outline-none font-bold no-spinner ${match.save_success ? 'text-green-600' : 'text-gray-800'}`}
                                                    value={match.score_p2}
                                                    onChange={(e) => handleScoreChange(match.id, 'score_p2', e.target.value)}
                                                    onFocus={(e) => e.target.select()}
                                                    onBlur={() => saveMatchScore(match)}
                                                    onKeyDown={(e) => handleKeyDown(e, match)}
                                                />
                                            </div>

                                            {/* SPELER 2 (Of Team 2) */}
                                            <div className={`flex-1 text-left truncate font-medium ${match.score_p2 > match.score_p1 && match.is_completed ? 'text-green-700 font-bold' : 'text-gray-700'}`}>
                                                {match.player2_name || <span className="italic text-gray-400">Bye</span>}
                                            </div>

                                        </div>

                                        <div className="w-20 flex justify-end gap-1">
                                            {match.is_saving ? (
                                                <span className="p-2 text-blue-500 animate-spin"><RefreshCcw size={16}/></span>
                                            ) : match.save_success ? (
                                                <span className="p-2 text-green-500"><SaveAll size={16}/></span>
                                            ) : (
                                                <button onClick={() => handleResetMatch(match.id)} className="p-2 text-gray-300 hover:text-red-500 transition" title="Reset">
                                                    <RefreshCcw size={16} />
                                                </button>
                                            )}
                                        </div>

                                    </div>
                                ))}
                            </div>
                        )}
                    </div>
                );
            })}
        </div>
      </div>
    </AdminLayout>
  );
};

export default ManageTournament;

==================================================
FILE: frontend/src\pages\admin\SystemLogs.tsx
==================================================

import { useEffect, useState, useRef } from 'react';
import AdminLayout from '../../components/layout/AdminLayout';
import { Terminal, Wifi, WifiOff } from 'lucide-react';

const SystemLogs = () => {
  const [logs, setLogs] = useState<string[]>([]);
  const [isConnected, setIsConnected] = useState(false);
  const scrollRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    // 1. Open the Connection
    const ws = new WebSocket('ws://localhost:8000/api/ws/logs');

    ws.onopen = () => {
      setIsConnected(true);
      console.log('Connected to Log Stream');
    };

    ws.onmessage = (event) => {
      // 2. Receive Data (it comes as a JSON array of strings)
      const data = JSON.parse(event.data);
      setLogs(data);
    };

    ws.onclose = () => setIsConnected(false);

    // Cleanup when leaving the page
    return () => {
      ws.close();
    };
  }, []);

  // Auto-scroll to bottom when new logs arrive
  useEffect(() => {
    if (scrollRef.current) {
      scrollRef.current.scrollTop = scrollRef.current.scrollHeight;
    }
  }, [logs]);

  return (
    <AdminLayout>
      <div className="max-w-6xl mx-auto h-[calc(100vh-100px)] flex flex-col">
        <div className="flex justify-between items-center mb-4">
          <h2 className="text-2xl font-bold text-gray-800 flex items-center gap-3">
            <Terminal className="text-gray-600" />
            System Live Logs
          </h2>
          
          <div className={`flex items-center gap-2 px-3 py-1 rounded-full text-sm font-medium ${isConnected ? 'bg-green-100 text-green-700' : 'bg-red-100 text-red-700'}`}>
            {isConnected ? <Wifi size={16} /> : <WifiOff size={16} />}
            {isConnected ? 'Live Stream Active' : 'Disconnected'}
          </div>
        </div>

        <div className="flex-1 bg-black rounded-lg shadow-2xl p-4 overflow-hidden border border-gray-700 flex flex-col font-mono text-sm">
          {/* Terminal Header */}
          <div className="flex gap-2 mb-4 border-b border-gray-800 pb-2">
            <div className="w-3 h-3 rounded-full bg-red-500"></div>
            <div className="w-3 h-3 rounded-full bg-yellow-500"></div>
            <div className="w-3 h-3 rounded-full bg-green-500"></div>
          </div>

          {/* Logs Output */}
          <div ref={scrollRef} className="flex-1 overflow-y-auto space-y-1 pr-2 custom-scrollbar">
            {logs.length === 0 ? (
              <span className="text-gray-500 italic">Waiting for logs...</span>
            ) : (
              logs.map((log, index) => (
                <div key={index} className="text-green-400 break-words hover:bg-gray-900 transition-colors p-0.5 rounded">
                  <span className="text-gray-600 mr-2">$</span>
                  {log}
                </div>
              ))
            )}
          </div>
        </div>
      </div>
    </AdminLayout>
  );
};

export default SystemLogs;

==================================================
FILE: frontend/src\pages\auth\Login.tsx
==================================================

import { useState } from 'react';
import { useAuth } from '../../hooks/useAuth';
import { loginUser } from '../../services/authService';
import { useNavigate } from 'react-router-dom';

const Login = () => {
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');
  
  // Get the login function from our global context
  const { login } = useAuth();
  
  // Hook to redirect the user after login
  const navigate = useNavigate();

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault(); // Stop page refresh
    setError('');

    try {
      // 1. Call Python API
      const data = await loginUser(username, password);
      
      // 2. Save token to Context/LocalStorage
      await login(data.access_token);
      
      // 3. Redirect to Dashboard
      navigate('/dashboard');
    } catch (err) {
      setError('Invalid username or password');
    }
  };

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-100">
      <div className="bg-white p-8 rounded-lg shadow-md w-96">
        <h2 className="text-2xl font-bold mb-6 text-center text-blue-600">Dart Manager</h2>
        
        {error && (
          <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-2 rounded mb-4">
            {error}
          </div>
        )}

        <form onSubmit={handleSubmit}>
          <div className="mb-4">
            <label className="block text-gray-700 text-sm font-bold mb-2">
              Username
            </label>
            <input
              type="text"
              className="w-full px-3 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
              value={username}
              onChange={(e) => setUsername(e.target.value)}
              required
            />
          </div>
          
          <div className="mb-6">
            <label className="block text-gray-700 text-sm font-bold mb-2">
              Password
            </label>
            <input
              type="password"
              className="w-full px-3 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              required
            />
          </div>
          
          <button
            type="submit"
            className="w-full bg-blue-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-700 transition duration-200"
          >
            Sign In
          </button>
        </form>
      </div>
    </div>
  );
};

export default Login;

==================================================
FILE: frontend/src\pages\auth\Register.tsx
==================================================

import { useState } from 'react';
import { Link, useNavigate } from 'react-router-dom';
import { registerUser } from '../../services/authService';

const Register = () => {
  const navigate = useNavigate();
  const [error, setError] = useState('');
  
  const [formData, setFormData] = useState({
    first_name: '',
    last_name: '',
    email: '',
    password: ''
  });

  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setFormData({ ...formData, [e.target.name]: e.target.value });
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError('');

    try {
      await registerUser(formData);
      // Success! Redirect to login
      alert("Registration successful! You can now sign in.");
      navigate('/login');
    } catch (err: any) {
      // If the backend says "Email already registered", show that here
      if (err.response && err.response.data && err.response.data.detail) {
        setError(err.response.data.detail);
      } else {
        setError('Registration failed. Please try again.');
      }
    }
  };

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-100">
      <div className="bg-white p-8 rounded-lg shadow-md w-96">
        <h2 className="text-2xl font-bold mb-6 text-center text-blue-600">Create Account</h2>
        
        {error && (
          <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-2 rounded mb-4 text-sm">
            {error}
          </div>
        )}

        <form onSubmit={handleSubmit} className="space-y-4">
          
          <div className="grid grid-cols-2 gap-2">
            <div>
              <label className="block text-gray-700 text-xs font-bold mb-1">First Name</label>
              <input
                name="first_name"
                type="text"
                required
                className="w-full px-3 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                onChange={handleChange}
                placeholder="Michael"
              />
            </div>
            <div>
              <label className="block text-gray-700 text-xs font-bold mb-1">Last Name</label>
              <input
                name="last_name"
                type="text"
                required
                className="w-full px-3 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
                onChange={handleChange}
                placeholder="Smith"
              />
            </div>
          </div>

          <div>
            <label className="block text-gray-700 text-xs font-bold mb-1">Email</label>
            <input
              name="email"
              type="email"
              required
              className="w-full px-3 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
              onChange={handleChange}
              placeholder="name@example.com"
            />
          </div>
          
          <div>
            <label className="block text-gray-700 text-xs font-bold mb-1">Password</label>
            <input
              name="password"
              type="password"
              required
              className="w-full px-3 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
              onChange={handleChange}
              placeholder="••••••••"
            />
          </div>
          
          <button
            type="submit"
            className="w-full bg-green-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-green-700 transition duration-200 mt-4"
          >
            Sign Up
          </button>
        </form>

        <div className="mt-4 text-center text-sm">
          <span className="text-gray-600">Already have an account? </span>
          <Link to="/login" className="text-blue-600 hover:underline">
            Login here
          </Link>
        </div>
      </div>
    </div>
  );
};

export default Register;

==================================================
FILE: frontend/src\pages\public\Standings.tsx
==================================================



==================================================
FILE: frontend/src\pages\public\TournamentView.tsx
==================================================

import { useEffect, useState, useMemo, useRef } from 'react';
import { useParams } from 'react-router-dom';
import api from '../../services/api';
import { Trophy, LayoutGrid, GitMerge, RefreshCw, Play, Pause, Medal, AlertCircle } from 'lucide-react';

// --- Types ---
interface Match {
  id: number;
  round_number: number;
  poule_number: number | null;
  player1_name: string;
  player2_name: string;
  score_p1: number;
  score_p2: number;
  is_completed: boolean;
  best_of_legs?: number;
  referee_name?: string;
}

interface Tournament {
  id: number;
  name: string;
  status: string;
  format: string;
  scorer_uuid: string;
  qualifiers_per_poule?: number; 
  starting_legs_group?: number;
  starting_legs_ko?: number;
  matches: Match[];
}

// Nieuw Type voor de data die uit de backend /standings endpoint komt
interface StandingsItem {
  id: number;
  name: string;
  points: number;
  played: number;
  legs_won: number;
  legs_lost: number;
  leg_diff: number;
  needs_shootout: boolean;
}

// --- Helper Components ---

const BracketView = ({ matches }: { matches: Match[] }) => {
    const rounds = useMemo(() => {
        const groups: Record<number, Match[]> = {};
        matches.forEach(m => {
            if (!groups[m.round_number]) groups[m.round_number] = [];
            groups[m.round_number].push(m);
        });
        return groups;
    }, [matches]);

    const roundNumbers = Object.keys(rounds).map(Number).sort((a, b) => a - b);
    
    const getRoundName = (matchCount: number, roundIndex: number) => {
        if (matchCount === 1) return "FINALE";
        if (matchCount === 2) return "HALVE FINALE";
        if (matchCount === 4) return "KWARTFINALE";
        if (matchCount === 8) return "LAATSTE 16";
        return `RONDE ${roundIndex + 1}`;
    };

    if (matches.length === 0) {
        return (
            <div className="bg-white p-12 rounded-lg border-2 border-dashed border-gray-300 text-center text-gray-500">
                <GitMerge className="mx-auto mb-2 opacity-20" size={40} />
                <p className="text-xl">Knockout Phase Pending...</p>
            </div>
        );
    }

    const BASE_HEIGHT = 160;
    
    return (
        <div className="overflow-x-auto pb-8 pt-4 flex justify-center">
            <div className="flex px-4">
                {roundNumbers.map((roundNum, colIndex) => {
                    const currentRoundMatches = rounds[roundNum];
                    const roundName = getRoundName(currentRoundMatches.length, colIndex);
                    const isLastColumn = colIndex === roundNumbers.length - 1;
                    const slotHeight = BASE_HEIGHT * Math.pow(2, colIndex);

                    return (
                        <div key={roundNum} className="flex flex-col w-64 md:w-80 transition-all duration-500">
                            <div className="text-center font-bold text-gray-500 uppercase text-xs mb-6 tracking-wider border-b border-gray-200 pb-2 mx-4">
                                {roundName}
                            </div>
                            <div className="flex flex-col justify-center flex-1">
                                {currentRoundMatches.map((match, matchIndex) => {
                                    const isTop = matchIndex % 2 === 0;
                                    const isBottom = matchIndex % 2 !== 0;

                                    return (
                                        <div 
                                            key={match.id} 
                                            className="relative flex items-center justify-center"
                                            style={{ height: `${slotHeight}px` }} 
                                        >
                                            {colIndex > 0 && (
                                                <div className="absolute -left-6 w-6 h-0.5 bg-gray-300"></div>
                                            )}
                                            {!isLastColumn && (
                                                <>
                                                    {isTop && (
                                                        <div className="absolute -right-6 top-1/2 w-6 border-t-2 border-r-2 border-gray-300 rounded-tr-md" style={{ height: '50%' }}></div>
                                                    )}
                                                    {isBottom && (
                                                        <div className="absolute -right-6 top-0 w-6 border-b-2 border-r-2 border-gray-300 rounded-br-md" style={{ height: '50%' }}></div>
                                                    )}
                                                </>
                                            )}

                                            <div className={`w-full mx-2 bg-white border-2 rounded-lg shadow-sm overflow-hidden text-sm relative z-10 transform transition-transform hover:scale-105
                                                ${match.is_completed ? 'border-gray-200' : 'border-blue-400 ring-2 ring-blue-100'}
                                            `}>
                                                <div className={`px-3 py-3 flex justify-between items-center border-b border-gray-100 ${match.score_p1 > match.score_p2 && match.is_completed ? 'bg-green-100 font-bold text-gray-900' : ''}`}>
                                                    <span className="truncate font-medium text-base">{match.player1_name || 'TBD'}</span>
                                                    <span className="font-mono font-bold ml-2 bg-gray-100 px-2 py-1 rounded text-gray-800 text-lg">
                                                        {match.is_completed ? match.score_p1 : '-'}
                                                    </span>
                                                </div>
                                                <div className={`px-3 py-3 flex justify-between items-center ${match.score_p2 > match.score_p1 && match.is_completed ? 'bg-green-100 font-bold text-gray-900' : ''}`}>
                                                    <span className={`truncate font-medium text-base ${!match.player2_name ? 'text-gray-400 italic' : ''}`}>
                                                        {match.player2_name ? match.player2_name : (match.is_completed ? 'BYE' : 'TBD')}
                                                    </span>
                                                    <span className="font-mono font-bold ml-2 bg-gray-100 px-2 py-1 rounded text-gray-800 text-lg">
                                                        {match.is_completed ? match.score_p2 : '-'}
                                                    </span>
                                                </div>
                                            </div>
                                        </div>
                                    );
                                })}
                            </div>
                        </div>
                    );
                })}
            </div>
        </div>
    );
};

// --- MAIN COMPONENT ---
const TournamentView = () => {
  const { public_uuid } = useParams();
  
  const [tournament, setTournament] = useState<Tournament | null>(null);
  
  // Nieuwe state voor de officiële standen uit de backend
  const [allStandings, setAllStandings] = useState<Record<number, StandingsItem[]>>({});
  
  const [loading, setLoading] = useState(true);
  
  const [activeTab, setActiveTab] = useState<number | 'ko'>(1);
  const [hasInitialized, setHasInitialized] = useState(false);
  
  const [isAutoPlay, setIsAutoPlay] = useState(false);
  const autoPlayRef = useRef<NodeJS.Timeout | null>(null);

  const loadData = async () => {
    try {
      // 1. Haal toernooi details op (inclusief matches voor de lijst)
      const res = await api.get(`/tournaments/public/${public_uuid}`);
      const tData = res.data;
      setTournament(tData);

      // 2. Haal de berekende standen op van de backend (Source of Truth)
      // We gebruiken tData.id omdat de public user dat nu heeft
      if (tData.id) {
          const standRes = await api.get(`/tournaments/${tData.id}/standings`);
          setAllStandings(standRes.data);
      }

    } catch (err) {
      console.error("Error loading tournament data", err);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    loadData();
    const interval = setInterval(loadData, 15000); 
    return () => clearInterval(interval);
  }, [public_uuid]);

  const availablePoules = useMemo(() => {
    if (!tournament) return [];
    const poules = new Set<number>();
    tournament.matches.forEach(m => {
        if (m.poule_number) poules.add(m.poule_number);
    });
    return Array.from(poules).sort((a, b) => a - b);
  }, [tournament]);

  const hasKnockout = useMemo(() => {
    return tournament?.matches.some(m => m.poule_number === null) || false;
  }, [tournament]);

  useEffect(() => {
    if (tournament && !loading) {
        if (!hasInitialized) {
            if (hasKnockout) {
                setActiveTab('ko');
                setIsAutoPlay(false);
            } else {
                if (availablePoules.length > 0) {
                    setActiveTab(availablePoules[0]);
                }
            }
            setHasInitialized(true);
        }
    }
  }, [loading, hasKnockout, hasInitialized, tournament, availablePoules]);

  useEffect(() => {
    if (isAutoPlay && !hasKnockout) { 
      autoPlayRef.current = setInterval(() => {
        setActiveTab((current) => {
          const sequence: (number | 'ko')[] = [...availablePoules];
          const currentIndex = sequence.indexOf(current);
          const nextIndex = (currentIndex + 1) % sequence.length;
          return sequence[nextIndex];
        });
      }, 10000);
    } else {
      if (autoPlayRef.current) clearInterval(autoPlayRef.current);
    }
    return () => {
      if (autoPlayRef.current) clearInterval(autoPlayRef.current);
    };
  }, [isAutoPlay, availablePoules, hasKnockout]);

  const filteredMatches = useMemo(() => {
    if (!tournament) return [];
    if (activeTab === 'ko') return tournament.matches.filter(m => m.poule_number === null);
    return tournament.matches.filter(m => m.poule_number === activeTab);
  }, [tournament, activeTab]);

  // Haal de juiste stand op uit de backend data
  const standings = useMemo(() => {
    if (activeTab === 'ko') return [];
    // We geven de lijst terug die de backend heeft berekend
    return allStandings[activeTab as number] || [];
  }, [allStandings, activeTab]);

  const handleTabClick = (tab: number | 'ko') => {
    setActiveTab(tab);
  };

  if (loading || !tournament || !hasInitialized) {
      return (
        <div className="min-h-screen bg-slate-900 flex flex-col items-center justify-center text-white gap-4">
            <RefreshCw className="animate-spin text-blue-500" size={40} />
            <span className="text-xl font-medium tracking-wide">Loading Tournament...</span>
        </div>
      );
  }

  return (
    <div className="min-h-screen bg-gray-50 flex flex-col">
      <header className="bg-slate-900 text-white p-4 lg:p-6 shadow-xl sticky top-0 z-50">
        <div className="max-w-7xl mx-auto flex justify-between items-center">
            <div>
               <h1 className="text-2xl md:text-4xl font-extrabold flex items-center gap-3 tracking-tight">
                  <Trophy className="text-yellow-400" size={32} />
                  {tournament.name}
              </h1>
              <div className="flex items-center gap-3 mt-2 opacity-80">
                <span className="text-sm font-medium bg-slate-800 px-3 py-1 rounded-full border border-slate-700">
                    {tournament.format === 'hybrid' ? 'Hybride' : tournament.format}
                </span>
                <span className={`text-sm px-3 py-1 rounded-full font-bold border ${tournament.status === 'active' ? 'bg-green-500/20 border-green-500 text-green-400' : 'bg-gray-500/20 border-gray-500'}`}>
                    {tournament.status}
                </span>
              </div>
            </div>

            <div className="flex items-center gap-4">
                {(availablePoules.length > 1 && !hasKnockout) && (
                    <button 
                        onClick={() => setIsAutoPlay(!isAutoPlay)}
                        className={`flex items-center gap-2 px-4 py-2 rounded-lg font-bold transition-all border ${
                            isAutoPlay 
                            ? 'bg-blue-600 text-white border-blue-500 shadow-[0_0_15px_rgba(37,99,235,0.5)]' 
                            : 'bg-slate-800 text-slate-400 border-slate-700 hover:bg-slate-700'
                        }`}
                    >
                        {isAutoPlay ? <Pause size={20} /> : <Play size={20} />}
                        <span className="hidden md:inline">{isAutoPlay ? 'AUTO ON' : 'TV MODE'}</span>
                    </button>
                )}
                <button 
                    onClick={loadData} 
                    className="p-2 bg-slate-800 rounded-lg hover:bg-slate-700 text-slate-400 hover:text-white transition"
                >
                    <RefreshCw size={24} />
                </button>
            </div>
        </div>
      </header>

      <main className="flex-1 max-w-7xl w-full mx-auto p-4 lg:p-8">
        <div className="flex border-b border-gray-200 mb-8 overflow-x-auto no-scrollbar gap-1">
            {availablePoules.map(num => (
                <button
                    key={num}
                    onClick={() => handleTabClick(num)}
                    className={`flex items-center gap-2 px-6 py-4 font-bold text-lg transition-all rounded-t-lg whitespace-nowrap ${
                        activeTab === num 
                        ? 'bg-white border-x border-t border-gray-200 text-blue-600 shadow-sm relative top-[1px]' 
                        : 'text-gray-400 hover:text-gray-600 hover:bg-gray-100'
                    }`}
                >
                    <LayoutGrid size={20} />
                    POULE {num}
                </button>
            ))}
            
            {hasKnockout && (
                <button
                    onClick={() => handleTabClick('ko')}
                    className={`flex items-center gap-2 px-6 py-4 font-bold text-lg transition-all rounded-t-lg whitespace-nowrap ${
                        activeTab === 'ko'
                        ? 'bg-white border-x border-t border-gray-200 text-orange-600 shadow-sm relative top-[1px]' 
                        : 'text-gray-400 hover:text-gray-600 hover:bg-gray-100'
                    }`}
                >
                    <GitMerge size={20} />
                    KNOCKOUT
                </button>
            )}
        </div>

        <div className="animate-fade-in">
            {activeTab !== 'ko' ? (
                <div className="grid gap-8 xl:grid-cols-3">
                    <div className="xl:col-span-2 flex flex-col">
                        <div className="bg-white rounded-xl shadow-lg border border-gray-100 overflow-hidden flex-1">
                            <div className="bg-gradient-to-r from-blue-600 to-blue-700 p-4 text-white">
                                <h3 className="font-bold text-xl flex items-center gap-2">
                                    <LayoutGrid size={24} /> 
                                    STANDINGS - POULE {activeTab}
                                </h3>
                            </div>
                            <div className="overflow-x-auto">
                                <table className="w-full text-left border-collapse">
                                    <thead>
                                        <tr className="bg-gray-50 text-gray-500 text-sm uppercase tracking-wider border-b border-gray-200">
                                            <th className="p-4 w-12 text-center">#</th>
                                            <th className="p-4">Player</th>
                                            <th className="p-4 text-center">W</th>
                                            <th className="p-4 text-center">L</th>
                                            <th className="p-4 text-center">+/-</th>
                                            <th className="p-4 text-center font-bold text-gray-800">PTS</th>
                                        </tr>
                                    </thead>
                                    <tbody className="text-gray-700">
                                        {standings.map((row, index) => {
                                            const isQualified = index < (tournament.qualifiers_per_poule || 2);
                                            // Bereken Winst/Verlies voor display (Backend geeft alleen punten)
                                            // Aanname: 2 punten per winst.
                                            const wins = Math.floor(row.points / 2);
                                            const losses = row.played - wins;

                                            return (
                                                <tr key={row.name} className={`border-b border-gray-50 hover:bg-blue-50/50 transition-colors ${isQualified ? 'bg-green-50/30' : ''}`}>
                                                    <td className="p-4 text-center font-mono text-gray-400">{index + 1}</td>
                                                    
                                                    <td className="p-4 font-bold text-lg flex items-center gap-3">
                                                        <span className="truncate">{row.name}</span>
                                                        {isQualified && (
                                                            <span title="Gekwalificeerd">
                                                                <Medal size={16} className="text-green-500" />
                                                            </span>
                                                        )}
                                                        {/* De Backend bepaalt nu of er een shootout nodig is */}
                                                        {row.needs_shootout && (
                                                            <span 
                                                                className="flex items-center gap-1 text-[10px] bg-red-100 text-red-600 px-2 py-0.5 rounded-full animate-pulse font-bold border border-red-200"
                                                                title="9-Dart Shoot-out vereist: Spelers staan exact gelijk"
                                                            >
                                                                <AlertCircle size={10} /> 9-DART SO
                                                            </span>
                                                        )}
                                                    </td>

                                                    <td className="p-4 text-center font-medium text-green-600">{wins}</td>
                                                    <td className="p-4 text-center text-red-400">{losses}</td>
                                                    <td className="p-4 text-center text-gray-500 font-mono">
                                                        {row.leg_diff > 0 ? `+${row.leg_diff}` : row.leg_diff}
                                                    </td>
                                                    <td className="p-4 text-center font-bold text-2xl text-blue-700">{row.points}</td>
                                                </tr>
                                            );
                                        })}
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>

                    <div className="flex flex-col">
                        <div className="bg-white rounded-xl shadow-lg border border-gray-100 overflow-hidden flex-1 max-h-[600px] flex flex-col">
                            <div className="bg-gray-100 p-4 border-b border-gray-200">
                                <h3 className="font-bold text-gray-700 text-lg">MATCHES</h3>
                            </div>
                            <div className="divide-y divide-gray-100 overflow-y-auto p-0 flex-1">
                                {filteredMatches.map((match) => (
                                    <div key={match.id} className="p-4 hover:bg-gray-50 transition-colors">
                                        <div className="flex justify-between text-xs font-bold text-gray-400 uppercase tracking-wide mb-2">
                                            <span>Ronde {match.round_number}</span>
                                            <span className="flex items-center gap-1 text-gray-500">
                                                Ref: <span className="text-gray-700">{match.referee_name || "-"}</span>
                                            </span>
                                            {match.is_completed && <span className="text-green-600 font-bold">Finished</span>}
                                        </div>
                                        <div className="flex items-center justify-between gap-2">
                                            <span className={`flex-1 truncate text-right font-medium text-lg ${match.score_p1 > match.score_p2 && match.is_completed ? 'text-gray-900 font-bold' : 'text-gray-500'}`}>
                                                {match.player1_name || 'Bye'}
                                            </span>
                                            <div className={`px-3 py-1 rounded-lg font-mono font-bold text-lg min-w-[3.5rem] text-center ${match.is_completed ? 'bg-slate-800 text-white' : 'bg-gray-100 text-gray-400'}`}>
                                                {match.is_completed ? `${match.score_p1}-${match.score_p2}` : 'VS'}
                                            </div>
                                            <span className={`flex-1 truncate text-left font-medium text-lg ${match.score_p2 > match.score_p1 && match.is_completed ? 'text-gray-900 font-bold' : 'text-gray-500'}`}>
                                                {match.player2_name || 'Bye'}
                                            </span>
                                        </div>
                                    </div>
                                ))}
                            </div>
                        </div>
                    </div>
                </div>
            ) : (
                <div className="bg-white p-4 md:p-8 rounded-xl shadow-lg border border-gray-200 overflow-x-auto min-h-[500px]">
                    <BracketView matches={filteredMatches} />
                </div>
            )}
        </div>
      </main>
    </div>
  );
};

export default TournamentView;

==================================================
FILE: frontend/src\pages\scorer\MatchList.tsx
==================================================

import { useEffect, useState } from 'react';
import { useParams, useNavigate, useSearchParams } from 'react-router-dom';
import api from '../../services/api';
import { PlayCircle, CheckCircle, Filter, GitMerge } from 'lucide-react';

interface Match {
  id: number;
  round_number: number;
  poule_number: number | null;
  player1_name: string;
  player2_name: string;
  is_completed: boolean;
  referee_name?: string;
}

const ScorerMatchList = () => {
  const { scorer_uuid } = useParams();
  const navigate = useNavigate();
  const [searchParams] = useSearchParams();
  
  const [matches, setMatches] = useState<Match[]>([]);
  const [loading, setLoading] = useState(true);

  // Read the 'poule' parameter. It might be a number ("1") or "ko"
  const pouleFilter = searchParams.get('poule');

  useEffect(() => {
    const loadMatches = async () => {
      try {
        const res = await api.get(`/matches/by-tournament/${scorer_uuid}`);
        setMatches(res.data);
      } catch (err) {
        alert("Invalid Scorer Link");
      } finally {
        setLoading(false);
      }
    };
    loadMatches();
  }, [scorer_uuid]);

  // --- UPDATED FILTER LOGIC ---
  const displayedMatches = matches.filter(match => {
    // 1. Show all if no filter
    if (!pouleFilter) return true;

    // 2. Show Knockout Matches (where poule_number is null)
    if (pouleFilter === 'ko') return match.poule_number === null;

    // 3. Show Specific Poule Matches
    return match.poule_number === parseInt(pouleFilter);
  });

  // Helper title text
  const getTitle = () => {
      if (pouleFilter === 'ko') return "Knockout Phase";
      if (pouleFilter) return `Poule ${pouleFilter}`;
      return "All Matches";
  };

  if (loading) return <div className="p-8 text-center text-white">Loading Matches...</div>;

  return (
    <div className="min-h-screen bg-slate-900 text-white p-4">
      <div className="text-center mb-6">
        <h1 className="text-2xl font-bold text-blue-400 flex items-center justify-center gap-2">
          {pouleFilter === 'ko' && <GitMerge />}
          {getTitle()}
        </h1>
        <p className="text-slate-500 text-sm">Select a match to start scoring</p>
      </div>
      
      {displayedMatches.length === 0 ? (
         <div className="text-center p-8 bg-slate-800 rounded-xl border border-slate-700 text-slate-400">
            <Filter className="mx-auto mb-2" />
            <p>No matches found for this view.</p>
         </div>
      ) : (
        <div className="space-y-3 max-w-lg mx-auto">
          {displayedMatches.map((match) => (
            <div 
              key={match.id}
              onClick={() => navigate(`/board/${scorer_uuid}/match/${match.id}`)}
              className={`p-4 rounded-xl border border-slate-700 flex justify-between items-center cursor-pointer transition-transform active:scale-95 ${
                match.is_completed ? 'bg-slate-800 opacity-60' : 'bg-slate-800 hover:bg-slate-700 shadow-lg'
              }`}
            >
              <div className="flex-1 text-center">
                <div className="mb-1">
                   <span className={`text-xs font-mono px-2 py-0.5 rounded ${match.poule_number ? 'bg-slate-900 text-slate-400' : 'bg-orange-900/30 text-orange-400 border border-orange-900/50'}`}>
                     {match.poule_number ? `P${match.poule_number}` : `KO - R${match.round_number}`}
                   </span>
                </div>

                <div className="font-bold text-lg">{match.player1_name || 'Bye'}</div>
                <div className="text-xs text-slate-400">VS</div>
                <div className="font-bold text-lg">{match.player2_name || 'Bye'}</div>

                <div className="mt-2 text-xs text-slate-500 font-mono border-t border-slate-700 pt-1 inline-block px-2">
                        Ref: <span className="text-slate-300">{match.referee_name || "-"}</span>
                </div>


              </div>
              
              <div className="ml-4">
                {match.is_completed ? (
                  <CheckCircle className="text-green-500" size={32} />
                ) : (
                  <PlayCircle className="text-blue-400" size={32} />
                )}
              </div>
            </div>
          ))}
        </div>
      )}
    </div>
  );
};

export default ScorerMatchList;

==================================================
FILE: frontend/src\pages\scorer\Scoreboard.tsx
==================================================

import { useEffect, useState } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import api from '../../services/api';
import { ArrowLeft, Save } from 'lucide-react';

const Scoreboard = () => {
  const { scorer_uuid, match_id } = useParams();
  const navigate = useNavigate();

  // Game State
  const [scoreP1, setScoreP1] = useState(0);
  const [scoreP2, setScoreP2] = useState(0);
  const [isCompleted, setIsCompleted] = useState(false);
  const [playerNames, setPlayerNames] = useState({ p1: 'Player 1', p2: 'Player 2' });

  // Load Match Data
  useEffect(() => {
    api.get(`/matches/by-tournament/${scorer_uuid}`).then(res => {
      const match = res.data.find((m: any) => m.id === Number(match_id));
      if (match) {
        setPlayerNames({ p1: match.player1_name, p2: match.player2_name });
        setScoreP1(match.score_p1);
        setScoreP2(match.score_p2);
        setIsCompleted(match.is_completed);
      }
    });
  }, [scorer_uuid, match_id]);

  const updateScore = async (p1: number, p2: number, completed: boolean) => {
    try {
      // 1. Send to Backend FIRST
      await api.put(
        `/matches/${match_id}/score`, 
        {
          score_p1: p1,
          score_p2: p2,
          is_completed: completed
        },
        {
          headers: { 'X-Scorer-Token': scorer_uuid }
        }
      );

      // 2. If successful, Update UI
      setScoreP1(p1);
      setScoreP2(p2);
      setIsCompleted(completed);

      // 3. If we marked it as completed, go back to the list
      if (completed) {
        navigate(-1); 
      }

    } catch (err: any) {
      console.error("Failed to sync score");
      
      // 4. FEEDBACK SYSTEM: Show the backend validation error
      // This will catch "Impossible score" errors from the Best of X logic
      const msg = err.response?.data?.detail || "Error updating score";
      alert("⚠️ " + msg);
    }
  };

  return (
    <div className="min-h-screen bg-black text-white flex flex-col">
      {/* Header */}
      <div className="p-4 bg-slate-900 flex items-center justify-between">
        <button onClick={() => navigate(-1)} className="text-slate-400">
          <ArrowLeft />
        </button>
        <span className="font-mono text-yellow-400 font-bold">MATCH {match_id}</span>
        <div className="w-6" /> 
      </div>

      {/* Score Display */}
      <div className="flex-1 flex flex-col justify-center items-center gap-8 p-4">
        
        {/* Player 1 */}
        <div className="w-full bg-slate-800 rounded-2xl p-6 flex justify-between items-center border border-slate-700">
          <span className="text-xl font-bold text-blue-300 truncate w-32">{playerNames.p1}</span>
          <div className="flex items-center gap-4">
             <button 
                onClick={() => updateScore(Math.max(0, scoreP1 - 1), scoreP2, false)}
                className="w-12 h-12 rounded-full bg-slate-700 text-2xl font-bold text-white hover:bg-slate-600"
             >-</button>
             <span className="text-6xl font-mono font-bold w-24 text-center">{scoreP1}</span>
             <button 
                onClick={() => updateScore(scoreP1 + 1, scoreP2, false)}
                className="w-12 h-12 rounded-full bg-blue-600 text-2xl font-bold text-white hover:bg-blue-500"
             >+</button>
          </div>
        </div>

        {/* VS Divider */}
        <div className="text-slate-500 font-bold">LEGS WON</div>

        {/* Player 2 */}
        <div className="w-full bg-slate-800 rounded-2xl p-6 flex justify-between items-center border border-slate-700">
          <span className="text-xl font-bold text-blue-300 truncate w-32">{playerNames.p2}</span>
          <div className="flex items-center gap-4">
             <button 
                onClick={() => updateScore(scoreP1, Math.max(0, scoreP2 - 1), false)}
                className="w-12 h-12 rounded-full bg-slate-700 text-2xl font-bold text-white hover:bg-slate-600"
             >-</button>
             <span className="text-6xl font-mono font-bold w-24 text-center">{scoreP2}</span>
             <button 
                onClick={() => updateScore(scoreP1, scoreP2 + 1, false)}
                className="w-12 h-12 rounded-full bg-blue-600 text-2xl font-bold text-white hover:bg-blue-500"
             >+</button>
          </div>
        </div>
      </div>

      {/* Footer Controls */}
      <div className="p-6 bg-slate-900 border-t border-slate-800">
        <button 
          onClick={() => {
            // Note: We don't manually navigate here anymore. 
            // updateScore handles navigation on success.
            updateScore(scoreP1, scoreP2, !isCompleted);
          }}
          className={`w-full py-4 rounded-xl text-xl font-bold flex items-center justify-center gap-3 transition-colors ${
            isCompleted 
            ? 'bg-slate-700 text-slate-300' 
            : 'bg-green-600 text-white hover:bg-green-500'
          }`}
        >
          <Save size={24} />
          {isCompleted ? 'Mark as In Progress' : 'Finish Match'}
        </button>
      </div>
    </div>
  );
};

export default Scoreboard;

==================================================
FILE: frontend/src\services\api.ts
==================================================

import axios from 'axios';

// 1. Create the instance (like requests.Session())
// const api = axios.create({
//   baseURL: 'http://localhost:8000/api', // Point to your FastAPI backend
//   headers: {
//     'Content-Type': 'application/json',
//   },
// });


const api = axios.create({
  // Verwijder de hardcoded localhost URL. 
  // Omdat Nginx op hetzelfde domein draait, gebruiken we een relatieve URL.
  // Als je app draait op http://mijn-server-ip/, wordt dit automatisch http://mijn-server-ip/api
  baseURL: '/api', 
  headers: {
    'Content-Type': 'application/json',
  },
});

// 2. Add an "Interceptor" (Middleware)
// Before every request is sent, check if we have a token in LocalStorage (browser memory)
api.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem('token');
    if (token) {
      // If token exists, attach it: Authorization: Bearer <token>
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

// This listens to every response coming BACK from the backend.
api.interceptors.response.use(
  (response) => {
    // If the response is good (status 200-299), just return it.
    return response;
  },
  (error) => {
    // If the backend returns 401 Unauthorized, the token is invalid/expired.
    if (error.response && error.response.status === 401) {
      // 1. Remove the bad token
      localStorage.removeItem('token');
      
      // 2. Redirect to login page
      // We use window.location because this file is not a React component,
      // so we can't use the useNavigate hook here.
      if (window.location.pathname !== '/login') {
         window.location.href = '/login';
      }
    }
    
    // Pass the error along so specific components can still handle it if needed
    return Promise.reject(error);
  }
);

export default api;

==================================================
FILE: frontend/src\services\authService.ts
==================================================

import api from './api';

// The data shape expected by FastAPI's OAuth2PasswordRequestForm
// It expects form-data, not JSON!
export const loginUser = async (username: string, password: string) => {
  const formData = new FormData();
  formData.append('username', username);
  formData.append('password', password);

  const response = await api.post('/auth/login', formData, {
    headers: {
      'Content-Type': 'application/x-www-form-urlencoded',
    },
  });
  return response.data; // Returns { access_token: "...", token_type: "bearer" }
};

export const registerUser = async (userData: any) => {
    const response = await api.post('/auth/register', userData);
    return response.data;
};

==================================================
FILE: frontend/src\types\index.ts
==================================================

export interface User {
  id: number;
  email: string;
  first_name: string;
  last_name: string;
}

export interface Player {
  id: number;
  first_name: string;
  last_name?: string;
  nickname?: string;
  email?: string;
  name: string;
}

export interface Dartboard {
  id: number;
  name: string;
  number: number;
}

export interface Tournament {
  id: number;
  name: string;
  date: string;
  status: string; // 'draft', 'active', 'completed'
  format: string;
  public_uuid?: string;
  scorer_uuid?: string;
  
  // Nieuwe velden die het dashboard nodig heeft:
  number_of_poules?: number;
  player_count?: number;
  board_count?: number;
  allow_byes?: boolean; 
}

// We voegen Match en Leg later toe
export interface Match {
    id: number;
    player1_id?: number | null;
    player2_id?: number | null;

    team1_id?: number | null;
    team2_id?: number | null;
    team1?: { id: number; name: string } | null;
    team2?: { id: number; name: string } | null;


    player1?: Player | null;
    player2?: Player | null;

    referee_name?: string;
}

export interface Team {
  id: number;
  name: string;
  players: Player[];
}
